{"remainingRequest":"/home/vignesh/DIVRT/guest-webapp/node_modules/vue-loader/lib/index.js??vue-loader-options!/home/vignesh/DIVRT/guest-webapp/src/uiComponents/VueTimePicker.vue?vue&type=script&lang=js&","dependencies":[{"path":"/home/vignesh/DIVRT/guest-webapp/src/uiComponents/VueTimePicker.vue","mtime":1678170570029},{"path":"/home/vignesh/DIVRT/guest-webapp/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/vignesh/DIVRT/guest-webapp/node_modules/babel-loader/lib/index.js","mtime":315532800000},{"path":"/home/vignesh/DIVRT/guest-webapp/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/vignesh/DIVRT/guest-webapp/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:CmNvbnN0IENPTkZJRyA9IHsKICAgIEhPVVJfVE9LRU5TOiBbJ0hIJywgJ0gnLCAnaGgnLCAnaCcsICdraycsICdrJ10sCiAgICBNSU5VVEVfVE9LRU5TOiBbJ21tJywgJ20nXSwKICAgIFNFQ09ORF9UT0tFTlM6IFsnc3MnLCAncyddLAogICAgQVBNX1RPS0VOUzogWydBJywgJ2EnXSwKICAgIEJBU0lDX1RZUEVTOiBbJ2hvdXInLCAnbWludXRlJywgJ3NlY29uZCcsICdhcG0nXQp9Cgpjb25zdCBERUZBVUxUX09QVElPTlMgPSB7CiAgICBmb3JtYXQ6ICdISDptbScsCiAgICBtaW51dGVJbnRlcnZhbDogMSwKICAgIHNlY29uZEludGVydmFsOiAxLAogICAgaG91clJhbmdlOiBudWxsLAogICAgbWludXRlUmFuZ2U6IG51bGwsCiAgICBzZWNvbmRSYW5nZTogbnVsbCwKICAgIGhpZGVEaXNhYmxlZEhvdXJzOiBmYWxzZSwKICAgIGhpZGVEaXNhYmxlZE1pbnV0ZXM6IGZhbHNlLAogICAgaGlkZURpc2FibGVkU2Vjb25kczogZmFsc2UsCiAgICBoaWRlRGlzYWJsZWRJdGVtczogZmFsc2UsCiAgICBoaWRlRHJvcGRvd246IGZhbHNlLAogICAgYmx1ckRlbGF5OiAzMDAsCiAgICBtYW51YWxJbnB1dFRpbWVvdXQ6IDEwMDAsCiAgICBkcm9wT2Zmc2V0SGVpZ2h0OiAxNjAKfQoKZXhwb3J0IGRlZmF1bHQgewogICAgbmFtZTogJ1Z1ZVRpbWVwaWNrZXInLAogICAgcHJvcHM6IHsKICAgICAgICB2YWx1ZTogeyB0eXBlOiBbT2JqZWN0LCBTdHJpbmddIH0sCiAgICAgICAgZm9ybWF0OiB7IHR5cGU6IFN0cmluZyB9LAogICAgICAgIG1pbnV0ZUludGVydmFsOiB7IHR5cGU6IFtOdW1iZXIsIFN0cmluZ10gfSwKICAgICAgICBzZWNvbmRJbnRlcnZhbDogeyB0eXBlOiBbTnVtYmVyLCBTdHJpbmddIH0sCgogICAgICAgIGhvdXJSYW5nZTogeyB0eXBlOiBBcnJheSB9LAogICAgICAgIG1pbnV0ZVJhbmdlOiB7IHR5cGU6IEFycmF5IH0sCiAgICAgICAgc2Vjb25kUmFuZ2U6IHsgdHlwZTogQXJyYXkgfSwKICAgICAgICBhcG1MYWJlbEVuYWJsZWQ6IHsgdHlwZTogQm9vbGVhbiwgZGVmYXVsdDogZmFsc2UgfSwKICAgICAgICBoaWRlRGlzYWJsZWRIb3VyczogeyB0eXBlOiBCb29sZWFuLCBkZWZhdWx0OiBmYWxzZSB9LAogICAgICAgIGhpZGVEaXNhYmxlZE1pbnV0ZXM6IHsgdHlwZTogQm9vbGVhbiwgZGVmYXVsdDogZmFsc2UgfSwKICAgICAgICBoaWRlRGlzYWJsZWRTZWNvbmRzOiB7IHR5cGU6IEJvb2xlYW4sIGRlZmF1bHQ6IGZhbHNlIH0sCiAgICAgICAgaGlkZURpc2FibGVkSXRlbXM6IHsgdHlwZTogQm9vbGVhbiwgZGVmYXVsdDogZmFsc2UgfSwKCiAgICAgICAgaGlkZUNsZWFyQnV0dG9uOiB7IHR5cGU6IEJvb2xlYW4sIGRlZmF1bHQ6IGZhbHNlIH0sCiAgICAgICAgZGlzYWJsZWQ6IHsgdHlwZTogQm9vbGVhbiwgZGVmYXVsdDogZmFsc2UgfSwKICAgICAgICBjbG9zZU9uQ29tcGxldGU6IHsgdHlwZTogQm9vbGVhbiwgZGVmYXVsdDogZmFsc2UgfSwKCiAgICAgICAgaWQ6IHsgdHlwZTogU3RyaW5nIH0sCiAgICAgICAgbmFtZTogeyB0eXBlOiBTdHJpbmcgfSwKICAgICAgICBpbnB1dENsYXNzOiB7IHR5cGU6IFtTdHJpbmcsIE9iamVjdCwgQXJyYXldIH0sCiAgICAgICAgcGxhY2Vob2xkZXI6IHsgdHlwZTogU3RyaW5nIH0sCiAgICAgICAgdGFiaW5kZXg6IHsgdHlwZTogW051bWJlciwgU3RyaW5nXSwgZGVmYXVsdDogMCB9LAogICAgICAgIGlucHV0V2lkdGg6IHsgdHlwZTogU3RyaW5nIH0sCiAgICAgICAgYXV0b2NvbXBsZXRlOiB7IHR5cGU6IFN0cmluZywgZGVmYXVsdDogJ29mZicgfSwKCiAgICAgICAgaG91ckxhYmVsOiB7IHR5cGU6IFN0cmluZyB9LAogICAgICAgIG1pbnV0ZUxhYmVsOiB7IHR5cGU6IFN0cmluZyB9LAogICAgICAgIHNlY29uZExhYmVsOiB7IHR5cGU6IFN0cmluZyB9LAogICAgICAgIGFwbUxhYmVsOiB7IHR5cGU6IFN0cmluZyB9LAogICAgICAgIGFtVGV4dDogeyB0eXBlOiBTdHJpbmcgfSwKICAgICAgICBwbVRleHQ6IHsgdHlwZTogU3RyaW5nIH0sCgogICAgICAgIGJsdXJEZWxheTogeyB0eXBlOiBbTnVtYmVyLCBTdHJpbmddIH0sCiAgICAgICAgYWR2YW5jZWRLZXlib2FyZDogeyB0eXBlOiBCb29sZWFuLCBkZWZhdWx0OiBmYWxzZSB9LAoKICAgICAgICBsYXp5OiB7IHR5cGU6IEJvb2xlYW4sIGRlZmF1bHQ6IGZhbHNlIH0sCiAgICAgICAgYXV0b1Njcm9sbDogeyB0eXBlOiBCb29sZWFuLCBkZWZhdWx0OiBmYWxzZSB9LAoKICAgICAgICBkcm9wRGlyZWN0aW9uOiB7IHR5cGU6IFN0cmluZywgZGVmYXVsdDogJ2Rvd24nIH0sCiAgICAgICAgZHJvcE9mZnNldEhlaWdodDogeyB0eXBlOiBbTnVtYmVyLCBTdHJpbmddIH0sCiAgICAgICAgY29udGFpbmVySWQ6IHsgdHlwZTogU3RyaW5nIH0sCiAgICAgICAgYXBwZW5kVG9Cb2R5OiB7IHR5cGU6IEJvb2xlYW4sIGRlZmF1bHQ6IGZhbHNlIH0sCgogICAgICAgIG1hbnVhbElucHV0OiB7IHR5cGU6IEJvb2xlYW4sIGRlZmF1bHQ6IGZhbHNlIH0sCiAgICAgICAgbWFudWFsSW5wdXRUaW1lb3V0OiB7IHR5cGU6IFtOdW1iZXIsIFN0cmluZ10gfSwKICAgICAgICBoaWRlRHJvcGRvd246IHsgdHlwZTogQm9vbGVhbiwgZGVmYXVsdDogZmFsc2UgfSwKICAgICAgICBmaXhlZERyb3Bkb3duQnV0dG9uOiB7IHR5cGU6IEJvb2xlYW4sIGRlZmF1bHQ6IGZhbHNlIH0sCgogICAgICAgIGRlYnVnTW9kZTogeyB0eXBlOiBCb29sZWFuLCBkZWZhdWx0OiBmYWxzZSB9CiAgICB9LAoKICAgIGRhdGEoKSB7CiAgICAgICAgcmV0dXJuIHsKICAgICAgICAgICAgdGltZVZhbHVlOiB7fSwKCiAgICAgICAgICAgIGhvdXJzOiBbXSwKICAgICAgICAgICAgbWludXRlczogW10sCiAgICAgICAgICAgIHNlY29uZHM6IFtdLAogICAgICAgICAgICBhcG1zOiBbXSwKCiAgICAgICAgICAgIGlzQWN0aXZlOiBmYWxzZSwKICAgICAgICAgICAgc2hvd0Ryb3Bkb3duOiBmYWxzZSwKICAgICAgICAgICAgaXNGb2N1c2luZzogZmFsc2UsCiAgICAgICAgICAgIGRlYm91bmNlVGltZXI6IHVuZGVmaW5lZCwKCiAgICAgICAgICAgIGhvdXJUeXBlOiAnSEgnLAogICAgICAgICAgICBtaW51dGVUeXBlOiAnbW0nLAogICAgICAgICAgICBzZWNvbmRUeXBlOiAnJywKICAgICAgICAgICAgYXBtVHlwZTogJycsCiAgICAgICAgICAgIGhvdXI6ICcnLAogICAgICAgICAgICBtaW51dGU6ICcnLAogICAgICAgICAgICBzZWNvbmQ6ICcnLAogICAgICAgICAgICBhcG06ICcnLAogICAgICAgICAgICBmdWxsVmFsdWVzOiB1bmRlZmluZWQsCiAgICAgICAgICAgIGJha0Rpc3BsYXlUaW1lOiB1bmRlZmluZWQsCiAgICAgICAgICAgIGRvQ2xlYXJBcG1DaGVja2luZzogZmFsc2UsCgogICAgICAgICAgICBzZWxlY3Rpb25UaW1lcjogdW5kZWZpbmVkLAogICAgICAgICAgICBrYklucHV0VGltZXI6IHVuZGVmaW5lZCwKICAgICAgICAgICAga2JJbnB1dExvZzogJycsCiAgICAgICAgICAgIGJha0N1cnJlbnRQb3M6IHVuZGVmaW5lZCwKICAgICAgICAgICAgZm9yY2VEcm9wT25Ub3A6IGZhbHNlCiAgICAgICAgfQogICAgfSwKCiAgICBjb21wdXRlZDogewogICAgICAgIG9wdHMoKSB7CiAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX09QVElPTlMpCgogICAgICAgICAgICBpZiAodGhpcy5mb3JtYXQgJiYgdGhpcy5mb3JtYXQubGVuZ3RoKSB7CiAgICAgICAgICAgICAgICBvcHRpb25zLmZvcm1hdCA9IFN0cmluZyh0aGlzLmZvcm1hdCkKICAgICAgICAgICAgfQoKICAgICAgICAgICAgaWYgKHRoaXMuaXNOdW1iZXIodGhpcy5taW51dGVJbnRlcnZhbCkpIHsKICAgICAgICAgICAgICAgIG9wdGlvbnMubWludXRlSW50ZXJ2YWwgPSArdGhpcy5taW51dGVJbnRlcnZhbAogICAgICAgICAgICB9CiAgICAgICAgICAgIC8vIG1pbnV0ZUludGVydmFsIGZhaWxzYWZlCiAgICAgICAgICAgIGlmICghb3B0aW9ucy5taW51dGVJbnRlcnZhbCB8fCBvcHRpb25zLm1pbnV0ZUludGVydmFsIDwgMSB8fCBvcHRpb25zLm1pbnV0ZUludGVydmFsID4gNjApIHsKICAgICAgICAgICAgICAgIGlmICh0aGlzLmRlYnVnTW9kZSkgewogICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLm1pbnV0ZUludGVydmFsID4gNjApIHsKICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWJ1Z0xvZyhgIm1pbnV0ZS1pbnRlcnZhbCIgc2hvdWxkIGJlIGxlc3MgdGhhbiA2MC4gQ3VycmVudCB2YWx1ZSBpcyAke3RoaXMubWludXRlSW50ZXJ2YWx9YCkKICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMubWludXRlSW50ZXJ2YWwgPT09IDAgfHwgb3B0aW9ucy5taW51dGVJbnRlcnZhbCA8IDEpIHsKICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWJ1Z0xvZyhgIm1pbnV0ZS1pbnRlcnZhbCIgc2hvdWxkIGJlIE5PIGxlc3MgdGhhbiAxLiBDdXJyZW50IHZhbHVlIGlzICR7dGhpcy5taW51dGVJbnRlcnZhbH1gKQogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLm1pbnV0ZUludGVydmFsID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5taW51dGVJbnRlcnZhbCA9IDYwCiAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgIG9wdGlvbnMubWludXRlSW50ZXJ2YWwgPSAxCiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIGlmICh0aGlzLmlzTnVtYmVyKHRoaXMuc2Vjb25kSW50ZXJ2YWwpKSB7CiAgICAgICAgICAgICAgICBvcHRpb25zLnNlY29uZEludGVydmFsID0gK3RoaXMuc2Vjb25kSW50ZXJ2YWwKICAgICAgICAgICAgfQogICAgICAgICAgICAvLyBzZWNvbmRJbnRlcnZhbCBmYWlsc2FmZQogICAgICAgICAgICBpZiAoIW9wdGlvbnMuc2Vjb25kSW50ZXJ2YWwgfHwgb3B0aW9ucy5zZWNvbmRJbnRlcnZhbCA8IDEgfHwgb3B0aW9ucy5zZWNvbmRJbnRlcnZhbCA+IDYwKSB7CiAgICAgICAgICAgICAgICBpZiAodGhpcy5kZWJ1Z01vZGUpIHsKICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5zZWNvbmRJbnRlcnZhbCA+IDYwKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVidWdMb2coYCJzZWNvbmQtaW50ZXJ2YWwiIHNob3VsZCBiZSBsZXNzIHRoYW4gNjAuIEN1cnJlbnQgdmFsdWUgaXMgJHt0aGlzLnNlY29uZEludGVydmFsfWApCiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLnNlY29uZEludGVydmFsID09PSAwIHx8IG9wdGlvbnMuc2Vjb25kSW50ZXJ2YWwgPCAxKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVidWdMb2coYCJzZWNvbmQtaW50ZXJ2YWwiIHNob3VsZCBiZSBOTyBsZXNzIHRoYW4gMS4gQ3VycmVudCB2YWx1ZSBpcyAke3RoaXMuc2Vjb25kSW50ZXJ2YWx9YCkKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5zZWNvbmRJbnRlcnZhbCA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuc2Vjb25kSW50ZXJ2YWwgPSA2MAogICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnNlY29uZEludGVydmFsID0gMQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CgogICAgICAgICAgICBpZiAodGhpcy5ob3VyUmFuZ2UgJiYgQXJyYXkuaXNBcnJheSh0aGlzLmhvdXJSYW5nZSkpIHsKICAgICAgICAgICAgICAgIG9wdGlvbnMuaG91clJhbmdlID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0aGlzLmhvdXJSYW5nZSkpCiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaG91clJhbmdlLmxlbmd0aCAmJiB0aGlzLmRlYnVnTW9kZSkgewogICAgICAgICAgICAgICAgICAgIHRoaXMuZGVidWdMb2coJ1RoZSAiaG91ci1yYW5nZSIgYXJyYXkgaXMgZW1wdHkgKGxlbmd0aCA9PT0gMCknKQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CgogICAgICAgICAgICBpZiAodGhpcy5taW51dGVSYW5nZSAmJiBBcnJheS5pc0FycmF5KHRoaXMubWludXRlUmFuZ2UpKSB7CiAgICAgICAgICAgICAgICBvcHRpb25zLm1pbnV0ZVJhbmdlID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0aGlzLm1pbnV0ZVJhbmdlKSkKICAgICAgICAgICAgICAgIGlmICghdGhpcy5taW51dGVSYW5nZS5sZW5ndGggJiYgdGhpcy5kZWJ1Z01vZGUpIHsKICAgICAgICAgICAgICAgICAgICB0aGlzLmRlYnVnTG9nKCdUaGUgIm1pbnV0ZS1yYW5nZSIgYXJyYXkgaXMgZW1wdHkgKGxlbmd0aCA9PT0gMCknKQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CgogICAgICAgICAgICBpZiAodGhpcy5zZWNvbmRSYW5nZSAmJiBBcnJheS5pc0FycmF5KHRoaXMuc2Vjb25kUmFuZ2UpKSB7CiAgICAgICAgICAgICAgICBvcHRpb25zLnNlY29uZFJhbmdlID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0aGlzLnNlY29uZFJhbmdlKSkKICAgICAgICAgICAgICAgIGlmICghdGhpcy5zZWNvbmRSYW5nZS5sZW5ndGggJiYgdGhpcy5kZWJ1Z01vZGUpIHsKICAgICAgICAgICAgICAgICAgICB0aGlzLmRlYnVnTG9nKCdUaGUgInNlY29uZC1yYW5nZSIgYXJyYXkgaXMgZW1wdHkgKGxlbmd0aCA9PT0gMCknKQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CgogICAgICAgICAgICBpZiAodGhpcy5oaWRlRGlzYWJsZWRJdGVtcykgewogICAgICAgICAgICAgICAgb3B0aW9ucy5oaWRlRGlzYWJsZWRJdGVtcyA9IHRydWUKICAgICAgICAgICAgfQoKICAgICAgICAgICAgaWYgKHRoaXMuaGlkZURpc2FibGVkSG91cnMgfHwgdGhpcy5oaWRlRGlzYWJsZWRJdGVtcykgewogICAgICAgICAgICAgICAgb3B0aW9ucy5oaWRlRGlzYWJsZWRIb3VycyA9IHRydWUKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAodGhpcy5oaWRlRGlzYWJsZWRNaW51dGVzIHx8IHRoaXMuaGlkZURpc2FibGVkSXRlbXMpIHsKICAgICAgICAgICAgICAgIG9wdGlvbnMuaGlkZURpc2FibGVkTWludXRlcyA9IHRydWUKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAodGhpcy5oaWRlRGlzYWJsZWRTZWNvbmRzIHx8IHRoaXMuaGlkZURpc2FibGVkSXRlbXMpIHsKICAgICAgICAgICAgICAgIG9wdGlvbnMuaGlkZURpc2FibGVkU2Vjb25kcyA9IHRydWUKICAgICAgICAgICAgfQoKICAgICAgICAgICAgaWYgKHRoaXMuaGlkZURyb3Bkb3duKSB7CiAgICAgICAgICAgICAgICBpZiAodGhpcy5tYW51YWxJbnB1dCkgewogICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuaGlkZURyb3Bkb3duID0gdHJ1ZQogICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmRlYnVnTW9kZSkgewogICAgICAgICAgICAgICAgICAgIHRoaXMuZGVidWdMb2coJyJoaWRlLWRyb3Bkb3duIiBvbmx5IHdvcmtzIHdpdGggIm1hbnVhbC1pbnB1dCIgbW9kZScpCiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIGlmICh0aGlzLmJsdXJEZWxheSAmJiArdGhpcy5ibHVyRGVsYXkgPiAwKSB7CiAgICAgICAgICAgICAgICBvcHRpb25zLmJsdXJEZWxheSA9ICt0aGlzLmJsdXJEZWxheQogICAgICAgICAgICB9CgogICAgICAgICAgICBpZiAodGhpcy5tYW51YWxJbnB1dFRpbWVvdXQgJiYgK3RoaXMubWFudWFsSW5wdXRUaW1lb3V0ID4gMCkgewogICAgICAgICAgICAgICAgb3B0aW9ucy5tYW51YWxJbnB1dFRpbWVvdXQgPSArdGhpcy5tYW51YWxJbnB1dFRpbWVvdXQKICAgICAgICAgICAgfQoKICAgICAgICAgICAgaWYgKHRoaXMuZHJvcE9mZnNldEhlaWdodCAmJiArdGhpcy5kcm9wT2Zmc2V0SGVpZ2h0ID4gMCkgewogICAgICAgICAgICAgICAgb3B0aW9ucy5kcm9wT2Zmc2V0SGVpZ2h0ID0gK3RoaXMuZHJvcE9mZnNldEhlaWdodAogICAgICAgICAgICB9CgogICAgICAgICAgICByZXR1cm4gb3B0aW9ucwogICAgICAgIH0sCgogICAgICAgIHVzZVN0cmluZ1ZhbHVlKCkgewogICAgICAgICAgICByZXR1cm4gdHlwZW9mIHRoaXMudmFsdWUgPT09ICdzdHJpbmcnCiAgICAgICAgfSwKCiAgICAgICAgZm9ybWF0U3RyaW5nKCkgewogICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRzLmZvcm1hdCB8fCBERUZBVUxUX09QVElPTlMuZm9ybWF0CiAgICAgICAgfSwKCiAgICAgICAgaW5Vc2UoKSB7CiAgICAgICAgICAgIGNvbnN0IHR5cGVzSW5Vc2UgPSBDT05GSUcuQkFTSUNfVFlQRVMuZmlsdGVyKHR5cGUgPT4gdGhpcy5nZXRUb2tlbkJ5VHlwZSh0eXBlKSkKICAgICAgICAgICAgLy8gU29ydCB0eXBlcyBhbmQgdG9rZW5zIGJ5IHRoZWlyIHNlcXVlbmNlIGluIHRoZSAiZm9ybWF0IiBzdHJpbmcKICAgICAgICAgICAgdHlwZXNJblVzZS5zb3J0KChsLCByKSA9PiB7CiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXRTdHJpbmcuaW5kZXhPZih0aGlzLmdldFRva2VuQnlUeXBlKGwpIHx8IG51bGwpIC0gdGhpcy5mb3JtYXRTdHJpbmcuaW5kZXhPZih0aGlzLmdldFRva2VuQnlUeXBlKHIpIHx8IG51bGwpCiAgICAgICAgICAgIH0pCiAgICAgICAgICAgIGNvbnN0IHRva2Vuc0luVXNlID0gdHlwZXNJblVzZS5tYXAodHlwZSA9PiB0aGlzLmdldFRva2VuQnlUeXBlKHR5cGUpKQogICAgICAgICAgICByZXR1cm4gewogICAgICAgICAgICAgICAgaG91cjogISF0aGlzLmhvdXJUeXBlLAogICAgICAgICAgICAgICAgbWludXRlOiAhIXRoaXMubWludXRlVHlwZSwKICAgICAgICAgICAgICAgIHNlY29uZDogISF0aGlzLnNlY29uZFR5cGUsCiAgICAgICAgICAgICAgICBhcG06ICEhdGhpcy5hcG1UeXBlLAogICAgICAgICAgICAgICAgdHlwZXM6IHR5cGVzSW5Vc2UgfHwgW10sCiAgICAgICAgICAgICAgICB0b2tlbnM6IHRva2Vuc0luVXNlIHx8IFtdCiAgICAgICAgICAgIH0KICAgICAgICB9LAoKICAgICAgICBkaXNwbGF5VGltZSgpIHsKICAgICAgICAgICAgbGV0IGZvcm1hdFN0cmluZyA9IFN0cmluZyh0aGlzLmZvcm1hdFN0cmluZykKICAgICAgICAgICAgaWYgKHRoaXMuaG91cikgewogICAgICAgICAgICAgICAgZm9ybWF0U3RyaW5nID0gZm9ybWF0U3RyaW5nLnJlcGxhY2UobmV3IFJlZ0V4cCh0aGlzLmhvdXJUeXBlLCAnZycpLCB0aGlzLmhvdXIpCiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKHRoaXMubWludXRlKSB7CiAgICAgICAgICAgICAgICBmb3JtYXRTdHJpbmcgPSBmb3JtYXRTdHJpbmcucmVwbGFjZShuZXcgUmVnRXhwKHRoaXMubWludXRlVHlwZSwgJ2cnKSwgdGhpcy5taW51dGUpCiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKHRoaXMuc2Vjb25kICYmIHRoaXMuc2Vjb25kVHlwZSkgewogICAgICAgICAgICAgICAgZm9ybWF0U3RyaW5nID0gZm9ybWF0U3RyaW5nLnJlcGxhY2UobmV3IFJlZ0V4cCh0aGlzLnNlY29uZFR5cGUsICdnJyksIHRoaXMuc2Vjb25kKQogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmICh0aGlzLmFwbSAmJiB0aGlzLmFwbVR5cGUpIHsKICAgICAgICAgICAgICAgIGZvcm1hdFN0cmluZyA9IGZvcm1hdFN0cmluZy5yZXBsYWNlKG5ldyBSZWdFeHAodGhpcy5hcG1UeXBlLCAnZycpLCB0aGlzLmFwbSkKICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gZm9ybWF0U3RyaW5nCiAgICAgICAgfSwKCiAgICAgICAgY3VzdG9tRGlzcGxheVRpbWUoKSB7CiAgICAgICAgICAgIGlmICghdGhpcy5hbVRleHQgJiYgIXRoaXMucG1UZXh0KSB7CiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kaXNwbGF5VGltZQogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiB0aGlzLmRpc3BsYXlUaW1lLnJlcGxhY2UobmV3IFJlZ0V4cCh0aGlzLmFwbSwgJ2cnKSwgdGhpcy5hcG1EaXNwbGF5VGV4dCh0aGlzLmFwbSkpCiAgICAgICAgfSwKCiAgICAgICAgaW5wdXRJc0VtcHR5KCkgewogICAgICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXRTdHJpbmcgPT09IHRoaXMuZGlzcGxheVRpbWUKICAgICAgICB9LAoKICAgICAgICBhbGxWYWx1ZVNlbGVjdGVkKCkgewogICAgICAgICAgICBpZiAoCiAgICAgICAgICAgICAgICAodGhpcy5pblVzZS5ob3VyICYmICF0aGlzLmhvdXIpIHx8CiAgICAgICAgICAgICAgICAodGhpcy5pblVzZS5taW51dGUgJiYgIXRoaXMubWludXRlKSB8fAogICAgICAgICAgICAgICAgKHRoaXMuaW5Vc2Uuc2Vjb25kICYmICF0aGlzLnNlY29uZCkgfHwKICAgICAgICAgICAgICAgICh0aGlzLmluVXNlLmFwbSAmJiAhdGhpcy5hcG0pCiAgICAgICAgICAgICkgewogICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlCiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIHRydWUKICAgICAgICB9LAoKICAgICAgICBjb2x1bW5zU2VxdWVuY2UoKSB7CiAgICAgICAgICAgIHJldHVybiB0aGlzLmluVXNlLnR5cGVzLm1hcCh0eXBlID0+IHR5cGUpIHx8IFtdCiAgICAgICAgfSwKCiAgICAgICAgc2hvd0NsZWFyQnRuKCkgewogICAgICAgICAgICBpZiAodGhpcy5oaWRlQ2xlYXJCdXR0b24gfHwgdGhpcy5kaXNhYmxlZCkgewogICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlCiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuICF0aGlzLmlucHV0SXNFbXB0eQogICAgICAgIH0sCgogICAgICAgIHNob3dEcm9wZG93bkJ0bigpIHsKICAgICAgICAgICAgaWYgKHRoaXMuZml4ZWREcm9wZG93bkJ1dHRvbikgeyByZXR1cm4gdHJ1ZSB9CiAgICAgICAgICAgIGlmICh0aGlzLm9wdHMuaGlkZURyb3Bkb3duICYmIHRoaXMuaXNBY3RpdmUgJiYgIXRoaXMuc2hvd0Ryb3Bkb3duKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZQogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiBmYWxzZQogICAgICAgIH0sCgogICAgICAgIGJhc2VPbjEySG91cnMoKSB7CiAgICAgICAgICAgIHJldHVybiB0aGlzLmhvdXJUeXBlID09PSAnaCcgfHwgdGhpcy5ob3VyVHlwZSA9PT0gJ2hoJwogICAgICAgIH0sCgogICAgICAgIGhvdXJSYW5nZUluMjRIckZvcm1hdCgpIHsKICAgICAgICAgICAgaWYgKCF0aGlzLmhvdXJUeXBlIHx8ICF0aGlzLm9wdHMuaG91clJhbmdlKSB7IHJldHVybiBmYWxzZSB9CiAgICAgICAgICAgIGlmICghdGhpcy5vcHRzLmhvdXJSYW5nZS5sZW5ndGgpIHsgcmV0dXJuIFtdIH0KCiAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gW10KICAgICAgICAgICAgdGhpcy5vcHRzLmhvdXJSYW5nZS5mb3JFYWNoKHZhbHVlID0+IHsKICAgICAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5KSB7CiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA+IDIgJiYgdGhpcy5kZWJ1Z01vZGUpIHsKICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWJ1Z0xvZyhgTmVzdGVkIGFycmF5IHdpdGhpbiAiaG91ci1yYW5nZSIgbXVzdCBjb250YWluIG5vIG1vcmUgdGhhbiB0d28gaXRlbXMuIE9ubHkgdGhlIGZpcnN0IHR3byBpdGVtcyBvZiAke0pTT04uc3RyaW5naWZ5KHZhbHVlKX0gd2lsbCBiZSB0YWtlbiBpbnRvIGFjY291bnQuYCkKICAgICAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgICAgIGxldCBzdGFydCA9IHZhbHVlWzBdCiAgICAgICAgICAgICAgICAgICAgbGV0IGVuZCA9IHZhbHVlWzFdIHx8IHZhbHVlWzBdCgogICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzMTJoUmFuZ2Uoc3RhcnQpKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gdGhpcy50cmFuc2xhdGUxMmhSYW5nZShzdGFydCkKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaXMxMmhSYW5nZShlbmQpKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGVuZCA9IHRoaXMudHJhbnNsYXRlMTJoUmFuZ2UoZW5kKQogICAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9ICtzdGFydDsgaSA8PSArZW5kOyBpKyspIHsKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPCAwIHx8IGkgPiAyNCkgeyBjb250aW51ZSB9CiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcmFuZ2UuaW5jbHVkZXMoaSkpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlLnB1c2goaSkKICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaXMxMmhSYW5nZSh2YWx1ZSkpIHsKICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLnRyYW5zbGF0ZTEyaFJhbmdlKHZhbHVlKQogICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gK3ZhbHVlCiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA8IDAgfHwgdmFsdWUgPiAyNCkgeyByZXR1cm4gfQogICAgICAgICAgICAgICAgICAgIGlmICghcmFuZ2UuaW5jbHVkZXModmFsdWUpKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlLnB1c2godmFsdWUpCiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9KQogICAgICAgICAgICByYW5nZS5zb3J0KChsLCByKSA9PiB7IHJldHVybiBsIC0gciB9KQogICAgICAgICAgICByZXR1cm4gcmFuZ2UKICAgICAgICB9LAoKICAgICAgICByZXN0cmljdGVkSG91clJhbmdlKCkgewogICAgICAgICAgICAvLyBObyByZXN0cmljdGlvbgogICAgICAgICAgICBpZiAoIXRoaXMuaG91clJhbmdlSW4yNEhyRm9ybWF0KSB7IHJldHVybiBmYWxzZSB9CiAgICAgICAgICAgIC8vIDEyLUhvdXIKICAgICAgICAgICAgaWYgKHRoaXMuYmFzZU9uMTJIb3VycykgewogICAgICAgICAgICAgICAgY29uc3QgcmFuZ2UgPSB0aGlzLmhvdXJSYW5nZUluMjRIckZvcm1hdC5tYXAoKHZhbHVlKSA9PiB7CiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSAxMikgewogICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJzEycCcKICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSAyNCB8fCB2YWx1ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJzEyYScKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlID4gMTIgPyBgJHt2YWx1ZSAlIDEyfXBgIDogYCR7dmFsdWV9YWAKICAgICAgICAgICAgICAgIH0pCiAgICAgICAgICAgICAgICByZXR1cm4gcmFuZ2UKICAgICAgICAgICAgfQogICAgICAgICAgICAvLyAyNC1Ib3VyCiAgICAgICAgICAgIHJldHVybiB0aGlzLmhvdXJSYW5nZUluMjRIckZvcm1hdAogICAgICAgIH0sCgogICAgICAgIHZhbGlkSG91cnNMaXN0KCkgewogICAgICAgICAgICBpZiAoIXRoaXMubWFudWFsSW5wdXQpIHsgcmV0dXJuIGZhbHNlIH0KICAgICAgICAgICAgaWYgKHRoaXMucmVzdHJpY3RlZEhvdXJSYW5nZSkgewogICAgICAgICAgICAgICAgbGV0IGxpc3QgPSBbXQogICAgICAgICAgICAgICAgaWYgKHRoaXMuYmFzZU9uMTJIb3VycykgewogICAgICAgICAgICAgICAgICAgIGxpc3QgPSB0aGlzLnJlc3RyaWN0ZWRIb3VyUmFuZ2UubWFwKGhyID0+IHsKICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbCA9IGhyLnN1YnN0cigwLCBoci5sZW5ndGggLSAxKQogICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByID0gaHIuc3Vic3RyKC0xKQogICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYCR7dGhpcy5mb3JtYXRWYWx1ZSh0aGlzLmhvdXJUeXBlLCBsKX0ke3J9YAogICAgICAgICAgICAgICAgICAgIH0pCiAgICAgICAgICAgICAgICAgICAgY29uc3QgYW0xMkluZGV4ID0gbGlzdC5pbmRleE9mKCcxMmEnKQogICAgICAgICAgICAgICAgICAgIGlmIChhbTEySW5kZXggPiAwKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1ha2UgJzEyYScgdGhlIGZpcnN0IGl0ZW0gaW4gaC9oaAogICAgICAgICAgICAgICAgICAgICAgICBsaXN0LnVuc2hpZnQobGlzdC5zcGxpY2UoYW0xMkluZGV4LCAxKVswXSkKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxpc3QKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGxpc3QgPSB0aGlzLnJlc3RyaWN0ZWRIb3VyUmFuZ2UubWFwKGhyID0+IHsKICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXRWYWx1ZSh0aGlzLmhvdXJUeXBlLCBocikKICAgICAgICAgICAgICAgIH0pCiAgICAgICAgICAgICAgICBpZiAobGlzdC5sZW5ndGggPiAxICYmIGxpc3RbMF0gJiYgbGlzdFswXSA9PT0gJzI0JykgewogICAgICAgICAgICAgICAgICAgIC8vIE1ha2UgJzI0JyB0aGUgbGFzdCBpdGVtIGluIGsva2sKICAgICAgICAgICAgICAgICAgICBsaXN0LnB1c2gobGlzdC5zaGlmdCgpKQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgcmV0dXJuIGxpc3QKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAodGhpcy5iYXNlT24xMkhvdXJzKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gW10uY29uY2F0KFtdLCB0aGlzLmhvdXJzLm1hcChociA9PiBgJHtocn1hYCksIHRoaXMuaG91cnMubWFwKGhyID0+IGAke2hyfXBgKSkKICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gdGhpcy5ob3VycwogICAgICAgIH0sCgogICAgICAgIGhhcygpIHsKICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gewogICAgICAgICAgICAgICAgY3VzdG9tQXBtVGV4dDogZmFsc2UKICAgICAgICAgICAgfQogICAgICAgICAgICBjb25zdCBhcG1FbmFibGVkID0gISF0aGlzLmFwbVR5cGUKCiAgICAgICAgICAgIGlmIChhcG1FbmFibGVkICYmIHRoaXMuaG91clJhbmdlSW4yNEhyRm9ybWF0ICYmIHRoaXMuaG91clJhbmdlSW4yNEhyRm9ybWF0Lmxlbmd0aCkgewogICAgICAgICAgICAgICAgY29uc3QgcmFuZ2UgPSBbXS5jb25jYXQoW10sIHRoaXMuaG91clJhbmdlSW4yNEhyRm9ybWF0KQogICAgICAgICAgICAgICAgcmVzdWx0LmFtID0gcmFuZ2Uuc29tZSh2YWx1ZSA9PiB2YWx1ZSA8IDEyIHx8IHZhbHVlID09PSAyNCkKICAgICAgICAgICAgICAgIHJlc3VsdC5wbSA9IHJhbmdlLnNvbWUodmFsdWUgPT4gdmFsdWUgPj0gMTIgJiYgdmFsdWUgPCAyNCkKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIHJlc3VsdC5hbSA9IGFwbUVuYWJsZWQKICAgICAgICAgICAgICAgIHJlc3VsdC5wbSA9IGFwbUVuYWJsZWQKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAoKHRoaXMuYW1UZXh0ICYmIHRoaXMuYW1UZXh0Lmxlbmd0aCkgfHwgKHRoaXMucG1UZXh0ICYmIHRoaXMucG1UZXh0Lmxlbmd0aCkpIHsKICAgICAgICAgICAgICAgIHJlc3VsdC5jdXN0b21BcG1UZXh0ID0gdHJ1ZQogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiByZXN1bHQKICAgICAgICB9LAoKICAgICAgICBtaW51dGVSYW5nZUxpc3QoKSB7CiAgICAgICAgICAgIGlmICghdGhpcy5taW51dGVUeXBlIHx8ICF0aGlzLm9wdHMubWludXRlUmFuZ2UpIHsgcmV0dXJuIGZhbHNlIH0KICAgICAgICAgICAgaWYgKCF0aGlzLm9wdHMubWludXRlUmFuZ2UubGVuZ3RoKSB7IHJldHVybiBbXSB9CiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbmRlclJhbmdlTGlzdCh0aGlzLm9wdHMubWludXRlUmFuZ2UsICdtaW51dGUnKQogICAgICAgIH0sCgogICAgICAgIHNlY29uZFJhbmdlTGlzdCgpIHsKICAgICAgICAgICAgaWYgKCF0aGlzLnNlY29uZFR5cGUgfHwgIXRoaXMub3B0cy5zZWNvbmRSYW5nZSkgeyByZXR1cm4gZmFsc2UgfQogICAgICAgICAgICBpZiAoIXRoaXMub3B0cy5zZWNvbmRSYW5nZS5sZW5ndGgpIHsgcmV0dXJuIFtdIH0KICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyUmFuZ2VMaXN0KHRoaXMub3B0cy5zZWNvbmRSYW5nZSwgJ3NlY29uZCcpCiAgICAgICAgfSwKCiAgICAgICAgaG91ckxhYmVsVGV4dCgpIHsKICAgICAgICAgICAgcmV0dXJuIHRoaXMuaG91ckxhYmVsIHx8IHRoaXMuaG91clR5cGUKICAgICAgICB9LAogICAgICAgIG1pbnV0ZUxhYmVsVGV4dCgpIHsKICAgICAgICAgICAgcmV0dXJuIHRoaXMubWludXRlTGFiZWwgfHwgdGhpcy5taW51dGVUeXBlCiAgICAgICAgfSwKICAgICAgICBzZWNvbmRMYWJlbFRleHQoKSB7CiAgICAgICAgICAgIHJldHVybiB0aGlzLnNlY29uZExhYmVsIHx8IHRoaXMuc2Vjb25kVHlwZQogICAgICAgIH0sCiAgICAgICAgYXBtTGFiZWxUZXh0KCkgewogICAgICAgICAgICByZXR1cm4gdGhpcy5hcG1MYWJlbCB8fCB0aGlzLmFwbVR5cGUKICAgICAgICB9LAoKICAgICAgICBpbnB1dFdpZHRoU3R5bGUoKSB7CiAgICAgICAgICAgIGlmICghdGhpcy5pbnB1dFdpZHRoIHx8ICF0aGlzLmlucHV0V2lkdGgubGVuZ3RoKSB7IHJldHVybiB9CiAgICAgICAgICAgIHJldHVybiB7CiAgICAgICAgICAgICAgICB3aWR0aDogdGhpcy5pbnB1dFdpZHRoCiAgICAgICAgICAgIH0KICAgICAgICB9LAoKICAgICAgICB0b2tlblJlZ2V4QmFzZSgpIHsKICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5Vc2UudG9rZW5zLmpvaW4oJ3wnKQogICAgICAgIH0sCgogICAgICAgIHRva2VuQ2h1bmtzKCkgewogICAgICAgICAgICBpZiAoIXRoaXMubWFudWFsSW5wdXQgJiYgIXRoaXMudXNlU3RyaW5nVmFsdWUpIHsgcmV0dXJuIGZhbHNlIH0KCiAgICAgICAgICAgIGNvbnN0IGZvcm1hdFN0cmluZyA9IFN0cmluZyh0aGlzLmZvcm1hdFN0cmluZykKICAgICAgICAgICAgY29uc3QgdG9rZW5zUmVneFN0ciA9IGAoJHt0aGlzLnRva2VuUmVnZXhCYXNlfSkrP2AKICAgICAgICAgICAgY29uc3QgdG9rZW5zTWF0Y2hBbGwgPSB0aGlzLmdldE1hdGNoQWxsQnlSZWdleChmb3JtYXRTdHJpbmcsIHRva2Vuc1JlZ3hTdHIpCgogICAgICAgICAgICBjb25zdCB0b2tlbkNodW5rcyA9IFtdCiAgICAgICAgICAgIGZvciAobGV0IHRrTWF0Y2ggb2YgdG9rZW5zTWF0Y2hBbGwpIHsKICAgICAgICAgICAgICAgIGNvbnN0IHJhd1Rva2VuID0gdGtNYXRjaFswXQogICAgICAgICAgICAgICAgY29uc3QgdG9rZW5NYXRjaEl0ZW0gPSB7CiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IHRrTWF0Y2guaW5kZXgsCiAgICAgICAgICAgICAgICAgICAgdG9rZW46IHJhd1Rva2VuLAogICAgICAgICAgICAgICAgICAgIHR5cGU6IHRoaXMuZ2V0VG9rZW5UeXBlKHJhd1Rva2VuKSwKICAgICAgICAgICAgICAgICAgICBuZWVkc0NhbGlicmF0ZTogcmF3VG9rZW4ubGVuZ3RoIDwgMiwKICAgICAgICAgICAgICAgICAgICBsZW46IChyYXdUb2tlbiB8fCAnJykubGVuZ3RoCiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB0b2tlbkNodW5rcy5wdXNoKHRva2VuTWF0Y2hJdGVtKQogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiB0b2tlbkNodW5rcwogICAgICAgIH0sCgogICAgICAgIG5lZWRzUG9zQ2FsaWJyYXRlKCkgewogICAgICAgICAgICBpZiAoIXRoaXMubWFudWFsSW5wdXQpIHsgcmV0dXJuIGZhbHNlIH0KICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9rZW5DaHVua3Muc29tZShjaGsgPT4gY2hrLm5lZWRzQ2FsaWJyYXRlKQogICAgICAgIH0sCgogICAgICAgIHRva2VuQ2h1bmtzUG9zKCkgewogICAgICAgICAgICBpZiAoIXRoaXMubWFudWFsSW5wdXQpIHsgcmV0dXJuIGZhbHNlIH0KICAgICAgICAgICAgaWYgKCF0aGlzLm5lZWRzUG9zQ2FsaWJyYXRlKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50b2tlbkNodW5rcy5tYXAoY2hrID0+IHsKICAgICAgICAgICAgICAgICAgICByZXR1cm4gewogICAgICAgICAgICAgICAgICAgICAgICB0b2tlbjogY2hrLnRva2VuLAogICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBjaGsudHlwZSwKICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IGNoay5pbmRleCwKICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBjaGsuaW5kZXggKyBjaGsubGVuCiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfSkKICAgICAgICAgICAgfQogICAgICAgICAgICBjb25zdCBsaXN0ID0gW10KICAgICAgICAgICAgbGV0IGNhbGlicmF0ZUxlbiA9IDAKICAgICAgICAgICAgdGhpcy50b2tlbkNodW5rcy5mb3JFYWNoKGNoayA9PiB7CiAgICAgICAgICAgICAgICBsZXQgY2h1bmtDdXJyZW50TGVuCiAgICAgICAgICAgICAgICAvLyBBZGp1c3QgZm9yIGN1c3RvbWl6ZWQgQU0vUE0gdGV4dAogICAgICAgICAgICAgICAgaWYgKGNoay50eXBlID09PSAnYXBtJyAmJiB0aGlzLmhhcy5jdXN0b21BcG1UZXh0KSB7CiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYXBtICYmIHRoaXMuYXBtLmxlbmd0aCkgewogICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXN0b21BcG1UZXh0ID0gdGhpcy5hcG0udG9Mb3dlckNhc2UoKSA9PT0gJ2FtJyA/IHRoaXMuYW1UZXh0IDogdGhpcy5wbVRleHQKICAgICAgICAgICAgICAgICAgICAgICAgY2h1bmtDdXJyZW50TGVuID0gKGN1c3RvbUFwbVRleHQgJiYgY3VzdG9tQXBtVGV4dC5sZW5ndGgpID8gY3VzdG9tQXBtVGV4dC5sZW5ndGggOiBjaGsubGVuCiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgY2h1bmtDdXJyZW50TGVuID0gY2hrLmxlbgogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAvLyBPdGhlcnMKICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgY2h1bmtDdXJyZW50TGVuID0gdGhpc1tjaGsudHlwZV0gJiYgdGhpc1tjaGsudHlwZV0ubGVuZ3RoID8gdGhpc1tjaGsudHlwZV0ubGVuZ3RoIDogY2hrLmxlbgogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgbGlzdC5wdXNoKHsKICAgICAgICAgICAgICAgICAgICB0b2tlbjogY2hrLnRva2VuLAogICAgICAgICAgICAgICAgICAgIHR5cGU6IGNoay50eXBlLAogICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBjaGsuaW5kZXggKyBjYWxpYnJhdGVMZW4sCiAgICAgICAgICAgICAgICAgICAgZW5kOiBjaGsuaW5kZXggKyBjYWxpYnJhdGVMZW4gKyBjaHVua0N1cnJlbnRMZW4KICAgICAgICAgICAgICAgIH0pCiAgICAgICAgICAgICAgICBpZiAoY2hrLm5lZWRzQ2FsaWJyYXRlICYmIGNodW5rQ3VycmVudExlbiA+IGNoay5sZW4pIHsKICAgICAgICAgICAgICAgICAgICBjYWxpYnJhdGVMZW4gKz0gKGNodW5rQ3VycmVudExlbiAtIGNoay5sZW4pCiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0pCiAgICAgICAgICAgIHJldHVybiBsaXN0CiAgICAgICAgfSwKCiAgICAgICAgaW52YWxpZFZhbHVlcygpIHsKICAgICAgICAgICAgaWYgKHRoaXMuaW5wdXRJc0VtcHR5KSB7IHJldHVybiBbXSB9CiAgICAgICAgICAgIGlmICghdGhpcy5yZXN0cmljdGVkSG91clJhbmdlICYmICF0aGlzLm1pbnV0ZVJhbmdlTGlzdCAmJiAhdGhpcy5zZWNvbmRSYW5nZUxpc3QgJiYgdGhpcy5vcHRzLm1pbnV0ZUludGVydmFsID09PSAxICYmIHRoaXMub3B0cy5zZWNvbmRJbnRlcnZhbCA9PT0gMSkgeyByZXR1cm4gW10gfQoKICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gW10KICAgICAgICAgICAgaWYgKHRoaXMuaW5Vc2UuaG91ciAmJiAhdGhpcy5pc0VtcHR5VmFsdWUodGhpcy5ob3VyVHlwZSwgdGhpcy5ob3VyKSAmJiAoIXRoaXMuaXNWYWxpZFZhbHVlKHRoaXMuaG91clR5cGUsIHRoaXMuaG91cikgfHwgdGhpcy5pc0Rpc2FibGVkKCdob3VyJywgdGhpcy5ob3VyKSkpIHsKICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKCdob3VyJykKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAodGhpcy5pblVzZS5taW51dGUgJiYgIXRoaXMuaXNFbXB0eVZhbHVlKHRoaXMubWludXRlVHlwZSwgdGhpcy5taW51dGUpICYmICghdGhpcy5pc1ZhbGlkVmFsdWUodGhpcy5taW51dGVUeXBlLCB0aGlzLm1pbnV0ZSkgfHwgdGhpcy5pc0Rpc2FibGVkKCdtaW51dGUnLCB0aGlzLm1pbnV0ZSkgfHwgdGhpcy5ub3RJbkludGVydmFsKCdtaW51dGUnLCB0aGlzLm1pbnV0ZSkpKSB7CiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnbWludXRlJykKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAodGhpcy5pblVzZS5zZWNvbmQgJiYgIXRoaXMuaXNFbXB0eVZhbHVlKHRoaXMuc2Vjb25kVHlwZSwgdGhpcy5zZWNvbmQpICYmICghdGhpcy5pc1ZhbGlkVmFsdWUodGhpcy5zZWNvbmRUeXBlLCB0aGlzLnNlY29uZCkgfHwgdGhpcy5pc0Rpc2FibGVkKCdzZWNvbmQnLCB0aGlzLnNlY29uZCkgfHwgdGhpcy5ub3RJbkludGVydmFsKCdzZWNvbmQnLCB0aGlzLnNlY29uZCkpKSB7CiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnc2Vjb25kJykKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAodGhpcy5pblVzZS5hcG0gJiYgIXRoaXMuaXNFbXB0eVZhbHVlKHRoaXMuYXBtVHlwZSwgdGhpcy5hcG0pICYmICghdGhpcy5pc1ZhbGlkVmFsdWUodGhpcy5hcG1UeXBlLCB0aGlzLmFwbSkgfHwgdGhpcy5pc0Rpc2FibGVkKCdhcG0nLCB0aGlzLmFwbSkpKSB7CiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnYXBtJykKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCkgewogICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdAogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiBbXQogICAgICAgIH0sCgogICAgICAgIGhhc0ludmFsaWRJbnB1dCgpIHsKICAgICAgICAgICAgcmV0dXJuIEJvb2xlYW4odGhpcy5pbnZhbGlkVmFsdWVzICYmIHRoaXMuaW52YWxpZFZhbHVlcy5sZW5ndGgpCiAgICAgICAgfSwKCiAgICAgICAgYXV0b0RpcmVjdGlvbkVuYWJsZWQoKSB7CiAgICAgICAgICAgIHJldHVybiB0aGlzLmRyb3BEaXJlY3Rpb24gPT09ICdhdXRvJwogICAgICAgIH0sCgogICAgICAgIGRyb3Bkb3duRGlyQ2xhc3MoKSB7CiAgICAgICAgICAgIGlmICh0aGlzLmF1dG9EaXJlY3Rpb25FbmFibGVkKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mb3JjZURyb3BPblRvcCA/ICdkcm9wLXVwJyA6ICdkcm9wLWRvd24nCiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIHRoaXMuZHJvcERpcmVjdGlvbiA9PT0gJ3VwJyA/ICdkcm9wLXVwJyA6ICdkcm9wLWRvd24nCiAgICAgICAgfQogICAgfSwKCiAgICB3YXRjaDogewogICAgICAgICdvcHRzLmZvcm1hdCcobmV3VmFsdWUpIHsKICAgICAgICAgICAgdGhpcy5yZW5kZXJGb3JtYXQobmV3VmFsdWUpCiAgICAgICAgfSwKICAgICAgICAnb3B0cy5taW51dGVJbnRlcnZhbCcobmV3SW50ZXZhbCkgewogICAgICAgICAgICB0aGlzLnJlbmRlckxpc3QoJ21pbnV0ZScsIG5ld0ludGV2YWwpCiAgICAgICAgfSwKICAgICAgICAnb3B0cy5zZWNvbmRJbnRlcnZhbCcobmV3SW50ZXZhbCkgewogICAgICAgICAgICB0aGlzLnJlbmRlckxpc3QoJ3NlY29uZCcsIG5ld0ludGV2YWwpCiAgICAgICAgfSwKICAgICAgICB2YWx1ZTogewogICAgICAgICAgICBkZWVwOiB0cnVlLAogICAgICAgICAgICBoYW5kbGVyKCkgewogICAgICAgICAgICAgICAgdGhpcy5yZWFkVmFsdWVzKCkKICAgICAgICAgICAgfQogICAgICAgIH0sCiAgICAgICAgZGlzcGxheVRpbWUoKSB7CiAgICAgICAgICAgIHRoaXMuZmlsbFZhbHVlcygpCiAgICAgICAgfSwKICAgICAgICBkaXNhYmxlZCh0b0Rpc2FibGVkKSB7CiAgICAgICAgICAgIGlmICh0b0Rpc2FibGVkKSB7CiAgICAgICAgICAgICAgICAvLyBGb3JjZSBjbG9zZSBkcm9wZG93biBhbmQgcmVzZXQgc3RhdHVzIHdoZW4gZGlzYWJsZWQKICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzQWN0aXZlKSB7CiAgICAgICAgICAgICAgICAgICAgdGhpcy5pc0FjdGl2ZSA9IGZhbHNlCiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZiAodGhpcy5zaG93RHJvcGRvd24pIHsKICAgICAgICAgICAgICAgICAgICB0aGlzLnNob3dEcm9wZG93biA9IGZhbHNlCiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICB9LAogICAgICAgICdpbnZhbGlkVmFsdWVzLmxlbmd0aCcobmV3TGVuZ3RoLCBvbGRMZW5ndGgpIHsKICAgICAgICAgICAgaWYgKG5ld0xlbmd0aCAmJiBuZXdMZW5ndGggPj0gMSkgewogICAgICAgICAgICAgICAgdGhpcy4kZW1pdCgnZXJyb3InLCB0aGlzLmludmFsaWRWYWx1ZXMpCiAgICAgICAgICAgIH0gZWxzZSBpZiAob2xkTGVuZ3RoICYmIG9sZExlbmd0aCA+PSAxKSB7CiAgICAgICAgICAgICAgICB0aGlzLiRlbWl0KCdlcnJvcicsIFtdKQogICAgICAgICAgICB9CiAgICAgICAgfQogICAgfSwKCiAgICBtZXRob2RzOiB7CiAgICAgICAgZm9ybWF0VmFsdWUodG9rZW4sIGkpIHsKICAgICAgICAgICAgaWYgKCF0aGlzLmlzTnVtYmVyKGkpKSB7IHJldHVybiAnJyB9CiAgICAgICAgICAgIGkgPSAraQogICAgICAgICAgICBzd2l0Y2ggKHRva2VuKSB7CiAgICAgICAgICAgICAgICBjYXNlICdIJzoKICAgICAgICAgICAgICAgIGNhc2UgJ2gnOgogICAgICAgICAgICAgICAgY2FzZSAnayc6CiAgICAgICAgICAgICAgICBjYXNlICdtJzoKICAgICAgICAgICAgICAgIGNhc2UgJ3MnOgogICAgICAgICAgICAgICAgICAgIGlmIChbJ2gnLCAnayddLmluY2x1ZGVzKHRva2VuKSAmJiBpID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbiA9PT0gJ2snID8gJzI0JyA6ICcxMicKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZyhpKQogICAgICAgICAgICAgICAgY2FzZSAnSEgnOgogICAgICAgICAgICAgICAgY2FzZSAnbW0nOgogICAgICAgICAgICAgICAgY2FzZSAnc3MnOgogICAgICAgICAgICAgICAgY2FzZSAnaGgnOgogICAgICAgICAgICAgICAgY2FzZSAna2snOgogICAgICAgICAgICAgICAgICAgIGlmIChbJ2hoJywgJ2trJ10uaW5jbHVkZXModG9rZW4pICYmIGkgPT09IDApIHsKICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuID09PSAna2snID8gJzI0JyA6ICcxMicKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGkgPCAxMCA/IGAwJHtpfWAgOiBTdHJpbmcoaSkKICAgICAgICAgICAgICAgIGRlZmF1bHQ6CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICcnCiAgICAgICAgICAgIH0KICAgICAgICB9LAoKICAgICAgICBjaGVja0FjY2VwdGluZ1R5cGUodmFsaWRWYWx1ZXMsIGZvcm1hdFN0cmluZykgewogICAgICAgICAgICBpZiAoIXZhbGlkVmFsdWVzIHx8ICFmb3JtYXRTdHJpbmcgfHwgIWZvcm1hdFN0cmluZy5sZW5ndGgpIHsgcmV0dXJuICcnIH0KICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWxpZFZhbHVlcy5sZW5ndGg7IGkrKykgewogICAgICAgICAgICAgICAgaWYgKGZvcm1hdFN0cmluZy5pbmRleE9mKHZhbGlkVmFsdWVzW2ldKSA+IC0xKSB7CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbGlkVmFsdWVzW2ldCiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuICcnCiAgICAgICAgfSwKCiAgICAgICAgcmVuZGVyRm9ybWF0KG5ld0Zvcm1hdCkgewogICAgICAgICAgICBuZXdGb3JtYXQgPSBuZXdGb3JtYXQgfHwgdGhpcy5vcHRzLmZvcm1hdCB8fCBERUZBVUxUX09QVElPTlMuZm9ybWF0CgogICAgICAgICAgICBsZXQgaG91clR5cGUgPSB0aGlzLmNoZWNrQWNjZXB0aW5nVHlwZShDT05GSUcuSE9VUl9UT0tFTlMsIG5ld0Zvcm1hdCkKICAgICAgICAgICAgbGV0IG1pbnV0ZVR5cGUgPSB0aGlzLmNoZWNrQWNjZXB0aW5nVHlwZShDT05GSUcuTUlOVVRFX1RPS0VOUywgbmV3Rm9ybWF0KQogICAgICAgICAgICB0aGlzLnNlY29uZFR5cGUgPSB0aGlzLmNoZWNrQWNjZXB0aW5nVHlwZShDT05GSUcuU0VDT05EX1RPS0VOUywgbmV3Rm9ybWF0KQogICAgICAgICAgICB0aGlzLmFwbVR5cGUgPSB0aGlzLmNoZWNrQWNjZXB0aW5nVHlwZShDT05GSUcuQVBNX1RPS0VOUywgbmV3Rm9ybWF0KQoKICAgICAgICAgICAgLy8gRmFpbHNhZmUgY2hlY2tpbmcKICAgICAgICAgICAgaWYgKCFob3VyVHlwZSAmJiAhbWludXRlVHlwZSAmJiAhdGhpcy5zZWNvbmRUeXBlICYmICF0aGlzLmFwbVR5cGUpIHsKICAgICAgICAgICAgICAgIGlmICh0aGlzLmRlYnVnTW9kZSAmJiB0aGlzLmZvcm1hdCkgewogICAgICAgICAgICAgICAgICAgIHRoaXMuZGVidWdMb2coYE5vIHZhbGlkIHRva2VucyBmb3VuZCBpbiB5b3VyIGRlZmluZWQgImZvcm1hdCIgc3RyaW5nICIke3RoaXMuZm9ybWF0fSIuIEZhbGxiYWNrIHRvIHRoZSBkZWZhdWx0ICJISDptbSIgZm9ybWF0LmApCiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBob3VyVHlwZSA9ICdISCcKICAgICAgICAgICAgICAgIG1pbnV0ZVR5cGUgPSAnbW0nCiAgICAgICAgICAgIH0KICAgICAgICAgICAgdGhpcy5ob3VyVHlwZSA9IGhvdXJUeXBlCiAgICAgICAgICAgIHRoaXMubWludXRlVHlwZSA9IG1pbnV0ZVR5cGUKCiAgICAgICAgICAgIHRoaXMuaG91clR5cGUgPyB0aGlzLnJlbmRlckhvdXJzTGlzdCgpIDogdGhpcy5ob3VycyA9IFtdCiAgICAgICAgICAgIHRoaXMubWludXRlVHlwZSA/IHRoaXMucmVuZGVyTGlzdCgnbWludXRlJykgOiB0aGlzLm1pbnV0ZXMgPSBbXQogICAgICAgICAgICB0aGlzLnNlY29uZFR5cGUgPyB0aGlzLnJlbmRlckxpc3QoJ3NlY29uZCcpIDogdGhpcy5zZWNvbmRzID0gW10KICAgICAgICAgICAgdGhpcy5hcG1UeXBlID8gdGhpcy5yZW5kZXJBcG1MaXN0KCkgOiB0aGlzLmFwbXMgPSBbXQoKICAgICAgICAgICAgdGhpcy4kbmV4dFRpY2soKCkgPT4gewogICAgICAgICAgICAgICAgdGhpcy5yZWFkVmFsdWVzKCkKICAgICAgICAgICAgfSkKICAgICAgICB9LAoKICAgICAgICByZW5kZXJIb3Vyc0xpc3QoKSB7CiAgICAgICAgICAgIGNvbnN0IGhvdXJzQ291bnQgPSB0aGlzLmJhc2VPbjEySG91cnMgPyAxMiA6IDI0CiAgICAgICAgICAgIGNvbnN0IGhvdXJzID0gW10KICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBob3Vyc0NvdW50OyBpKyspIHsKICAgICAgICAgICAgICAgIGlmICh0aGlzLmhvdXJUeXBlID09PSAnaycgfHwgdGhpcy5ob3VyVHlwZSA9PT0gJ2trJykgewogICAgICAgICAgICAgICAgICAgIGhvdXJzLnB1c2godGhpcy5mb3JtYXRWYWx1ZSh0aGlzLmhvdXJUeXBlLCBpICsgMSkpCiAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgIGhvdXJzLnB1c2godGhpcy5mb3JtYXRWYWx1ZSh0aGlzLmhvdXJUeXBlLCBpKSkKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgICB0aGlzLmhvdXJzID0gaG91cnMKICAgICAgICB9LAoKICAgICAgICByZW5kZXJMaXN0KGxpc3RUeXBlLCBpbnRlcnZhbCkgewogICAgICAgICAgICBpZiAoIXRoaXMuaXNNaW51dGVPclNlY29uZChsaXN0VHlwZSkpIHsgcmV0dXJuIH0KCiAgICAgICAgICAgIGNvbnN0IGlzTWludXRlID0gbGlzdFR5cGUgPT09ICdtaW51dGUnCiAgICAgICAgICAgIGludGVydmFsID0gaW50ZXJ2YWwgfHwgKGlzTWludXRlID8gKHRoaXMub3B0cy5taW51dGVJbnRlcnZhbCB8fCBERUZBVUxUX09QVElPTlMubWludXRlSW50ZXJ2YWwpIDogKHRoaXMub3B0cy5zZWNvbmRJbnRlcnZhbCB8fCBERUZBVUxUX09QVElPTlMuc2Vjb25kSW50ZXJ2YWwpKQoKICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gW10KICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2MDsgaSArPSBpbnRlcnZhbCkgewogICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5mb3JtYXRWYWx1ZShpc01pbnV0ZSA/IHRoaXMubWludXRlVHlwZSA6IHRoaXMuc2Vjb25kVHlwZSwgaSkpCiAgICAgICAgICAgIH0KICAgICAgICAgICAgaXNNaW51dGUgPyB0aGlzLm1pbnV0ZXMgPSByZXN1bHQgOiB0aGlzLnNlY29uZHMgPSByZXN1bHQKICAgICAgICB9LAoKICAgICAgICByZW5kZXJBcG1MaXN0KCkgewogICAgICAgICAgICB0aGlzLmFwbXMgPSB0aGlzLmFwbVR5cGUgPT09ICdBJyA/IFsnQU0nLCAnUE0nXSA6IFsnYW0nLCAncG0nXQogICAgICAgIH0sCgogICAgICAgIHJlYWRWYWx1ZXMoKSB7CiAgICAgICAgICAgIGlmICh0aGlzLnVzZVN0cmluZ1ZhbHVlKSB7CiAgICAgICAgICAgICAgICBpZiAodGhpcy5kZWJ1Z01vZGUpIHsKICAgICAgICAgICAgICAgICAgICB0aGlzLmRlYnVnTG9nKGBSZWNlaXZlZCBhIHN0cmluZyB2YWx1ZTogIiR7dGhpcy52YWx1ZX0iYCkKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHRoaXMucmVhZFN0cmluZ1ZhbHVlcyh0aGlzLnZhbHVlKQogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgaWYgKHRoaXMuZGVidWdNb2RlKSB7CiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWJ1Z0xvZyhgUmVjZWl2ZWQgYW4gb2JqZWN0IHZhbHVlOiAiJHtKU09OLnN0cmluZ2lmeSh0aGlzLnZhbHVlIHx8IHt9KX0iYCkKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHRoaXMucmVhZE9iamVjdFZhbHVlcyh0aGlzLnZhbHVlKQogICAgICAgICAgICB9CiAgICAgICAgfSwKCiAgICAgICAgcmVhZE9iamVjdFZhbHVlcyhvYmpWYWx1ZSkgewogICAgICAgICAgICBjb25zdCB0aW1lVmFsdWUgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG9ialZhbHVlIHx8IHt9KSkKICAgICAgICAgICAgY29uc3QgdmFsdWVzID0gT2JqZWN0LmtleXModGltZVZhbHVlKQoKICAgICAgICAgICAgLy8gRmFpbHNhZmUgZm9yIGVtcHR5IGB2LW1vZGVsYCBvYmplY3QKICAgICAgICAgICAgaWYgKHZhbHVlcy5sZW5ndGggPT09IDApIHsKICAgICAgICAgICAgICAgIHRoaXMuYWRkRmFsbGJhY2tWYWx1ZXMoKQogICAgICAgICAgICAgICAgcmV0dXJuCiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIENPTkZJRy5CQVNJQ19UWVBFUy5mb3JFYWNoKHR5cGUgPT4gewogICAgICAgICAgICAgICAgY29uc3QgdG9rZW4gPSB0aGlzLmdldFRva2VuQnlUeXBlKHR5cGUpCiAgICAgICAgICAgICAgICBpZiAodmFsdWVzLmluZGV4T2YodG9rZW4pID4gLTEpIHsKICAgICAgICAgICAgICAgICAgICBjb25zdCBzYW5pdGl6ZWRWYWx1ZSA9IHRoaXMuc2FuaXRpemVkVmFsdWUodG9rZW4sIHRpbWVWYWx1ZVt0b2tlbl0pCiAgICAgICAgICAgICAgICAgICAgdGhpc1t0eXBlXSA9IHNhbml0aXplZFZhbHVlCiAgICAgICAgICAgICAgICAgICAgdGltZVZhbHVlW3Rva2VuXSA9IHNhbml0aXplZFZhbHVlCiAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgIHRoaXNbdHlwZV0gPSAnJwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9KQogICAgICAgICAgICB0aGlzLnRpbWVWYWx1ZSA9IHRpbWVWYWx1ZQogICAgICAgIH0sCgogICAgICAgIGdldE1hdGNoQWxsQnlSZWdleCh0ZXN0U3RyaW5nLCByZWdleFN0cmluZykgewogICAgICAgICAgICBjb25zdCBzdHIgPSAncG9seWZpbGxUZXN0JwogICAgICAgICAgICBjb25zdCBuZWVkc1BvbHlmaWxsID0gQm9vbGVhbighc3RyLm1hdGNoQWxsIHx8IHR5cGVvZiBzdHIubWF0Y2hBbGwgIT09ICdmdW5jdGlvbicpCiAgICAgICAgICAgIHJldHVybiBuZWVkc1BvbHlmaWxsID8gdGhpcy5wb2x5ZmlsbE1hdGNoQWxsKHRlc3RTdHJpbmcsIHJlZ2V4U3RyaW5nKSA6IHRlc3RTdHJpbmcubWF0Y2hBbGwobmV3IFJlZ0V4cChyZWdleFN0cmluZywgJ2cnKSkKICAgICAgICB9LAoKICAgICAgICByZWFkU3RyaW5nVmFsdWVzKHN0cmluZ1ZhbHVlKSB7CiAgICAgICAgICAgIC8vIEZhaWxzYWZlIGZvciBlbXB0eSBgdi1tb2RlbGAgc3RyaW5nCiAgICAgICAgICAgIGlmICghc3RyaW5nVmFsdWUgfHwgIXN0cmluZ1ZhbHVlLmxlbmd0aCkgewogICAgICAgICAgICAgICAgdGhpcy5hZGRGYWxsYmFja1ZhbHVlcygpCiAgICAgICAgICAgICAgICByZXR1cm4KICAgICAgICAgICAgfQoKICAgICAgICAgICAgY29uc3QgZm9ybWF0U3RyaW5nID0gU3RyaW5nKHRoaXMuZm9ybWF0U3RyaW5nKQogICAgICAgICAgICBjb25zdCB0b2tlbnNSZWd4U3RyID0gYCgke3RoaXMudG9rZW5SZWdleEJhc2V9KSs/YAogICAgICAgICAgICBjb25zdCBvdGhlcnNSZWd4U3RyID0gYFteKCR7dGhpcy50b2tlblJlZ2V4QmFzZX0pXStgCgogICAgICAgICAgICBjb25zdCB0b2tlbnNNYXRjaEFsbCA9IHRoaXMuZ2V0TWF0Y2hBbGxCeVJlZ2V4KGZvcm1hdFN0cmluZywgdG9rZW5zUmVneFN0cikKICAgICAgICAgICAgY29uc3Qgb3RoZXJzTWF0Y2hBbGwgPSB0aGlzLmdldE1hdGNoQWxsQnlSZWdleChmb3JtYXRTdHJpbmcsIG90aGVyc1JlZ3hTdHIpCgogICAgICAgICAgICBjb25zdCBjaHVua3MgPSBbXQogICAgICAgICAgICBjb25zdCB0b2tlbkNodW5rcyA9IFtdCgogICAgICAgICAgICBmb3IgKGxldCB0a01hdGNoIG9mIHRva2Vuc01hdGNoQWxsKSB7CiAgICAgICAgICAgICAgICBjb25zdCB0b2tlbk1hdGNoSXRlbSA9IHsKICAgICAgICAgICAgICAgICAgICBpbmRleDogdGtNYXRjaC5pbmRleCwKICAgICAgICAgICAgICAgICAgICB0b2tlbjogdGtNYXRjaFswXSwKICAgICAgICAgICAgICAgICAgICBpc1ZhbHVlVG9rZW46IHRydWUKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGNodW5rcy5wdXNoKHRva2VuTWF0Y2hJdGVtKQogICAgICAgICAgICAgICAgdG9rZW5DaHVua3MucHVzaCh0b2tlbk1hdGNoSXRlbSkKICAgICAgICAgICAgfQoKICAgICAgICAgICAgZm9yIChsZXQgb3RNYXRjaCBvZiBvdGhlcnNNYXRjaEFsbCkgewogICAgICAgICAgICAgICAgY2h1bmtzLnB1c2goewogICAgICAgICAgICAgICAgICAgIGluZGV4OiBvdE1hdGNoLmluZGV4LAogICAgICAgICAgICAgICAgICAgIHRva2VuOiBvdE1hdGNoWzBdCiAgICAgICAgICAgICAgICB9KQogICAgICAgICAgICB9CgogICAgICAgICAgICBjaHVua3Muc29ydCgobCwgcikgPT4gbC5pbmRleCA8IHIuaW5kZXggPyAtMSA6IDEpCgogICAgICAgICAgICBsZXQgcmVnZXhDb21ibyA9ICcnCiAgICAgICAgICAgIGNodW5rcy5mb3JFYWNoKGNodW5rID0+IHsKICAgICAgICAgICAgICAgIGlmIChjaHVuay5pc1ZhbHVlVG9rZW4pIHsKICAgICAgICAgICAgICAgICAgICBjb25zdCB0b2tlblJlZ2V4ID0gdGhpcy5nZXRUb2tlblJlZ2V4KGNodW5rLnRva2VuKSB8fCAnJwogICAgICAgICAgICAgICAgICAgIHJlZ2V4Q29tYm8gKz0gdG9rZW5SZWdleAogICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICBjb25zdCBzYWZlQ2hhcnMgPSBjaHVuay50b2tlbi5yZXBsYWNlKC9cXHswfShcKnxcP3xcLnxcKykvZywgJ1xcJDEnKQogICAgICAgICAgICAgICAgICAgIHJlZ2V4Q29tYm8gKz0gYCg/OiR7c2FmZUNoYXJzfSlgCiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0pCgogICAgICAgICAgICBjb25zdCBjb21ib1JlZyA9IG5ldyBSZWdFeHAocmVnZXhDb21ibykKCiAgICAgICAgICAgIC8vIERvIHRlc3QgYmVmb3JlIG1hdGNoCiAgICAgICAgICAgIGlmIChjb21ib1JlZy50ZXN0KHN0cmluZ1ZhbHVlKSkgewogICAgICAgICAgICAgICAgY29uc3QgbWF0Y2hSZXN1bHRzID0gc3RyaW5nVmFsdWUubWF0Y2gobmV3IFJlZ0V4cChyZWdleENvbWJvKSkKICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlUmVzdWx0cyA9IG1hdGNoUmVzdWx0cy5zbGljZSgxLCB0b2tlbkNodW5rcy5sZW5ndGggKyAxKQogICAgICAgICAgICAgICAgY29uc3QgdGltZVZhbHVlID0ge30KICAgICAgICAgICAgICAgIHZhbHVlUmVzdWx0cy5mb3JFYWNoKCh2YWx1ZSwgdnJJbmRleCkgPT4gewogICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbkNodW5rc1t2ckluZGV4XSkgewogICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXRUb2tlbiA9IHRva2VuQ2h1bmtzW3ZySW5kZXhdLnRva2VuCiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVWYWx1ZVt0YXJnZXRUb2tlbl0gPSB0aGlzLnNldFZhbHVlRnJvbVN0cmluZyh2YWx1ZSwgdGFyZ2V0VG9rZW4pCiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfSkKICAgICAgICAgICAgICAgIHRoaXMudGltZVZhbHVlID0gdGltZVZhbHVlCgogICAgICAgICAgICAgICAgaWYgKHRoaXMuZGVidWdNb2RlKSB7CiAgICAgICAgICAgICAgICAgICAgY29uc3QgdG9rZW5DaHVua3NGb3JMb2cgPSB0b2tlbkNodW5rcy5tYXAodENodW5rID0+IHRDaHVuayAmJiB0Q2h1bmsudG9rZW4pCiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWJ1Z0xvZyhgU3VjY2Vzc2Z1bGx5IHBhcnNlZCB2YWx1ZXMgJHtKU09OLnN0cmluZ2lmeSh2YWx1ZVJlc3VsdHMpfVxuZm9yICR7SlNPTi5zdHJpbmdpZnkodG9rZW5DaHVua3NGb3JMb2cpfVxuaW4gZm9ybWF0IHBhdHRlcm4gJyR7dGhpcy5mb3JtYXRTdHJpbmd9J2ApCiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICBpZiAodGhpcy5kZWJ1Z01vZGUpIHsKICAgICAgICAgICAgICAgICAgICB0aGlzLmRlYnVnTG9nKGBUaGUgaW5wdXQgc3RyaW5nIGluICJ2LW1vZGVsIiBkb2VzIE5PVCBtYXRjaCB0aGUgImZvcm1hdCIgcGF0dGVyblxuZm9ybWF0OiAke3RoaXMuZm9ybWF0U3RyaW5nfVxudi1tb2RlbDogJHtzdHJpbmdWYWx1ZX1gKQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgfSwKCiAgICAgICAgcG9seWZpbGxNYXRjaEFsbCh0YXJnZXRTdHJpbmcsIHJlZ3hTdHIpIHsKICAgICAgICAgICAgY29uc3QgbWF0Y2hlc0xpc3QgPSB0YXJnZXRTdHJpbmcubWF0Y2gobmV3IFJlZ0V4cChyZWd4U3RyLCAnZycpKQogICAgICAgICAgICBjb25zdCByZXN1bHQgPSBbXQogICAgICAgICAgICBjb25zdCBpbmRpY2VzUmVnID0gW10KICAgICAgICAgICAgaWYgKG1hdGNoZXNMaXN0ICYmIG1hdGNoZXNMaXN0Lmxlbmd0aCkgewogICAgICAgICAgICAgICAgbWF0Y2hlc0xpc3QuZm9yRWFjaChtYXRjaGVkSXRlbSA9PiB7CiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXhpc3RJbmRleCA9IGluZGljZXNSZWcuZmluZEluZGV4KGlkeEl0ZW0gPT4gaWR4SXRlbS5zdHIgPT09IG1hdGNoZWRJdGVtKQogICAgICAgICAgICAgICAgICAgIGxldCBpbmRleAogICAgICAgICAgICAgICAgICAgIGlmIChleGlzdEluZGV4ID49IDApIHsKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGljZXNSZWdbZXhpc3RJbmRleF0gJiYgaW5kaWNlc1JlZ1tleGlzdEluZGV4XS5yZWdleCkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBpbmRpY2VzUmVnW2V4aXN0SW5kZXhdLnJlZ2V4LmV4ZWModGFyZ2V0U3RyaW5nKS5pbmRleAogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaXRlbUluZGljZXNSZWdleCA9IG5ldyBSZWdFeHAobWF0Y2hlZEl0ZW0sICdnJykKICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBpdGVtSW5kaWNlc1JlZ2V4LmV4ZWModGFyZ2V0U3RyaW5nKS5pbmRleAogICAgICAgICAgICAgICAgICAgICAgICBpbmRpY2VzUmVnLnB1c2goewogICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyOiBTdHJpbmcobWF0Y2hlZEl0ZW0pLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVnZXg6IGl0ZW1JbmRpY2VzUmVnZXgKICAgICAgICAgICAgICAgICAgICAgICAgfSkKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goewogICAgICAgICAgICAgICAgICAgICAgICAwOiBTdHJpbmcobWF0Y2hlZEl0ZW0pLAogICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogaW5kZXgKICAgICAgICAgICAgICAgICAgICB9KQogICAgICAgICAgICAgICAgfSkKICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gcmVzdWx0CiAgICAgICAgfSwKCiAgICAgICAgYWRkRmFsbGJhY2tWYWx1ZXMoKSB7CiAgICAgICAgICAgIGNvbnN0IHRpbWVWYWx1ZSA9IHt9CiAgICAgICAgICAgIHRoaXMuaW5Vc2UudHlwZXMuZm9yRWFjaCh0eXBlID0+IHsKICAgICAgICAgICAgICAgIHRpbWVWYWx1ZVt0aGlzLmdldFRva2VuQnlUeXBlKHR5cGUpXSA9ICcnCiAgICAgICAgICAgIH0pCiAgICAgICAgICAgIHRoaXMudGltZVZhbHVlID0gdGltZVZhbHVlCiAgICAgICAgfSwKCiAgICAgICAgc2V0VmFsdWVGcm9tU3RyaW5nKHBhcnNlZFZhbHVlLCB0b2tlbikgewogICAgICAgICAgICBpZiAoIXRva2VuIHx8ICFwYXJzZWRWYWx1ZSkgeyByZXR1cm4gJycgfQogICAgICAgICAgICBjb25zdCB0b2tlblR5cGUgPSB0aGlzLmdldFRva2VuVHlwZSh0b2tlbikKICAgICAgICAgICAgaWYgKCF0b2tlblR5cGUgfHwgIXRva2VuVHlwZS5sZW5ndGgpIHsgcmV0dXJuICcnIH0KICAgICAgICAgICAgY29uc3Qgc3RkVmFsdWUgPSAocGFyc2VkVmFsdWUgIT09IHRoaXMuZ2V0VG9rZW5CeVR5cGUodG9rZW5UeXBlKSkgPyBwYXJzZWRWYWx1ZSA6ICcnCiAgICAgICAgICAgIHRoaXNbdG9rZW5UeXBlXSA9IHN0ZFZhbHVlCiAgICAgICAgICAgIHJldHVybiBzdGRWYWx1ZQogICAgICAgIH0sCgogICAgICAgIGZpbGxWYWx1ZXMoZm9yY2VFbWl0KSB7CiAgICAgICAgICAgIGNvbnN0IGZ1bGxWYWx1ZXMgPSB7fQoKICAgICAgICAgICAgY29uc3QgYmFzZUhvdXIgPSB0aGlzLmhvdXIKICAgICAgICAgICAgY29uc3QgYmFzZUhvdXJUeXBlID0gdGhpcy5ob3VyVHlwZQoKICAgICAgICAgICAgbGV0IGFwbVZhbHVlCgogICAgICAgICAgICAvLyBIb3VyIHR5cGUgb3IgaG91ciB2YWx1ZSBpcyBOT1Qgc2V0IGluIHRoZSAiZm9ybWF0IiBzdHJpbmcKICAgICAgICAgICAgaWYgKCFiYXNlSG91clR5cGUgfHwgIXRoaXMuaXNOdW1iZXIoYmFzZUhvdXIpKSB7CiAgICAgICAgICAgICAgICBDT05GSUcuSE9VUl9UT0tFTlMuZm9yRWFjaCh0b2tlbiA9PiBmdWxsVmFsdWVzW3Rva2VuXSA9ICcnKQogICAgICAgICAgICAgICAgYXBtVmFsdWUgPSB0aGlzLmxvd2VyQ2FzZWRBcG0odGhpcy5hcG0gfHwgJycpCiAgICAgICAgICAgICAgICBmdWxsVmFsdWVzLmEgPSBhcG1WYWx1ZQogICAgICAgICAgICAgICAgZnVsbFZhbHVlcy5BID0gYXBtVmFsdWUudG9VcHBlckNhc2UoKQoKICAgICAgICAgICAgICAgIC8vIEJvdGggSG91ciB0eXBlIGFuZCB2YWx1ZSBhcmUgc2V0CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICBjb25zdCBob3VyVmFsdWUgPSArYmFzZUhvdXIKICAgICAgICAgICAgICAgIGNvbnN0IGFwbVZhbHVlID0gKHRoaXMuYmFzZU9uMTJIb3VycyAmJiB0aGlzLmFwbSkgPyB0aGlzLmxvd2VyQ2FzZWRBcG0odGhpcy5hcG0pIDogZmFsc2UKCiAgICAgICAgICAgICAgICBDT05GSUcuSE9VUl9UT0tFTlMuZm9yRWFjaCgodG9rZW4pID0+IHsKICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW4gPT09IGJhc2VIb3VyVHlwZSkgewogICAgICAgICAgICAgICAgICAgICAgICBmdWxsVmFsdWVzW3Rva2VuXSA9IGJhc2VIb3VyCiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybgogICAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAgICAgbGV0IHZhbHVlCiAgICAgICAgICAgICAgICAgICAgbGV0IGFwbQogICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodG9rZW4pIHsKICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnSCc6CiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ0hIJzoKICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnayc6CiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2trJzoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmJhc2VPbjEySG91cnMpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXBtVmFsdWUgPT09ICdwbScpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBob3VyVmFsdWUgPCAxMiA/IGhvdXJWYWx1ZSArIDEyIDogaG91clZhbHVlCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChbJ2snLCAna2snXS5pbmNsdWRlcyh0b2tlbikpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBob3VyVmFsdWUgPT09IDEyID8gMjQgOiBob3VyVmFsdWUKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGhvdXJWYWx1ZSAlIDEyCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoWydrJywgJ2trJ10uaW5jbHVkZXModG9rZW4pKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gaG91clZhbHVlID09PSAwID8gMjQgOiBob3VyVmFsdWUKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGhvdXJWYWx1ZSAlIDI0CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVsbFZhbHVlc1t0b2tlbl0gPSB0aGlzLmZvcm1hdFZhbHVlKHRva2VuLCB2YWx1ZSkKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrCiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2gnOgogICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdoaCc6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBoIDwtPiBoaAogICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYmFzZU9uMTJIb3VycykgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gaG91clZhbHVlCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBtID0gYXBtVmFsdWUgfHwgJycKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZWFkIGZyb20gb3RoZXIgaG91ciBmb3JtYXRzCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChob3VyVmFsdWUgPiAxMSAmJiBob3VyVmFsdWUgPCAyNCkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcG0gPSAncG0nCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gaG91clZhbHVlID09PSAxMiA/IDEyIDogaG91clZhbHVlICUgMTIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcG0gPSAnYW0nCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gaG91clZhbHVlICUgMTIgPT09IDAgPyAxMiA6IGhvdXJWYWx1ZQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bGxWYWx1ZXNbdG9rZW5dID0gdGhpcy5mb3JtYXRWYWx1ZSh0b2tlbiwgdmFsdWUpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdWxsVmFsdWVzLmEgPSBhcG0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bGxWYWx1ZXMuQSA9IGFwbS50b1VwcGVyQ2FzZSgpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhawogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0pCiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIGZ1bGxWYWx1ZXMubSA9IHRoaXMuZm9ybWF0VmFsdWUoJ20nLCB0aGlzLm1pbnV0ZSkKICAgICAgICAgICAgZnVsbFZhbHVlcy5tbSA9IHRoaXMuZm9ybWF0VmFsdWUoJ21tJywgdGhpcy5taW51dGUpCiAgICAgICAgICAgIGZ1bGxWYWx1ZXMucyA9IHRoaXMuZm9ybWF0VmFsdWUoJ3MnLCB0aGlzLnNlY29uZCkKICAgICAgICAgICAgZnVsbFZhbHVlcy5zcyA9IHRoaXMuZm9ybWF0VmFsdWUoJ3NzJywgdGhpcy5zZWNvbmQpCgogICAgICAgICAgICB0aGlzLmZ1bGxWYWx1ZXMgPSBmdWxsVmFsdWVzCgogICAgICAgICAgICAvLyBPbiBsYXp5IG1vZGUsIGVtaXQgYGlucHV0YCBhbmQgYGNoYW5nZWAgZXZlbnRzIG9ubHkgd2hlbjoKICAgICAgICAgICAgLy8gLSBUaGUgdXNlciBwaWNrIGEgbmV3IHZhbHVlIGFuZCB0aGVuIGNsb3NlIHRoZSBkcm9wZG93bgogICAgICAgICAgICAvLyAtIFRoZSB1c2VyIGNsaWNrIHRoZSAoIngiKSBjbGVhciBidXR0b24KICAgICAgICAgICAgaWYgKCF0aGlzLmxhenkgfHwgZm9yY2VFbWl0KSB7CiAgICAgICAgICAgICAgICB0aGlzLmVtaXRUaW1lVmFsdWUoKQogICAgICAgICAgICB9CgogICAgICAgICAgICBpZiAodGhpcy5jbG9zZU9uQ29tcGxldGUgJiYgdGhpcy5hbGxWYWx1ZVNlbGVjdGVkICYmIHRoaXMuc2hvd0Ryb3Bkb3duKSB7CiAgICAgICAgICAgICAgICB0aGlzLnRvZ2dsZUFjdGl2ZSgpCiAgICAgICAgICAgIH0KICAgICAgICB9LAoKICAgICAgICBnZXRGdWxsRGF0YSgpIHsKICAgICAgICAgICAgaWYgKCF0aGlzLmZ1bGxWYWx1ZXMpIHsKICAgICAgICAgICAgICAgIHRoaXMuZmlsbFZhbHVlcygpCiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIHsKICAgICAgICAgICAgICAgIGRhdGE6IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodGhpcy5mdWxsVmFsdWVzKSksCiAgICAgICAgICAgICAgICBkaXNwbGF5VGltZTogdGhpcy5pbnB1dElzRW1wdHkgPyAnJyA6IFN0cmluZyh0aGlzLmRpc3BsYXlUaW1lKQogICAgICAgICAgICB9CiAgICAgICAgfSwKCiAgICAgICAgZW1pdFRpbWVWYWx1ZSgpIHsKICAgICAgICAgICAgaWYgKHRoaXMubGF6eSAmJiB0aGlzLmJha0Rpc3BsYXlUaW1lID09PSB0aGlzLmRpc3BsYXlUaW1lKSB7CiAgICAgICAgICAgICAgICBpZiAodGhpcy5kZWJ1Z01vZGUpIHsKICAgICAgICAgICAgICAgICAgICB0aGlzLmRlYnVnTG9nKCdUaGUgdmFsdWUgZG9lcyBub3QgY2hhbmdlIG9uIGBsYXp5YCBtb2RlLiBTa2lwIHRoZSBlbWl0dGluZyBgaW5wdXRgIGFuZCBgY2hhbmdlYCBldmVudC4nKQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgcmV0dXJuCiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIGNvbnN0IGZ1bGxEYXRhID0gdGhpcy5nZXRGdWxsRGF0YSgpCgogICAgICAgICAgICBpZiAodGhpcy51c2VTdHJpbmdWYWx1ZSkgewogICAgICAgICAgICAgICAgdGhpcy4kZW1pdCgnaW5wdXQnLCBmdWxsRGF0YS5kaXNwbGF5VGltZSkKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIGNvbnN0IGZ1bGxWYWx1ZXMgPSBmdWxsRGF0YS5kYXRhCiAgICAgICAgICAgICAgICBjb25zdCB0b2tlbnNJblVzZSA9IHRoaXMuaW5Vc2UudG9rZW5zIHx8IFtdCiAgICAgICAgICAgICAgICBjb25zdCB0aW1lVmFsdWUgPSB7fQogICAgICAgICAgICAgICAgdG9rZW5zSW5Vc2UuZm9yRWFjaCgodG9rZW4pID0+IHsKICAgICAgICAgICAgICAgICAgICB0aW1lVmFsdWVbdG9rZW5dID0gZnVsbFZhbHVlc1t0b2tlbl0gfHwgJycKICAgICAgICAgICAgICAgIH0pCiAgICAgICAgICAgICAgICB0aGlzLiRlbWl0KCdpbnB1dCcsIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodGltZVZhbHVlKSkpCiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIHRoaXMuJGVtaXQoJ2NoYW5nZScsIGZ1bGxEYXRhKQogICAgICAgIH0sCgogICAgICAgIHRyYW5zbGF0ZTEyaFJhbmdlKHZhbHVlKSB7CiAgICAgICAgICAgIGNvbnN0IHZhbHVlVCA9IHRoaXMubWF0Y2gxMmhSYW5nZSh2YWx1ZSkKICAgICAgICAgICAgaWYgKCt2YWx1ZVRbMV0gPT09IDEyKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gK3ZhbHVlVFsxXSArICh2YWx1ZVRbMl0udG9Mb3dlckNhc2UoKSA9PT0gJ3AnID8gMCA6IDEyKQogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiArdmFsdWVUWzFdICsgKHZhbHVlVFsyXS50b0xvd2VyQ2FzZSgpID09PSAncCcgPyAxMiA6IDApCiAgICAgICAgfSwKCiAgICAgICAgaXNEaXNhYmxlZCh0eXBlLCB2YWx1ZSkgewogICAgICAgICAgICBpZiAoIXRoaXMuaXNCYXNpY1R5cGUodHlwZSkgfHwgIXRoaXMuaW5Vc2VbdHlwZV0pIHsgcmV0dXJuIHRydWUgfQogICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHsKICAgICAgICAgICAgICAgIGNhc2UgJ2hvdXInOgogICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmlzRGlzYWJsZWRIb3VyKHZhbHVlKQogICAgICAgICAgICAgICAgY2FzZSAnbWludXRlJzoKICAgICAgICAgICAgICAgIGNhc2UgJ3NlY29uZCc6CiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzW2Ake3R5cGV9UmFuZ2VMaXN0YF0pIHsKICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlCiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIHJldHVybiAhdGhpc1tgJHt0eXBlfVJhbmdlTGlzdGBdLmluY2x1ZGVzKHZhbHVlKQogICAgICAgICAgICAgICAgY2FzZSAnYXBtJzoKICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMucmVzdHJpY3RlZEhvdXJSYW5nZSkgewogICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2UKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICF0aGlzLmhhc1t0aGlzLmxvd2VyQ2FzZWRBcG0odmFsdWUpXQogICAgICAgICAgICAgICAgZGVmYXVsdDoKICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZQogICAgICAgICAgICB9CiAgICAgICAgfSwKCiAgICAgICAgaXNEaXNhYmxlZEhvdXIodmFsdWUpIHsKICAgICAgICAgICAgaWYgKCF0aGlzLnJlc3RyaWN0ZWRIb3VyUmFuZ2UpIHsgcmV0dXJuIGZhbHNlIH0KICAgICAgICAgICAgaWYgKHRoaXMuYmFzZU9uMTJIb3VycykgewogICAgICAgICAgICAgICAgaWYgKCF0aGlzLmFwbSB8fCAhdGhpcy5hcG0ubGVuZ3RoKSB7CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlCiAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgIGNvbnN0IHRva2VuID0gdGhpcy5hcG0udG9Mb3dlckNhc2UoKSA9PT0gJ2FtJyA/ICdhJyA6ICdwJwogICAgICAgICAgICAgICAgICAgIHJldHVybiAhdGhpcy5yZXN0cmljdGVkSG91clJhbmdlLmluY2x1ZGVzKGAkeyt2YWx1ZX0ke3Rva2VufWApCiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgICAgLy8gRmFsbGJhY2sgZm9yICdISCcgYW5kICdIIGhvdXIgZm9ybWF0IHdpdGggYSBgaG91ci1yYW5nZWAgaW4gYSAxMi1ob3VyIGZvcm0KICAgICAgICAgICAgaWYgKAogICAgICAgICAgICAgICAgKHRoaXMuaG91clR5cGUgPT09ICdISCcgfHwgdGhpcy5ob3VyVHlwZSA9PT0gJ0gnKSAmJgogICAgICAgICAgICAgICAgK3ZhbHVlID09PSAwICYmIHRoaXMucmVzdHJpY3RlZEhvdXJSYW5nZS5pbmNsdWRlcygyNCkKICAgICAgICAgICAgKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2UKICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gIXRoaXMucmVzdHJpY3RlZEhvdXJSYW5nZS5pbmNsdWRlcygrdmFsdWUpCiAgICAgICAgfSwKCiAgICAgICAgbm90SW5JbnRlcnZhbChzZWN0aW9uLCB2YWx1ZSkgewogICAgICAgICAgICBpZiAoIXNlY3Rpb24gfHwgIXRoaXMuaXNNaW51dGVPclNlY29uZChzZWN0aW9uKSkgeyByZXR1cm4gfQogICAgICAgICAgICBpZiAodGhpcy5vcHRzW2Ake3NlY3Rpb259SW50ZXJ2YWxgXSA9PT0gMSkgeyByZXR1cm4gZmFsc2UgfQogICAgICAgICAgICByZXR1cm4gK3ZhbHVlICUgdGhpcy5vcHRzW2Ake3NlY3Rpb259SW50ZXJ2YWxgXSAhPT0gMAogICAgICAgIH0sCgogICAgICAgIHJlbmRlclJhbmdlTGlzdChyYXdSYW5nZSwgc2VjdGlvbikgewogICAgICAgICAgICBpZiAoIXJhd1JhbmdlIHx8ICFzZWN0aW9uIHx8ICF0aGlzLmlzTWludXRlT3JTZWNvbmQoc2VjdGlvbikpIHsgcmV0dXJuIFtdIH0KICAgICAgICAgICAgY29uc3QgcmFuZ2UgPSBbXQogICAgICAgICAgICBsZXQgZm9ybWF0ZWRWYWx1ZQogICAgICAgICAgICByYXdSYW5nZS5mb3JFYWNoKHZhbHVlID0+IHsKICAgICAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5KSB7CiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA+IDIgJiYgdGhpcy5kZWJ1Z01vZGUpIHsKICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWJ1Z0xvZyhgTmVzdGVkIGFycmF5IHdpdGhpbiAiJHtzZWN0aW9ufS1yYW5nZSIgbXVzdCBjb250YWluIG5vIG1vcmUgdGhhbiB0d28gaXRlbXMuIE9ubHkgdGhlIGZpcnN0IHR3byBpdGVtcyBvZiAke0pTT04uc3RyaW5naWZ5KHZhbHVlKX0gd2lsbCBiZSB0YWtlbiBpbnRvIGFjY291bnQuYCkKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSB2YWx1ZVswXQogICAgICAgICAgICAgICAgICAgIGNvbnN0IGVuZCA9IHZhbHVlWzFdIHx8IHZhbHVlWzBdCiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9ICtzdGFydDsgaSA8PSArZW5kOyBpKyspIHsKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPCAwIHx8IGkgPiA1OSkgeyBjb250aW51ZSB9CiAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdGVkVmFsdWUgPSB0aGlzLmZvcm1hdFZhbHVlKHRoaXMuZ2V0VG9rZW5CeVR5cGUoc2VjdGlvbiksIGkpCiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcmFuZ2UuaW5jbHVkZXMoZm9ybWF0ZWRWYWx1ZSkpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlLnB1c2goZm9ybWF0ZWRWYWx1ZSkKICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgaWYgKCt2YWx1ZSA8IDAgfHwgK3ZhbHVlID4gNTkpIHsgcmV0dXJuIH0KICAgICAgICAgICAgICAgICAgICBmb3JtYXRlZFZhbHVlID0gdGhpcy5mb3JtYXRWYWx1ZSh0aGlzLmdldFRva2VuQnlUeXBlKHNlY3Rpb24pLCB2YWx1ZSkKICAgICAgICAgICAgICAgICAgICBpZiAoIXJhbmdlLmluY2x1ZGVzKGZvcm1hdGVkVmFsdWUpKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlLnB1c2goZm9ybWF0ZWRWYWx1ZSkKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0pCiAgICAgICAgICAgIHJhbmdlLnNvcnQoKGwsIHIpID0+IHsgcmV0dXJuIGwgLSByIH0pCiAgICAgICAgICAgIC8vIERlYnVnIE1vZGUKICAgICAgICAgICAgaWYgKHRoaXMuZGVidWdNb2RlKSB7CiAgICAgICAgICAgICAgICBjb25zdCBmdWxsTGlzdCA9IChzZWN0aW9uID09PSAnbWludXRlJyA/IHRoaXMubWludXRlcyA6IHRoaXMuc2Vjb25kcykgfHwgW10KICAgICAgICAgICAgICAgIGNvbnN0IHZhbGlkSXRlbXMgPSBmdWxsTGlzdC5maWx0ZXIoaXRlbSA9PiByYW5nZS5pbmNsdWRlcyhpdGVtKSkKICAgICAgICAgICAgICAgIGlmICghdmFsaWRJdGVtcyB8fCAhdmFsaWRJdGVtcy5sZW5ndGgpIHsKICAgICAgICAgICAgICAgICAgICBpZiAoc2VjdGlvbiA9PT0gJ21pbnV0ZScpIHsKICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWJ1Z0xvZyhgVGhlIG1pbnV0ZSBsaXN0IGlzIGVtcHR5IGR1ZSB0byB0aGUgIm1pbnV0ZS1yYW5nZSIgY29uZmlnXG5taW51dGUtcmFuZ2U6ICR7SlNPTi5zdHJpbmdpZnkodGhpcy5taW51dGVSYW5nZSl9XG5taW51dGUtaW50ZXJ2YWw6ICR7dGhpcy5vcHRzLm1pbnV0ZUludGVydmFsfWApCiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWJ1Z0xvZyhgVGhlIHNlY29uZCBsaXN0IGlzIGVtcHR5IGR1ZSB0byB0aGUgInNlY29uZC1yYW5nZSIgY29uZmlnXG5zZWNvbmQtcmFuZ2U6ICR7SlNPTi5zdHJpbmdpZnkodGhpcy5zZWNvbmRSYW5nZSl9XG5zZWNvbmQtaW50ZXJ2YWw6ICR7dGhpcy5vcHRzLnNlY29uZEludGVydmFsfWApCiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiByYW5nZQogICAgICAgIH0sCgogICAgICAgIGZvcmNlQXBtU2VsZWN0aW9uKCkgewogICAgICAgICAgICBpZiAodGhpcy5tYW51YWxJbnB1dCkgewogICAgICAgICAgICAgICAgLy8gU2tpcCB0aGlzIHRvIGFsbG93IHVzZXJzIHRvIHBhc3RlIGEgc3RyaW5nIHZhbHVlIGZyb20gdGhlIGNsaXBib2FyZCBpbiBNYW51YWwgSW5wdXQgbW9kZQogICAgICAgICAgICAgICAgcmV0dXJuCiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKHRoaXMuYXBtVHlwZSAmJiAhdGhpcy5hcG0pIHsKICAgICAgICAgICAgICAgIGlmICh0aGlzLmhhcy5hbSB8fCB0aGlzLmhhcy5wbSkgewogICAgICAgICAgICAgICAgICAgIHRoaXMuZG9DbGVhckFwbUNoZWNraW5nID0gdHJ1ZQogICAgICAgICAgICAgICAgICAgIGNvbnN0IGFwbVZhbHVlID0gdGhpcy5oYXMuYW0gPyAnYW0nIDogJ3BtJwogICAgICAgICAgICAgICAgICAgIHRoaXMuYXBtID0gdGhpcy5hcG1UeXBlID09PSAnQScgPyBhcG1WYWx1ZS50b1VwcGVyQ2FzZSgpIDogYXBtVmFsdWUKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgIH0sCgogICAgICAgIGVtcHR5QXBtU2VsZWN0aW9uKCkgewogICAgICAgICAgICBpZiAodGhpcy5kb0NsZWFyQXBtQ2hlY2tpbmcgJiYgdGhpcy5ob3VyID09PSAnJyAmJiB0aGlzLm1pbnV0ZSA9PT0gJycgJiYgdGhpcy5zZWNvbmQgPT09ICcnKSB7CiAgICAgICAgICAgICAgICB0aGlzLmFwbSA9ICcnCiAgICAgICAgICAgIH0KICAgICAgICAgICAgdGhpcy5kb0NsZWFyQXBtQ2hlY2tpbmcgPSBmYWxzZQogICAgICAgIH0sCgogICAgICAgIGFwbURpc3BsYXlUZXh0KGFwbVZhbHVlKSB7CiAgICAgICAgICAgIGlmICh0aGlzLmFtVGV4dCAmJiB0aGlzLmxvd2VyQ2FzZWRBcG0oYXBtVmFsdWUpID09PSAnYW0nKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hbVRleHQKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAodGhpcy5wbVRleHQgJiYgdGhpcy5sb3dlckNhc2VkQXBtKGFwbVZhbHVlKSA9PT0gJ3BtJykgewogICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucG1UZXh0CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIGFwbVZhbHVlCiAgICAgICAgfSwKCiAgICAgICAgdG9nZ2xlQWN0aXZlKCkgewogICAgICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCkgeyByZXR1cm4gfQogICAgICAgICAgICB0aGlzLmlzQWN0aXZlID0gIXRoaXMuaXNBY3RpdmUKCiAgICAgICAgICAgIGlmICh0aGlzLmlzQWN0aXZlKSB7CiAgICAgICAgICAgICAgICB0aGlzLmlzRm9jdXNpbmcgPSB0cnVlCiAgICAgICAgICAgICAgICBpZiAodGhpcy5tYW51YWxJbnB1dCkgewogICAgICAgICAgICAgICAgICAgIHRoaXMuJGVtaXQoJ2ZvY3VzJykKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGlmICghdGhpcy5vcHRzLmhpZGVEcm9wZG93bikgewogICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0RHJvcGRvd25TdGF0ZSh0cnVlKQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgLy8gUmVjb3JkIHRvIGNoZWNrIGlmIHZhbHVlIGRpZCBjaGFuZ2UgaW4gdGhlIGxhdGVyIHBoYXNlCiAgICAgICAgICAgICAgICBpZiAodGhpcy5sYXp5KSB7CiAgICAgICAgICAgICAgICAgICAgdGhpcy5iYWtEaXNwbGF5VGltZSA9IFN0cmluZyh0aGlzLmRpc3BsYXlUaW1lIHx8ICcnKQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKHRoaXMubWFudWFsSW5wdXQgJiYgIXRoaXMuaW5wdXRJc0VtcHR5KSB7CiAgICAgICAgICAgICAgICAgICAgdGhpcy4kbmV4dFRpY2soKCkgPT4gewogICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy4kcmVmcy5pbnB1dCAmJiB0aGlzLiRyZWZzLmlucHV0LnNlbGVjdGlvblN0YXJ0ID09PSAwICYmIHRoaXMuJHJlZnMuaW5wdXQuc2VsZWN0aW9uRW5kID09PSB0aGlzLmRpc3BsYXlUaW1lLmxlbmd0aCkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2VsZWN0IHRoZSBmaXJzdCBzbG90IGluc3RlYWQgb2YgdGhlIHdob2xlIHZhbHVlIHN0cmluZyB3aGVuIHRhYmJlZCBpbgogICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RGaXJzdFNsb3QoKQogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgfSkKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIGlmICh0aGlzLnNob3dEcm9wZG93bikgewogICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0RHJvcGRvd25TdGF0ZShmYWxzZSkKICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5tYW51YWxJbnB1dCkgewogICAgICAgICAgICAgICAgICAgIHRoaXMuJGVtaXQoJ2JsdXInLCB0aGlzLmdldEZ1bGxEYXRhKCkpCiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB0aGlzLmlzRm9jdXNpbmcgPSBmYWxzZQogICAgICAgICAgICAgICAgaWYgKHRoaXMubGF6eSkgewogICAgICAgICAgICAgICAgICAgIHRoaXMuZmlsbFZhbHVlcyh0cnVlKQogICAgICAgICAgICAgICAgICAgIHRoaXMuYmFrRGlzcGxheVRpbWUgPSB1bmRlZmluZWQKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQoKICAgICAgICAgICAgaWYgKHRoaXMucmVzdHJpY3RlZEhvdXJSYW5nZSAmJiB0aGlzLmJhc2VPbjEySG91cnMpIHsKICAgICAgICAgICAgICAgIHRoaXMuc2hvd0Ryb3Bkb3duID8gdGhpcy5mb3JjZUFwbVNlbGVjdGlvbigpIDogdGhpcy5lbXB0eUFwbVNlbGVjdGlvbigpCiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKHRoaXMuc2hvd0Ryb3Bkb3duKSB7CiAgICAgICAgICAgICAgICB0aGlzLmNoZWNrRm9yQXV0b1Njcm9sbCgpCiAgICAgICAgICAgIH0KICAgICAgICB9LAoKICAgICAgICBzZXREcm9wZG93blN0YXRlKHRvU2hvdywgZnJvbVVzZXJDbGljayA9IGZhbHNlKSB7CiAgICAgICAgICAgIGlmICh0b1Nob3cpIHsKICAgICAgICAgICAgICAgIGlmICh0aGlzLmFwcGVuZFRvQm9keSkgewogICAgICAgICAgICAgICAgICAgIHRoaXMuYXBwZW5kRHJvcGRvd25Ub0JvZHkoKQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgdGhpcy5rZWVwRm9jdXNpbmcoKQogICAgICAgICAgICAgICAgaWYgKHRoaXMuYXV0b0RpcmVjdGlvbkVuYWJsZWQpIHsKICAgICAgICAgICAgICAgICAgICB0aGlzLmNoZWNrRHJvcERpcmVjdGlvbigpCiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB0aGlzLnNob3dEcm9wZG93biA9IHRydWUKICAgICAgICAgICAgICAgIHRoaXMuJGVtaXQoJ29wZW4nKQogICAgICAgICAgICAgICAgaWYgKGZyb21Vc2VyQ2xpY2spIHsKICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5maXhlZERyb3Bkb3duQnV0dG9uKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaXNBY3RpdmUgPSB0cnVlCiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIHRoaXMuJGVtaXQoJ2JsdXInLCB0aGlzLmdldEZ1bGxEYXRhKCkpCiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGVja0ZvckF1dG9TY3JvbGwoKQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgdGhpcy5zaG93RHJvcGRvd24gPSBmYWxzZQogICAgICAgICAgICAgICAgdGhpcy4kZW1pdCgnY2xvc2UnLCB0aGlzLmdldEZ1bGxEYXRhKCkpCiAgICAgICAgICAgICAgICBpZiAodGhpcy5hcHBlbmRUb0JvZHkpIHsKICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZURyb3Bkb3duRnJvbUJvZHkoKQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgfSwKCiAgICAgICAgYXBwZW5kRHJvcGRvd25Ub0JvZHkoKSB7CiAgICAgICAgICAgIGNvbnN0IGRyb3Bkb3duID0gdGhpcy4kcmVmcyAmJiB0aGlzLiRyZWZzLmRyb3Bkb3duCiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnYm9keScpWzBdCiAgICAgICAgICAgIGlmIChib2R5ICYmIGRyb3Bkb3duKSB7CiAgICAgICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy51cGRhdGVEcm9wZG93blBvcykKICAgICAgICAgICAgICAgIGRyb3Bkb3duLmNsYXNzTGlzdC5hZGQoJ3Z1ZV9fdGltZS1waWNrZXItZHJvcGRvd24nKQogICAgICAgICAgICAgICAgdGhpcy51cGRhdGVEcm9wZG93blBvcygpCiAgICAgICAgICAgICAgICBib2R5LmFwcGVuZENoaWxkKGRyb3Bkb3duKQogICAgICAgICAgICB9CiAgICAgICAgfSwKCiAgICAgICAgdXBkYXRlRHJvcGRvd25Qb3MoKSB7CiAgICAgICAgICAgIGlmICghdGhpcy5hcHBlbmRUb0JvZHkpIHsgcmV0dXJuIH0KICAgICAgICAgICAgY29uc3QgZHJvcGRvd24gPSB0aGlzLiRyZWZzICYmIHRoaXMuJHJlZnMuZHJvcGRvd24KICAgICAgICAgICAgY29uc3QgYm9keSA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdib2R5JylbMF0KICAgICAgICAgICAgaWYgKGJvZHkgJiYgZHJvcGRvd24pIHsKICAgICAgICAgICAgICAgIGNvbnN0IGJveCA9IHRoaXMuJGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpCiAgICAgICAgICAgICAgICBpZiAodGhpcy5kcm9wZG93bkRpckNsYXNzID09PSAnZHJvcC11cCcpIHsKICAgICAgICAgICAgICAgICAgICBkcm9wZG93bi5zdHlsZS5ib3R0b20gPSBgJHt3aW5kb3cuaW5uZXJIZWlnaHQgLSBib3gueX1weGAKICAgICAgICAgICAgICAgICAgICBkcm9wZG93bi5zdHlsZS50b3AgPSAnYXV0bycKICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgZHJvcGRvd24uc3R5bGUudG9wID0gYCR7Ym94LnkgKyBib3guaGVpZ2h0fXB4YAogICAgICAgICAgICAgICAgICAgIGRyb3Bkb3duLnN0eWxlLmJvdHRvbSA9ICdhdXRvJwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgZHJvcGRvd24uc3R5bGUubGVmdCA9IGAke2JveC54fXB4YAogICAgICAgICAgICB9CiAgICAgICAgfSwKCiAgICAgICAgcmVtb3ZlRHJvcGRvd25Gcm9tQm9keSgpIHsKICAgICAgICAgICAgY29uc3QgZHJvcGRvd24gPSB0aGlzLiRyZWZzICYmIHRoaXMuJHJlZnMuZHJvcGRvd24KICAgICAgICAgICAgY29uc3QgYm9keSA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdib2R5JylbMF0KICAgICAgICAgICAgaWYgKGJvZHkgJiYgZHJvcGRvd24gJiYgYm9keS5jb250YWlucyhkcm9wZG93bikpIHsKICAgICAgICAgICAgICAgIGJvZHkucmVtb3ZlQ2hpbGQoZHJvcGRvd24pCiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKGRyb3Bkb3duKSB7CiAgICAgICAgICAgICAgICBkcm9wZG93bi5jbGFzc0xpc3QucmVtb3ZlKCd2dWVfX3RpbWUtcGlja2VyLWRyb3Bkb3duJykKICAgICAgICAgICAgICAgIGRyb3Bkb3duLnN0eWxlLnRvcCA9ICcnCiAgICAgICAgICAgICAgICBkcm9wZG93bi5zdHlsZS5ib3R0b20gPSAnJwogICAgICAgICAgICAgICAgZHJvcGRvd24uc3R5bGUubGVmdCA9ICcnCiAgICAgICAgICAgICAgICB0aGlzLiRlbC5hcHBlbmRDaGlsZChkcm9wZG93bikKICAgICAgICAgICAgfQogICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy51cGRhdGVEcm9wZG93blBvcykKICAgICAgICB9LAoKICAgICAgICBibHVyRXZlbnQoKSB7CiAgICAgICAgICAgIGlmICh0aGlzLm1hbnVhbElucHV0ICYmICF0aGlzLm9wdHMuaGlkZURyb3Bkb3duKSB7CiAgICAgICAgICAgICAgICAvLyBoaWRlRHJvcGRvd24ncyBgYmx1cmAgZXZlbnQgaXMgaGFuZGxlZCBzb21ld2hlcmUgZWxzZQogICAgICAgICAgICAgICAgdGhpcy4kZW1pdCgnYmx1cicsIHRoaXMuZ2V0RnVsbERhdGEoKSkKICAgICAgICAgICAgfQogICAgICAgIH0sCgogICAgICAgIHNlbGVjdCh0eXBlLCB2YWx1ZSkgewogICAgICAgICAgICBpZiAodGhpcy5pc0Jhc2ljVHlwZSh0eXBlKSAmJiAhdGhpcy5pc0Rpc2FibGVkKHR5cGUsIHZhbHVlKSkgewogICAgICAgICAgICAgICAgdGhpc1t0eXBlXSA9IHZhbHVlCiAgICAgICAgICAgICAgICBpZiAodGhpcy5kb0NsZWFyQXBtQ2hlY2tpbmcpIHsKICAgICAgICAgICAgICAgICAgICB0aGlzLmRvQ2xlYXJBcG1DaGVja2luZyA9IGZhbHNlCiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICB9LAoKICAgICAgICBjbGVhclRpbWUoKSB7CiAgICAgICAgICAgIGlmICh0aGlzLmRpc2FibGVkKSB7IHJldHVybiB9CiAgICAgICAgICAgIHRoaXMuaG91ciA9ICcnCiAgICAgICAgICAgIHRoaXMubWludXRlID0gJycKICAgICAgICAgICAgdGhpcy5zZWNvbmQgPSAnJwogICAgICAgICAgICB0aGlzLmFwbSA9ICcnCgogICAgICAgICAgICBpZiAodGhpcy5tYW51YWxJbnB1dCAmJiB0aGlzLiRyZWZzICYmIHRoaXMuJHJlZnMuaW5wdXQgJiYgdGhpcy4kcmVmcy5pbnB1dC52YWx1ZS5sZW5ndGgpIHsKICAgICAgICAgICAgICAgIHRoaXMuJHJlZnMuaW5wdXQudmFsdWUgPSAnJwogICAgICAgICAgICB9CgogICAgICAgICAgICBpZiAodGhpcy5sYXp5KSB7CiAgICAgICAgICAgICAgICB0aGlzLmZpbGxWYWx1ZXModHJ1ZSkKICAgICAgICAgICAgfQogICAgICAgIH0sCgogICAgICAgIC8vCiAgICAgICAgLy8gQXV0by1TY3JvbGwKICAgICAgICAvLwoKICAgICAgICBjaGVja0ZvckF1dG9TY3JvbGwoKSB7CiAgICAgICAgICAgIGlmICh0aGlzLmlucHV0SXNFbXB0eSkgeyByZXR1cm4gfQogICAgICAgICAgICBpZiAodGhpcy5hdXRvU2Nyb2xsKSB7CiAgICAgICAgICAgICAgICB0aGlzLiRuZXh0VGljaygoKSA9PiB7CiAgICAgICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxUb1NlbGVjdGVkVmFsdWVzKCkKICAgICAgICAgICAgICAgIH0pCiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5hZHZhbmNlZEtleWJvYXJkKSB7CiAgICAgICAgICAgICAgICAvLyBBdXRvLWZvY3VzIG9uIHNlbGVjdGVkIHZhbHVlIGluIHRoZSBmaXJzdCBjb2x1bW4gZm9yIGFkdmFuY2VkLWtleWJvYXJkCiAgICAgICAgICAgICAgICB0aGlzLiRuZXh0VGljaygoKSA9PiB7CiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmlyc3RDb2x1bW4gPSB0aGlzLmluVXNlLnR5cGVzWzBdCiAgICAgICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxUb1NlbGVjdGVkKGZpcnN0Q29sdW1uLCB0cnVlKQogICAgICAgICAgICAgICAgfSkKICAgICAgICAgICAgfQogICAgICAgIH0sCgogICAgICAgIHNjcm9sbFRvU2VsZWN0ZWQoY29sdW1uLCBhbGxvd0ZhbGxiYWNrID0gZmFsc2UpIHsKICAgICAgICAgICAgaWYgKCF0aGlzLnRpbWVWYWx1ZSB8fCB0aGlzLmlucHV0SXNFbXB0eSkgeyByZXR1cm4gfQogICAgICAgICAgICBsZXQgdGFyZ2V0TGlzdAogICAgICAgICAgICBpZiAodGhpcy5hcHBlbmRUb0JvZHkgJiYgdGhpcy4kcmVmcyAmJiB0aGlzLiRyZWZzLmRyb3Bkb3duKSB7CiAgICAgICAgICAgICAgICB0YXJnZXRMaXN0ID0gdGhpcy4kcmVmcy5kcm9wZG93bi5xdWVyeVNlbGVjdG9yQWxsKGB1bC4ke2NvbHVtbn1zYClbMF0KICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIHRhcmdldExpc3QgPSB0aGlzLiRlbC5xdWVyeVNlbGVjdG9yQWxsKGB1bC4ke2NvbHVtbn1zYClbMF0KICAgICAgICAgICAgfQogICAgICAgICAgICBsZXQgdGFyZ2V0VmFsdWUgPSB0aGlzLmFjdGl2ZUl0ZW1JbkNvbChjb2x1bW4pWzBdCiAgICAgICAgICAgIGlmICghdGFyZ2V0VmFsdWUgJiYgYWxsb3dGYWxsYmFjaykgewogICAgICAgICAgICAgICAgLy8gTm8gdmFsdWUgc2VsZWN0ZWQgaW4gdGhlIHRhcmdldCBjb2x1bW4sIGZhbGxiYWNrIHRvIHRoZSBmaXJzdCBmb3VuZCB2YWxpZCBpdGVtCiAgICAgICAgICAgICAgICB0YXJnZXRWYWx1ZSA9IHRoaXMudmFsaWRJdGVtc0luQ29sKGNvbHVtbilbMF0KICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAodGFyZ2V0TGlzdCAmJiB0YXJnZXRWYWx1ZSkgewogICAgICAgICAgICAgICAgdGFyZ2V0TGlzdC5zY3JvbGxUb3AgPSB0YXJnZXRWYWx1ZS5vZmZzZXRUb3AgLSA0MAogICAgICAgICAgICAgICAgaWYgKHRoaXMuYWR2YW5jZWRLZXlib2FyZCkgewogICAgICAgICAgICAgICAgICAgIHRhcmdldFZhbHVlLmZvY3VzKCkKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgIH0sCgogICAgICAgIHNjcm9sbFRvU2VsZWN0ZWRWYWx1ZXMoKSB7CiAgICAgICAgICAgIGlmICghdGhpcy50aW1lVmFsdWUgfHwgdGhpcy5pbnB1dElzRW1wdHkpIHsgcmV0dXJuIH0KICAgICAgICAgICAgdGhpcy5pblVzZS50eXBlcy5mb3JFYWNoKHNlY3Rpb24gPT4gewogICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxUb1NlbGVjdGVkKHNlY3Rpb24pCiAgICAgICAgICAgIH0pCiAgICAgICAgfSwKCiAgICAgICAgLy8KICAgICAgICAvLyBBZGRpdGlvbmFsIEtleWJvYXJkIE5hdmlnYXRpb24KICAgICAgICAvLwoKICAgICAgICBvbkZvY3VzKCkgewogICAgICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCkgeyByZXR1cm4gfQogICAgICAgICAgICBpZiAoIXRoaXMuaXNGb2N1c2luZykgewogICAgICAgICAgICAgICAgdGhpcy5pc0ZvY3VzaW5nID0gdHJ1ZQogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmICghdGhpcy5pc0FjdGl2ZSkgewogICAgICAgICAgICAgICAgdGhpcy50b2dnbGVBY3RpdmUoKQogICAgICAgICAgICB9CiAgICAgICAgfSwKCiAgICAgICAgZXNjQmx1cigpIHsKICAgICAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQpIHsgcmV0dXJuIH0KICAgICAgICAgICAgd2luZG93LmNsZWFyVGltZW91dCh0aGlzLmRlYm91bmNlVGltZXIpCiAgICAgICAgICAgIHRoaXMuaXNGb2N1c2luZyA9IGZhbHNlCiAgICAgICAgICAgIGNvbnN0IGlucHV0Qm94ID0gdGhpcy4kZWwucXVlcnlTZWxlY3RvckFsbCgnaW5wdXQuZGlzcGxheS10aW1lJylbMF0KICAgICAgICAgICAgaWYgKGlucHV0Qm94KSB7CiAgICAgICAgICAgICAgICBpbnB1dEJveC5ibHVyKCkKICAgICAgICAgICAgfQogICAgICAgIH0sCgogICAgICAgIGRlYm91bmNlQmx1cigpIHsKICAgICAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQpIHsgcmV0dXJuIH0KICAgICAgICAgICAgdGhpcy5pc0ZvY3VzaW5nID0gZmFsc2UKICAgICAgICAgICAgd2luZG93LmNsZWFyVGltZW91dCh0aGlzLmRlYm91bmNlVGltZXIpCiAgICAgICAgICAgIHRoaXMuZGVib3VuY2VUaW1lciA9IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHsKICAgICAgICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5kZWJvdW5jZVRpbWVyKQogICAgICAgICAgICAgICAgdGhpcy5vbkJsdXIoKQogICAgICAgICAgICB9LCB0aGlzLm9wdHMuYmx1ckRlbGF5KQogICAgICAgIH0sCgogICAgICAgIG9uQmx1cigpIHsKICAgICAgICAgICAgaWYgKCF0aGlzLmRpc2FibGVkICYmICF0aGlzLmlzRm9jdXNpbmcgJiYgdGhpcy5pc0FjdGl2ZSkgewogICAgICAgICAgICAgICAgdGhpcy50b2dnbGVBY3RpdmUoKQogICAgICAgICAgICB9CiAgICAgICAgfSwKCiAgICAgICAga2VlcEZvY3VzaW5nKCkgewogICAgICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCkgeyByZXR1cm4gfQogICAgICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMuZGVib3VuY2VUaW1lcikKICAgICAgICAgICAgaWYgKCF0aGlzLmlzRm9jdXNpbmcpIHsKICAgICAgICAgICAgICAgIHRoaXMuaXNGb2N1c2luZyA9IHRydWUKICAgICAgICAgICAgfQogICAgICAgIH0sCgogICAgICAgIG9uVGFiKGNvbHVtbiwgdmFsdWUsIGV2dCkgewogICAgICAgICAgICBpZiAodGhpcy5hcHBlbmRUb0JvZHkgJiYgZXZ0LnNoaWZ0S2V5KSB7CiAgICAgICAgICAgICAgICBjb25zdCBmaXJzdENvbHVtbiA9IHRoaXMuaW5Vc2UudHlwZXNbMF0KICAgICAgICAgICAgICAgIGlmIChjb2x1bW4gIT09IGZpcnN0Q29sdW1uKSB7IHJldHVybiB9CiAgICAgICAgICAgICAgICBjb25zdCBmaXJzdFZhbGlkVmFsdWUgPSB0aGlzLnZhbGlkSXRlbXNJbkNvbChmaXJzdENvbHVtbilbMF0KICAgICAgICAgICAgICAgIC8vIElzIHRoZSBmaXJzdCB2YWxpZCBpdGVtIGluIHRoZSBmaXJzdCBjb2x1bW4KICAgICAgICAgICAgICAgIGlmIChmaXJzdFZhbGlkVmFsdWUgJiYgZmlyc3RWYWxpZFZhbHVlLmdldEF0dHJpYnV0ZSgnZGF0YS1rZXknKSA9PT0gU3RyaW5nKHZhbHVlKSkgewogICAgICAgICAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpCiAgICAgICAgICAgICAgICAgICAgLy8gRm9jdXMgYmFjayBvbiA8aW5wdXQ+CiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuJHJlZnMgJiYgdGhpcy4kcmVmcy5pbnB1dCkgewogICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRyZWZzLmlucHV0LmZvY3VzKCkKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICB9LAoKICAgICAgICB2YWxpZEl0ZW1zSW5Db2woY29sdW1uKSB7CiAgICAgICAgICAgIGNvbnN0IGNvbHVtbkNsYXNzID0gYCR7Y29sdW1ufXNgCiAgICAgICAgICAgIGlmICh0aGlzLmFwcGVuZFRvQm9keSAmJiB0aGlzLiRyZWZzICYmIHRoaXMuJHJlZnMuZHJvcGRvd24pIHsKICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRyZWZzLmRyb3Bkb3duLnF1ZXJ5U2VsZWN0b3JBbGwoYHVsLiR7Y29sdW1uQ2xhc3N9ID4gbGk6bm90KC5oaW50KTpub3QoW2Rpc2FibGVkXSlgKQogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiB0aGlzLiRlbC5xdWVyeVNlbGVjdG9yQWxsKGB1bC4ke2NvbHVtbkNsYXNzfSA+IGxpOm5vdCguaGludCk6bm90KFtkaXNhYmxlZF0pYCkKICAgICAgICB9LAoKICAgICAgICBhY3RpdmVJdGVtSW5Db2woY29sdW1uKSB7CiAgICAgICAgICAgIGNvbnN0IGNvbHVtbkNsYXNzID0gYCR7Y29sdW1ufXNgCiAgICAgICAgICAgIGlmICh0aGlzLmFwcGVuZFRvQm9keSAmJiB0aGlzLiRyZWZzICYmIHRoaXMuJHJlZnMuZHJvcGRvd24pIHsKICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRyZWZzLmRyb3Bkb3duLnF1ZXJ5U2VsZWN0b3JBbGwoYHVsLiR7Y29sdW1uQ2xhc3N9ID4gbGkuYWN0aXZlOm5vdCguaGludClgKQogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiB0aGlzLiRlbC5xdWVyeVNlbGVjdG9yQWxsKGB1bC4ke2NvbHVtbkNsYXNzfSA+IGxpLmFjdGl2ZTpub3QoLmhpbnQpYCkKICAgICAgICB9LAoKICAgICAgICBnZXRDbG9zZXN0U2libGluZyhjb2x1bW4sIGRhdGFLZXksIGdldFByZXZpb3VzID0gZmFsc2UpIHsKICAgICAgICAgICAgY29uc3Qgc2libGluZ3NJbkNvbCA9IHRoaXMudmFsaWRJdGVtc0luQ29sKGNvbHVtbikKICAgICAgICAgICAgY29uc3Qgc2VsZkluZGV4ID0gQXJyYXkucHJvdG90eXBlLmZpbmRJbmRleC5jYWxsKHNpYmxpbmdzSW5Db2wsIChzYmwpID0+IHsKICAgICAgICAgICAgICAgIHJldHVybiBzYmwuZ2V0QXR0cmlidXRlKCdkYXRhLWtleScpID09PSBkYXRhS2V5CiAgICAgICAgICAgIH0pCgogICAgICAgICAgICAvLyBBbHJlYWR5IHRoZSBmaXJzdCBpdGVtCiAgICAgICAgICAgIGlmIChnZXRQcmV2aW91cyAmJiBzZWxmSW5kZXggPT09IDApIHsKICAgICAgICAgICAgICAgIHJldHVybiBzaWJsaW5nc0luQ29sW3NpYmxpbmdzSW5Db2wubGVuZ3RoIC0gMV0KICAgICAgICAgICAgfQogICAgICAgICAgICAvLyBBbHJlYWR5IHRoZSBsYXN0IGl0ZW0KICAgICAgICAgICAgaWYgKCFnZXRQcmV2aW91cyAmJiBzZWxmSW5kZXggPT09IHNpYmxpbmdzSW5Db2wubGVuZ3RoIC0gMSkgewogICAgICAgICAgICAgICAgcmV0dXJuIHNpYmxpbmdzSW5Db2xbMF0KICAgICAgICAgICAgfQogICAgICAgICAgICAvLyBTZWxlY3RlZCB2YWx1ZSBub3QgaW4gdGhlIHZhbGlkIHZhbHVlcyBsaXN0CiAgICAgICAgICAgIGlmIChzZWxmSW5kZXggPCAwKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gc2libGluZ3NJbkNvbFswXQogICAgICAgICAgICB9CgogICAgICAgICAgICBpZiAoZ2V0UHJldmlvdXMpIHsKICAgICAgICAgICAgICAgIHJldHVybiBzaWJsaW5nc0luQ29sW3NlbGZJbmRleCAtIDFdCiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIHNpYmxpbmdzSW5Db2xbc2VsZkluZGV4ICsgMV0KICAgICAgICB9LAoKICAgICAgICBwcmV2SXRlbShjb2x1bW4sIGRhdGFLZXksIGlzTWFudWFsSW5wdXQgPSBmYWxzZSkgewogICAgICAgICAgICBjb25zdCB0YXJnZXRJdGVtID0gdGhpcy5nZXRDbG9zZXN0U2libGluZyhjb2x1bW4sIGRhdGFLZXksIHRydWUpCiAgICAgICAgICAgIGlmICh0YXJnZXRJdGVtKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gaXNNYW51YWxJbnB1dCA/IHRhcmdldEl0ZW0gOiB0YXJnZXRJdGVtLmZvY3VzKCkKICAgICAgICAgICAgfQogICAgICAgIH0sCgogICAgICAgIG5leHRJdGVtKGNvbHVtbiwgZGF0YUtleSwgaXNNYW51YWxJbnB1dCA9IGZhbHNlKSB7CiAgICAgICAgICAgIGNvbnN0IHRhcmdldEl0ZW0gPSB0aGlzLmdldENsb3Nlc3RTaWJsaW5nKGNvbHVtbiwgZGF0YUtleSwgZmFsc2UpCiAgICAgICAgICAgIGlmICh0YXJnZXRJdGVtKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gaXNNYW51YWxJbnB1dCA/IHRhcmdldEl0ZW0gOiB0YXJnZXRJdGVtLmZvY3VzKCkKICAgICAgICAgICAgfQogICAgICAgIH0sCgogICAgICAgIGdldFNpZGVDb2x1bW5OYW1lKGN1cnJlbnRDb2x1bW4sIHRvTGVmdCA9IGZhbHNlKSB7CiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRDb2x1bW5JbmRleCA9IHRoaXMuaW5Vc2UudHlwZXMuaW5kZXhPZihjdXJyZW50Q29sdW1uKQogICAgICAgICAgICBpZiAodG9MZWZ0ICYmIGN1cnJlbnRDb2x1bW5JbmRleCA8PSAwKSB7CiAgICAgICAgICAgICAgICBpZiAodGhpcy5kZWJ1Z01vZGUpIHsKICAgICAgICAgICAgICAgICAgICB0aGlzLmRlYnVnTG9nKCdZb3VcJ3JlIGluIHRoZSBsZWZ0bW9zdCBsaXN0IGFscmVhZHknKQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgcmV0dXJuCiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXRvTGVmdCAmJiBjdXJyZW50Q29sdW1uSW5kZXggPT09ICh0aGlzLmluVXNlLnR5cGVzLmxlbmd0aCAtIDEpKSB7CiAgICAgICAgICAgICAgICBpZiAodGhpcy5kZWJ1Z01vZGUpIHsKICAgICAgICAgICAgICAgICAgICB0aGlzLmRlYnVnTG9nKCdZb3VcJ3JlIGluIHRoZSByaWdodG1vc3QgbGlzdCBhbHJlYWR5JykKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHJldHVybgogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiB0aGlzLmluVXNlLnR5cGVzW3RvTGVmdCA/IGN1cnJlbnRDb2x1bW5JbmRleCAtIDEgOiBjdXJyZW50Q29sdW1uSW5kZXggKyAxXQogICAgICAgIH0sCgogICAgICAgIGdldEZpcnN0SXRlbUluU2lkZUNvbHVtbihjdXJyZW50Q29sdW1uLCB0b0xlZnQgPSBmYWxzZSkgewogICAgICAgICAgICBjb25zdCB0YXJnZXRDb2x1bW4gPSB0aGlzLmdldFNpZGVDb2x1bW5OYW1lKGN1cnJlbnRDb2x1bW4sIHRvTGVmdCkKICAgICAgICAgICAgaWYgKCF0YXJnZXRDb2x1bW4pIHsgcmV0dXJuIH0KICAgICAgICAgICAgY29uc3QgbGlzdEl0ZW1zID0gdGhpcy52YWxpZEl0ZW1zSW5Db2wodGFyZ2V0Q29sdW1uKQogICAgICAgICAgICBpZiAobGlzdEl0ZW1zICYmIGxpc3RJdGVtc1swXSkgewogICAgICAgICAgICAgICAgcmV0dXJuIGxpc3RJdGVtc1swXQogICAgICAgICAgICB9CiAgICAgICAgfSwKCiAgICAgICAgZ2V0QWN0aXZlSXRlbUluU2lkZUNvbHVtbihjdXJyZW50Q29sdW1uLCB0b0xlZnQgPSBmYWxzZSkgewogICAgICAgICAgICBjb25zdCB0YXJnZXRDb2x1bW4gPSB0aGlzLmdldFNpZGVDb2x1bW5OYW1lKGN1cnJlbnRDb2x1bW4sIHRvTGVmdCkKICAgICAgICAgICAgaWYgKCF0YXJnZXRDb2x1bW4pIHsgcmV0dXJuIH0KICAgICAgICAgICAgY29uc3QgYWN0aXZlSXRlbXMgPSB0aGlzLmFjdGl2ZUl0ZW1JbkNvbCh0YXJnZXRDb2x1bW4pCiAgICAgICAgICAgIGlmIChhY3RpdmVJdGVtcyAmJiBhY3RpdmVJdGVtc1swXSkgewogICAgICAgICAgICAgICAgcmV0dXJuIGFjdGl2ZUl0ZW1zWzBdCiAgICAgICAgICAgIH0KICAgICAgICB9LAoKICAgICAgICB0b0xlZnRDb2x1bW4oY3VycmVudENvbHVtbikgewogICAgICAgICAgICBjb25zdCB0YXJnZXRJdGVtID0gdGhpcy5nZXRBY3RpdmVJdGVtSW5TaWRlQ29sdW1uKGN1cnJlbnRDb2x1bW4sIHRydWUpIHx8IHRoaXMuZ2V0Rmlyc3RJdGVtSW5TaWRlQ29sdW1uKGN1cnJlbnRDb2x1bW4sIHRydWUpCiAgICAgICAgICAgIGlmICh0YXJnZXRJdGVtKSB7CiAgICAgICAgICAgICAgICB0YXJnZXRJdGVtLmZvY3VzKCkKICAgICAgICAgICAgfQogICAgICAgIH0sCgogICAgICAgIHRvUmlnaHRDb2x1bW4oY3VycmVudENvbHVtbikgewogICAgICAgICAgICBjb25zdCB0YXJnZXRJdGVtID0gdGhpcy5nZXRBY3RpdmVJdGVtSW5TaWRlQ29sdW1uKGN1cnJlbnRDb2x1bW4sIGZhbHNlKSB8fCB0aGlzLmdldEZpcnN0SXRlbUluU2lkZUNvbHVtbihjdXJyZW50Q29sdW1uLCBmYWxzZSkKICAgICAgICAgICAgaWYgKHRhcmdldEl0ZW0pIHsKICAgICAgICAgICAgICAgIHRhcmdldEl0ZW0uZm9jdXMoKQogICAgICAgICAgICB9CiAgICAgICAgfSwKCiAgICAgICAgLy8KICAgICAgICAvLyBNYW51YWwgSW5wdXQKICAgICAgICAvLwoKICAgICAgICBvbk1vdXNlRG93bigpIHsKICAgICAgICAgICAgaWYgKCF0aGlzLm1hbnVhbElucHV0KSB7IHJldHVybiB9CiAgICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5zZWxlY3Rpb25UaW1lcikKICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25UaW1lciA9IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHsKICAgICAgICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5zZWxlY3Rpb25UaW1lcikKICAgICAgICAgICAgICAgIGlmICh0aGlzLiRyZWZzICYmIHRoaXMuJHJlZnMuaW5wdXQpIHsKICAgICAgICAgICAgICAgICAgICBjb25zdCBuZWFyZXN0U2xvdCA9IHRoaXMuZ2V0TmVhcmVzdENodW5rQnlQb3ModGhpcy4kcmVmcy5pbnB1dC5zZWxlY3Rpb25TdGFydCB8fCAwKQogICAgICAgICAgICAgICAgICAgIHRoaXMuZGVib3VuY2VTZXRJbnB1dFNlbGVjdGlvbihuZWFyZXN0U2xvdCkKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSwgNTApCiAgICAgICAgfSwKCiAgICAgICAga2V5RG93bkhhbmRsZXIoZXZ0KSB7CiAgICAgICAgICAgIGlmIChldnQuaXNDb21wb3NpbmcgfHwgZXZ0LmtleUNvZGUgPT09IDIyOSkgewogICAgICAgICAgICAgICAgLy8gU2tpcCBJTUUgaW5wdXRzCiAgICAgICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKQogICAgICAgICAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpCiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2UKICAgICAgICAgICAgfQogICAgICAgICAgICAvLyBOdW1iZXJzCiAgICAgICAgICAgIGlmICgoZXZ0LmtleUNvZGUgPj0gNDggJiYgZXZ0LmtleUNvZGUgPD0gNTcpIHx8IChldnQua2V5Q29kZSA+PSA5NiAmJiBldnQua2V5Q29kZSA8PSAxMDUpKSB7CiAgICAgICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKQogICAgICAgICAgICAgICAgdGhpcy5rZXlib2FyZElucHV0KGV2dC5rZXkpCiAgICAgICAgICAgICAgICAvLyBBfFB8TQogICAgICAgICAgICB9IGVsc2UgaWYgKFs2NSwgODAsIDc3XS5pbmNsdWRlcyhldnQua2V5Q29kZSkpIHsKICAgICAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpCiAgICAgICAgICAgICAgICB0aGlzLmtleWJvYXJkSW5wdXQoZXZ0LmtleSwgdHJ1ZSkKICAgICAgICAgICAgICAgIC8vIEFycm93IGtleXMKICAgICAgICAgICAgfSBlbHNlIGlmIChldnQua2V5Q29kZSA+PSAzNyAmJiBldnQua2V5Q29kZSA8PSA0MCkgewogICAgICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCkKICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJLYklucHV0TG9nKCkKICAgICAgICAgICAgICAgIHRoaXMuYXJyb3dIYW5kbGVyKGV2dCkKICAgICAgICAgICAgICAgIC8vIERlbGV0ZXxCYWNrc3BhY2UKICAgICAgICAgICAgfSBlbHNlIGlmIChldnQua2V5Q29kZSA9PT0gOCB8fCBldnQua2V5Q29kZSA9PT0gNDYpIHsKICAgICAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpCiAgICAgICAgICAgICAgICB0aGlzLmNsZWFyS2JJbnB1dExvZygpCiAgICAgICAgICAgICAgICB0aGlzLmNsZWFyVGltZSgpCiAgICAgICAgICAgICAgICAvLyBUYWIKICAgICAgICAgICAgfSBlbHNlIGlmIChldnQua2V5Q29kZSA9PT0gOSkgewogICAgICAgICAgICAgICAgdGhpcy5jbGVhcktiSW5wdXRMb2coKQogICAgICAgICAgICAgICAgdGhpcy50YWJIYW5kbGVyKGV2dCkKICAgICAgICAgICAgICAgIC8vIENvbG9ufFNwYWNlCiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXZ0LmtleUNvZGUgPT09IDE4NiB8fCBldnQua2V5Q29kZSA9PT0gMzIpIHsKICAgICAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpCiAgICAgICAgICAgICAgICB0aGlzLmNsZWFyS2JJbnB1dExvZygpCiAgICAgICAgICAgICAgICB0aGlzLnRvTmV4dFNsb3QoKQogICAgICAgICAgICAgICAgLy8gUHJldmVudCBhbnkgTm9uLUVTQyBhbmQgbm9uLXBhc3RpbmcgaW5wdXRzCiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXZ0LmtleUNvZGUgIT09IDI3ICYmICEoZXZ0Lm1ldGFLZXkgfHwgZXZ0LmN0cmxLZXkpKSB7CiAgICAgICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKQogICAgICAgICAgICB9CiAgICAgICAgfSwKCiAgICAgICAgb25Db21wb3N0aW9uU3RhcnQoZXZ0KSB7CiAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpCiAgICAgICAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKQogICAgICAgICAgICB0aGlzLmJha0N1cnJlbnRQb3MgPSB0aGlzLmdldEN1cnJlbnRUb2tlbkNodW5rKCkKICAgICAgICAgICAgcmV0dXJuIGZhbHNlCiAgICAgICAgfSwKCiAgICAgICAgb25Db21wb3N0aW9uRW5kKGV2dCkgewogICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKQogICAgICAgICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCkKCiAgICAgICAgICAgIGNvbnN0IGNwc0RhdGEgPSBldnQuZGF0YQogICAgICAgICAgICBsZXQgaW5wdXRJc0N1c3RvbUFwbVRleHQgPSBmYWxzZQogICAgICAgICAgICBpZiAodGhpcy5oYXMuY3VzdG9tQXBtVGV4dCkgewogICAgICAgICAgICAgICAgaW5wdXRJc0N1c3RvbUFwbVRleHQgPSB0aGlzLmlzQ3VzdG9tQXBtVGV4dChjcHNEYXRhKQogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChpbnB1dElzQ3VzdG9tQXBtVGV4dCkgewogICAgICAgICAgICAgICAgdGhpcy5zZXRTYW5pdGl6ZWRWYWx1ZVRvU2VjdGlvbignYXBtJywgaW5wdXRJc0N1c3RvbUFwbVRleHQpCiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIHRoaXMuJHJlZnMuaW5wdXQudmFsdWUgPSB0aGlzLmhhcy5jdXN0b21BcG1UZXh0ID8gdGhpcy5jdXN0b21EaXNwbGF5VGltZSA6IHRoaXMuZGlzcGxheVRpbWUKCiAgICAgICAgICAgIHRoaXMuJG5leHRUaWNrKCgpID0+IHsKICAgICAgICAgICAgICAgIGlmICh0aGlzLmJha0N1cnJlbnRQb3MpIHsKICAgICAgICAgICAgICAgICAgICBjb25zdCBiYWtQb3MgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHRoaXMuYmFrQ3VycmVudFBvcykpCiAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0SXNDdXN0b21BcG1UZXh0KSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGJha1Bvcy5lbmQgPSAoYmFrUG9zLnN0YXJ0ICsgY3BzRGF0YS5sZW5ndGgpCiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIHRoaXMuZGVib3VuY2VTZXRJbnB1dFNlbGVjdGlvbihiYWtQb3MpCiAgICAgICAgICAgICAgICAgICAgdGhpcy5iYWtDdXJyZW50UG9zID0gbnVsbAogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9KQogICAgICAgICAgICByZXR1cm4gZmFsc2UKICAgICAgICB9LAoKICAgICAgICBwYXN0ZUhhbmRsZXIoZXZ0KSB7CiAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpCiAgICAgICAgICAgIGxldCBwYXN0aW5nVGV4dCA9IChldnQuY2xpcGJvYXJkRGF0YSB8fCB3aW5kb3cuY2xpcGJvYXJkRGF0YSkuZ2V0RGF0YSgndGV4dCcpCiAgICAgICAgICAgIGlmICh0aGlzLmRlYnVnTW9kZSkgewogICAgICAgICAgICAgICAgdGhpcy5kZWJ1Z0xvZyhgUGFzdGluZyB2YWx1ZSAiJHtwYXN0aW5nVGV4dH0iIGZyb20gY2xpcGJvYXJkYCkKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAoIXBhc3RpbmdUZXh0IHx8ICFwYXN0aW5nVGV4dC5sZW5ndGgpIHsgcmV0dXJuIH0KCiAgICAgICAgICAgIC8vIFJlcGxhY2UgY3VzdG9tIEFNL1BNIHRleHQgKGlmIGFueSkKICAgICAgICAgICAgaWYgKHRoaXMuaGFzLmN1c3RvbUFwbVRleHQpIHsKICAgICAgICAgICAgICAgIHBhc3RpbmdUZXh0ID0gdGhpcy5yZXBsYWNlQ3VzdG9tQXBtVGV4dChwYXN0aW5nVGV4dCkKICAgICAgICAgICAgfQoKICAgICAgICAgICAgaWYgKHRoaXMuaW5wdXRJc0VtcHR5KSB7CiAgICAgICAgICAgICAgICB0aGlzLnJlYWRTdHJpbmdWYWx1ZXMocGFzdGluZ1RleHQpCiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICB0aGlzLmtiSW5wdXRMb2cgPSBwYXN0aW5nVGV4dC5zdWJzdHIoLTIsIDIpCiAgICAgICAgICAgICAgICB0aGlzLnNldEtiSW5wdXQoKQogICAgICAgICAgICAgICAgdGhpcy5kZWJvdW5jZUNsZWFyS2JMb2coKQogICAgICAgICAgICB9CiAgICAgICAgfSwKCiAgICAgICAgYXJyb3dIYW5kbGVyKGV2dCkgewogICAgICAgICAgICBjb25zdCBkaXJlY3Rpb24gPSB7IDM3OiAnTCcsIDM4OiAnVScsIDM5OiAnUicsIDQwOiAnRCcgfVtldnQua2V5Q29kZV0KICAgICAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gJ1UnIHx8IGRpcmVjdGlvbiA9PT0gJ0QnKSB7CiAgICAgICAgICAgICAgICBpZiAodGhpcy5pbnB1dElzRW1wdHkpIHsKICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdEZpcnN0VmFsaWRWYWx1ZSgpCiAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRDaHVuayA9IHRoaXMuZ2V0Q3VycmVudFRva2VuQ2h1bmsoKQogICAgICAgICAgICAgICAgICAgIGlmICghY3VycmVudENodW5rKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0Rmlyc3RWYWxpZFZhbHVlKCkKICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuCiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIGNvbnN0IHRva2VuVHlwZSA9IGN1cnJlbnRDaHVuay50eXBlCiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRDbG9zZXN0VmFsaWRJdGVtSW5Db2wodG9rZW5UeXBlLCB0aGlzW3Rva2VuVHlwZV0sIGRpcmVjdGlvbikKICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdDaHVua1BvcyA9IHRoaXMuZ2V0Q3VycmVudFRva2VuQ2h1bmsoKQogICAgICAgICAgICAgICAgICAgIHRoaXMuZGVib3VuY2VTZXRJbnB1dFNlbGVjdGlvbihuZXdDaHVua1BvcykKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPT09ICdSJykgewogICAgICAgICAgICAgICAgdGhpcy50b0xhdGVyYWxUb2tlbihmYWxzZSkKICAgICAgICAgICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPT09ICdMJykgewogICAgICAgICAgICAgICAgdGhpcy50b0xhdGVyYWxUb2tlbih0cnVlKQogICAgICAgICAgICB9CiAgICAgICAgfSwKCiAgICAgICAgdGFiSGFuZGxlcihldnQpIHsKICAgICAgICAgICAgaWYgKCF0aGlzLmlucHV0SXNFbXB0eSAmJiB0aGlzLnRva2VuQ2h1bmtzUG9zICYmIHRoaXMudG9rZW5DaHVua3NQb3MubGVuZ3RoKSB7CiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50Q2h1bmsgPSB0aGlzLmdldEN1cnJlbnRUb2tlbkNodW5rKCkKICAgICAgICAgICAgICAgIGlmICghY3VycmVudENodW5rKSB7IHJldHVybiB9CiAgICAgICAgICAgICAgICBjb25zdCBmaXJzdENodW5rID0gdGhpcy50b2tlbkNodW5rc1Bvc1swXQogICAgICAgICAgICAgICAgY29uc3QgbGFzdENodW5rID0gdGhpcy50b2tlbkNodW5rc1Bvc1t0aGlzLnRva2VuQ2h1bmtzUG9zLmxlbmd0aCAtIDFdCiAgICAgICAgICAgICAgICBpZiAoKGV2dC5zaGlmdEtleSAmJiBjdXJyZW50Q2h1bmsudG9rZW4gIT09IGZpcnN0Q2h1bmsudG9rZW4pIHx8ICghZXZ0LnNoaWZ0S2V5ICYmIGN1cnJlbnRDaHVuay50b2tlbiAhPT0gbGFzdENodW5rLnRva2VuKSkgewogICAgICAgICAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpCiAgICAgICAgICAgICAgICAgICAgdGhpcy50b0xhdGVyYWxUb2tlbihldnQuc2hpZnRLZXkpCiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5hcHBlbmRUb0JvZHkgJiYgdGhpcy5hZHZhbmNlZEtleWJvYXJkKSB7CiAgICAgICAgICAgICAgICBpZiAoZXZ0LnNoaWZ0S2V5KSB7IHJldHVybiB9CiAgICAgICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKQogICAgICAgICAgICAgICAgaWYgKHRoaXMuaW5wdXRJc0VtcHR5KSB7CiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmlyc3RDb2x1bW4gPSB0aGlzLmluVXNlLnR5cGVzWzBdCiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0VmFsdWUgPSB0aGlzLnZhbGlkSXRlbXNJbkNvbChmaXJzdENvbHVtbilbMF0KICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0VmFsdWUpIHsKICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0VmFsdWUuZm9jdXMoKQogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgIH0sCgogICAgICAgIGtleWJvYXJkSW5wdXQobmV3Q2hhciwgaXNBcG0gPSBmYWxzZSkgewogICAgICAgICAgICBjb25zdCBjdXJyZW50Q2h1bmsgPSB0aGlzLmdldEN1cnJlbnRUb2tlbkNodW5rKCkKICAgICAgICAgICAgaWYgKCFjdXJyZW50Q2h1bmsgfHwgKGN1cnJlbnRDaHVuay50eXBlICE9PSAnYXBtJyAmJiBpc0FwbSkgfHwgKGN1cnJlbnRDaHVuay50eXBlID09PSAnYXBtJyAmJiAhaXNBcG0pKSB7IHJldHVybiB9CiAgICAgICAgICAgIHRoaXMua2JJbnB1dExvZyA9IGAke3RoaXMua2JJbnB1dExvZy5zdWJzdHIoLTEpfSR7bmV3Q2hhcn1gCiAgICAgICAgICAgIHRoaXMuc2V0S2JJbnB1dCgpCiAgICAgICAgICAgIHRoaXMuZGVib3VuY2VDbGVhcktiTG9nKCkKICAgICAgICB9LAoKICAgICAgICBjbGVhcktiSW5wdXRMb2coKSB7CiAgICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5rYklucHV0VGltZXIpCiAgICAgICAgICAgIHRoaXMua2JJbnB1dExvZyA9ICcnCiAgICAgICAgfSwKCiAgICAgICAgZGVib3VuY2VDbGVhcktiTG9nKCkgewogICAgICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMua2JJbnB1dFRpbWVyKQogICAgICAgICAgICB0aGlzLmtiSW5wdXRUaW1lciA9IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHsKICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJLYklucHV0TG9nKCkKICAgICAgICAgICAgfSwgdGhpcy5vcHRzLm1hbnVhbElucHV0VGltZW91dCkKICAgICAgICB9LAoKICAgICAgICBzZXRLYklucHV0KHZhbHVlKSB7CiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgfHwgdGhpcy5rYklucHV0TG9nCiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRDaHVuayA9IHRoaXMuZ2V0Q3VycmVudFRva2VuQ2h1bmsoKQogICAgICAgICAgICBpZiAoIWN1cnJlbnRDaHVuayB8fCAhdmFsdWUgfHwgIXZhbHVlLmxlbmd0aCkgeyByZXR1cm4gfQogICAgICAgICAgICBjb25zdCBjaHVua1R5cGUgPSBjdXJyZW50Q2h1bmsudHlwZQogICAgICAgICAgICBjb25zdCBjaHVua1Rva2VuID0gY3VycmVudENodW5rLnRva2VuCgogICAgICAgICAgICBsZXQgdmFsaWRWYWx1ZQogICAgICAgICAgICBpZiAoY2h1bmtUeXBlID09PSAnYXBtJykgewogICAgICAgICAgICAgICAgaWYgKHRoaXMubG93ZXJDYXNlZEFwbSh2YWx1ZSkuaW5jbHVkZXMoJ2EnKSkgewogICAgICAgICAgICAgICAgICAgIHZhbGlkVmFsdWUgPSAnYW0nCiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMubG93ZXJDYXNlZEFwbSh2YWx1ZSkuaW5jbHVkZXMoJ3AnKSkgewogICAgICAgICAgICAgICAgICAgIHZhbGlkVmFsdWUgPSAncG0nCiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZiAodmFsaWRWYWx1ZSkgewogICAgICAgICAgICAgICAgICAgIHZhbGlkVmFsdWUgPSBjaHVua1Rva2VuID09PSAnQScgPyB2YWxpZFZhbHVlLnRvVXBwZXJDYXNlKCkgOiB2YWxpZFZhbHVlCiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc1ZhbGlkVmFsdWUoY2h1bmtUb2tlbiwgdmFsdWUpKSB7CiAgICAgICAgICAgICAgICAgICAgdmFsaWRWYWx1ZSA9IHZhbHVlCiAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgIGNvbnN0IGxhc3RJbnB1dFZhbHVlID0gdGhpcy5mb3JtYXRWYWx1ZShjaHVua1Rva2VuLCB2YWx1ZS5zdWJzdHIoLTEpKQogICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzVmFsaWRWYWx1ZShjaHVua1Rva2VuLCBsYXN0SW5wdXRWYWx1ZSkpIHsKICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRWYWx1ZSA9IGxhc3RJbnB1dFZhbHVlCiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CgogICAgICAgICAgICBpZiAodmFsaWRWYWx1ZSkgewogICAgICAgICAgICAgICAgdGhpcy5zZXRTYW5pdGl6ZWRWYWx1ZVRvU2VjdGlvbihjaHVua1R5cGUsIHZhbGlkVmFsdWUpCiAgICAgICAgICAgICAgICBjb25zdCBuZXdDaHVua1BvcyA9IHRoaXMuZ2V0Q3VycmVudFRva2VuQ2h1bmsoKQogICAgICAgICAgICAgICAgdGhpcy5kZWJvdW5jZVNldElucHV0U2VsZWN0aW9uKG5ld0NodW5rUG9zKQogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmICh0aGlzLmRlYnVnTW9kZSkgewogICAgICAgICAgICAgICAgaWYgKHZhbGlkVmFsdWUpIHsKICAgICAgICAgICAgICAgICAgICB0aGlzLmRlYnVnTG9nKGBTdWNjZXNzZnVsbHkgc2V0IHZhbHVlICIke3ZhbGlkVmFsdWV9IiBmcm9tIGxhdGVzdCBpbnB1dCAiJHt2YWx1ZX0iIGZvciB0aGUgIiR7Y2h1bmtUeXBlfSIgc2xvdGApCiAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgIHRoaXMuZGVidWdMb2coYFZhbHVlICIke3ZhbHVlfSIgaXMgaW52YWxpZCBpbiB0aGUgIiR7Y2h1bmtUeXBlfSIgc2xvdGApCiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICB9LAoKICAgICAgICAvLyBGb3JtIEF1dG9maWxsCiAgICAgICAgb25DaGFuZ2UoKSB7CiAgICAgICAgICAgIGlmICghdGhpcy5tYW51YWxJbnB1dCB8fCAhdGhpcy4kcmVmcyB8fCAhdGhpcy4kcmVmcy5pbnB1dCkgeyByZXR1cm4gfQogICAgICAgICAgICBjb25zdCBhdXRvRmlsbFZhbHVlID0gdGhpcy4kcmVmcy5pbnB1dC52YWx1ZSB8fCAnJwogICAgICAgICAgICBpZiAoYXV0b0ZpbGxWYWx1ZSAmJiBhdXRvRmlsbFZhbHVlLmxlbmd0aCkgewogICAgICAgICAgICAgICAgdGhpcy5yZWFkU3RyaW5nVmFsdWVzKGF1dG9GaWxsVmFsdWUpCiAgICAgICAgICAgIH0KICAgICAgICB9LAoKICAgICAgICBnZXROZWFyZXN0Q2h1bmtCeVBvcyhzdGFydFBvcykgewogICAgICAgICAgICBpZiAoIXRoaXMudG9rZW5DaHVua3NQb3MgfHwgIXRoaXMudG9rZW5DaHVua3NQb3MubGVuZ3RoKSB7IHJldHVybiB9CiAgICAgICAgICAgIGxldCBuZWFyZXN0CiAgICAgICAgICAgIGxldCBuZWFyZXN0RGVsdGEgPSAtMQogICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudG9rZW5DaHVua3NQb3MubGVuZ3RoOyBpKyspIHsKICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0aGlzLnRva2VuQ2h1bmtzUG9zW2ldKSkKICAgICAgICAgICAgICAgIGlmIChjaHVuay5zdGFydCA9PT0gc3RhcnRQb3MpIHsKICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2h1bmsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGNvbnN0IGRlbHRhID0gTWF0aC5hYnMoY2h1bmsuc3RhcnQgLSBzdGFydFBvcykKICAgICAgICAgICAgICAgIGlmIChuZWFyZXN0RGVsdGEgPCAwKSB7CiAgICAgICAgICAgICAgICAgICAgbmVhcmVzdCA9IGNodW5rCiAgICAgICAgICAgICAgICAgICAgbmVhcmVzdERlbHRhID0gZGVsdGEKICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgaWYgKG5lYXJlc3REZWx0YSA8PSBkZWx0YSkgewogICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmVhcmVzdAogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBuZWFyZXN0RGVsdGEgPSBkZWx0YQogICAgICAgICAgICAgICAgICAgIG5lYXJlc3QgPSBjaHVuawogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiBuZWFyZXN0CiAgICAgICAgfSwKCiAgICAgICAgc2VsZWN0Rmlyc3RWYWxpZFZhbHVlKCkgewogICAgICAgICAgICBpZiAoIXRoaXMudG9rZW5DaHVua3NQb3MgfHwgIXRoaXMudG9rZW5DaHVua3NQb3MubGVuZ3RoKSB7IHJldHVybiB9CiAgICAgICAgICAgIGNvbnN0IGZpcnN0U2xvdFR5cGUgPSB0aGlzLnRva2VuQ2h1bmtzUG9zWzBdLnR5cGUKICAgICAgICAgICAgaWYgKGZpcnN0U2xvdFR5cGUgPT09ICdob3VyJykgewogICAgICAgICAgICAgICAgdGhpcy5nZXRDbG9zZXN0SG91ckl0ZW0oKQogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgdGhpcy5nZXRDbG9zZXN0VmFsaWRJdGVtSW5Db2woZmlyc3RTbG90VHlwZSwgdGhpc1tmaXJzdFNsb3RUeXBlXSkKICAgICAgICAgICAgfQogICAgICAgICAgICB0aGlzLnNlbGVjdEZpcnN0U2xvdCgpCiAgICAgICAgfSwKCiAgICAgICAgZ2V0Q2xvc2VzdEhvdXJJdGVtKGN1cnJlbnRWYWx1ZSwgZGlyZWN0aW9uID0gJ1UnKSB7CiAgICAgICAgICAgIGlmICghdGhpcy52YWxpZEhvdXJzTGlzdCB8fCAhdGhpcy52YWxpZEhvdXJzTGlzdC5sZW5ndGgpIHsKICAgICAgICAgICAgICAgIGlmICh0aGlzLmRlYnVnTW9kZSkgewogICAgICAgICAgICAgICAgICAgIHRoaXMuZGVidWdMb2coYE5vIHZhbGlkIGhvdXIgdmFsdWVzIGZvdW5kLCBwbGVhc2UgY2hlY2sgeW91ciAiaG91ci1yYW5nZSIgY29uZmlnXG5ob3VyLXJhbmdlOiAke0pTT04uc3RyaW5naWZ5KHRoaXMuaG91clJhbmdlKX1gKQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgcmV0dXJuCiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKCFjdXJyZW50VmFsdWUpIHsKICAgICAgICAgICAgICAgIHRoaXMuc2V0TWFudWFsSG91cih0aGlzLnZhbGlkSG91cnNMaXN0WzBdKQogICAgICAgICAgICAgICAgcmV0dXJuCiAgICAgICAgICAgIH0KICAgICAgICAgICAgY29uc3QgY3VycmVudEluZGV4ID0gdGhpcy52YWxpZEhvdXJzTGlzdC5maW5kSW5kZXgoaXRlbSA9PiB7CiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuYmFzZU9uMTJIb3VycykgewogICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtID09PSBjdXJyZW50VmFsdWUKICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWVLZXkgPSBgJHtjdXJyZW50VmFsdWV9JHt0aGlzLmxvd2VyQ2FzZWRBcG0odGhpcy5hcG0pID09PSAncG0nID8gJ3AnIDogJ2EnfWAKICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlbSA9PT0gdmFsdWVLZXkKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSkKICAgICAgICAgICAgbGV0IG5leHRJbmRleAogICAgICAgICAgICBpZiAoY3VycmVudEluZGV4ID09PSAtMSkgewogICAgICAgICAgICAgICAgbmV4dEluZGV4ID0gMAogICAgICAgICAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gJ0QnKSB7CiAgICAgICAgICAgICAgICBuZXh0SW5kZXggPSBjdXJyZW50SW5kZXggPT09IDAgPyB0aGlzLnZhbGlkSG91cnNMaXN0Lmxlbmd0aCAtIDEgOiBjdXJyZW50SW5kZXggLSAxCiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICBuZXh0SW5kZXggPSAoY3VycmVudEluZGV4ICsgMSkgJSB0aGlzLnZhbGlkSG91cnNMaXN0Lmxlbmd0aAogICAgICAgICAgICB9CiAgICAgICAgICAgIGNvbnN0IG5leHRJdGVtID0gdGhpcy52YWxpZEhvdXJzTGlzdFtuZXh0SW5kZXhdCiAgICAgICAgICAgIHRoaXMuc2V0TWFudWFsSG91cihuZXh0SXRlbSkKICAgICAgICB9LAoKICAgICAgICBnZXRDbG9zZXN0VmFsaWRJdGVtSW5Db2woY29sdW1uLCBjdXJyZW50VmFsdWUsIGRpcmVjdGlvbiA9ICdVJykgewogICAgICAgICAgICBpZiAoY29sdW1uID09PSAnaG91cicpIHsKICAgICAgICAgICAgICAgIHRoaXMuZ2V0Q2xvc2VzdEhvdXJJdGVtKGN1cnJlbnRWYWx1ZSwgZGlyZWN0aW9uKQogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgY29uc3QgbmV4dEl0ZW0gPSBkaXJlY3Rpb24gPT09ICdEJyA/IHRoaXMucHJldkl0ZW0oY29sdW1uLCB0aGlzW2NvbHVtbl0sIHRydWUpIDogdGhpcy5uZXh0SXRlbShjb2x1bW4sIHRoaXNbY29sdW1uXSwgdHJ1ZSkKICAgICAgICAgICAgICAgIGlmIChuZXh0SXRlbSkgewogICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0KGNvbHVtbiwgbmV4dEl0ZW0uZ2V0QXR0cmlidXRlKCdkYXRhLWtleScpKQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgfSwKCiAgICAgICAgc2V0U2FuaXRpemVkVmFsdWVUb1NlY3Rpb24oc2VjdGlvbiwgaW5wdXRWYWx1ZSkgewogICAgICAgICAgICBpZiAoIXNlY3Rpb24gfHwgIXRoaXMuZ2V0VG9rZW5CeVR5cGUoc2VjdGlvbikpIHsgcmV0dXJuIH0KICAgICAgICAgICAgLy8gTk9URTogRGlzYWJsZWQgdmFsdWVzIGFyZSBhbGxvd2VkIGhlcmUsIGZvbGxvd2VkIGJ5IGFuICdlcnJvcicgZXZlbnQsIHRob3VnaAogICAgICAgICAgICBjb25zdCBzYW5pdGl6ZWRWYWx1ZSA9IHRoaXMuc2FuaXRpemVkVmFsdWUodGhpcy5nZXRUb2tlbkJ5VHlwZShzZWN0aW9uKSwgaW5wdXRWYWx1ZSkKICAgICAgICAgICAgdGhpc1tzZWN0aW9uXSA9IHNhbml0aXplZFZhbHVlCiAgICAgICAgfSwKCiAgICAgICAgc2V0TWFudWFsSG91cihuZXh0SXRlbSkgewogICAgICAgICAgICBpZiAodGhpcy5pczEyaFJhbmdlKG5leHRJdGVtKSkgewogICAgICAgICAgICAgICAgY29uc3QgaG91clQgPSB0aGlzLm1hdGNoMTJoUmFuZ2UobmV4dEl0ZW0pCiAgICAgICAgICAgICAgICBjb25zdCBhcG1WYWx1ZSA9IGhvdXJUWzJdID09PSAnYScgPyAnQU0nIDogJ1BNJwogICAgICAgICAgICAgICAgdGhpcy5zZXRTYW5pdGl6ZWRWYWx1ZVRvU2VjdGlvbignYXBtJywgdGhpcy5hcG1UeXBlID09PSAnYScgPyBhcG1WYWx1ZS50b0xvd2VyQ2FzZSgpIDogYXBtVmFsdWUpCiAgICAgICAgICAgICAgICB0aGlzLnNldFNhbml0aXplZFZhbHVlVG9TZWN0aW9uKCdob3VyJywgaG91clRbMV0pCiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICB0aGlzLnNldFNhbml0aXplZFZhbHVlVG9TZWN0aW9uKCdob3VyJywgbmV4dEl0ZW0pCiAgICAgICAgICAgIH0KICAgICAgICB9LAoKICAgICAgICBkZWJvdW5jZVNldElucHV0U2VsZWN0aW9uKHsgc3RhcnQgPSAwLCBlbmQgPSAwIH0pIHsKICAgICAgICAgICAgdGhpcy4kbmV4dFRpY2soKCkgPT4gewogICAgICAgICAgICAgICAgdGhpcy5zZXRJbnB1dFNlbGVjdGlvblJhbmdlKHN0YXJ0LCBlbmQpCiAgICAgICAgICAgIH0pCiAgICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5zZWxlY3Rpb25UaW1lcikKICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25UaW1lciA9IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHsKICAgICAgICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5zZWxlY3Rpb25UaW1lcikKICAgICAgICAgICAgICAgIC8vIERvdWJsZS1jaGVjayBzZWxlY3Rpb24gZm9yIDEyaHIgZm9ybWF0CiAgICAgICAgICAgICAgICBpZiAodGhpcy4kcmVmcy5pbnB1dCAmJiAodGhpcy4kcmVmcy5pbnB1dC5zZWxlY3Rpb25TdGFydCAhPT0gc3RhcnQgfHwgdGhpcy4kcmVmcy5pbnB1dC5zZWxlY3Rpb25FbmQgIT09IGVuZCkpIHsKICAgICAgICAgICAgICAgICAgICB0aGlzLnNldElucHV0U2VsZWN0aW9uUmFuZ2Uoc3RhcnQsIGVuZCkKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSwgMzApCiAgICAgICAgfSwKCiAgICAgICAgc2V0SW5wdXRTZWxlY3Rpb25SYW5nZShzdGFydCwgZW5kKSB7CiAgICAgICAgICAgIGlmICh0aGlzLiRyZWZzICYmIHRoaXMuJHJlZnMuaW5wdXQpIHsKICAgICAgICAgICAgICAgIHRoaXMuJHJlZnMuaW5wdXQuc2V0U2VsZWN0aW9uUmFuZ2Uoc3RhcnQsIGVuZCkKICAgICAgICAgICAgfQogICAgICAgIH0sCgogICAgICAgIGdldEN1cnJlbnRUb2tlbkNodW5rKCkgewogICAgICAgICAgICByZXR1cm4gdGhpcy5nZXROZWFyZXN0Q2h1bmtCeVBvcygodGhpcy4kcmVmcy5pbnB1dCAmJiB0aGlzLiRyZWZzLmlucHV0LnNlbGVjdGlvblN0YXJ0KSB8fCAwKQogICAgICAgIH0sCgogICAgICAgIHNlbGVjdEZpcnN0U2xvdCgpIHsKICAgICAgICAgICAgY29uc3QgZmlyc3RDaHVua1BvcyA9IHRoaXMuZ2V0TmVhcmVzdENodW5rQnlQb3MoMCkKICAgICAgICAgICAgdGhpcy5kZWJvdW5jZVNldElucHV0U2VsZWN0aW9uKGZpcnN0Q2h1bmtQb3MpCiAgICAgICAgfSwKCiAgICAgICAgdG9OZXh0U2xvdCgpIHsKICAgICAgICAgICAgaWYgKCF0aGlzLmlucHV0SXNFbXB0eSAmJiB0aGlzLnRva2VuQ2h1bmtzUG9zICYmIHRoaXMudG9rZW5DaHVua3NQb3MubGVuZ3RoKSB7CiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50Q2h1bmsgPSB0aGlzLmdldEN1cnJlbnRUb2tlbkNodW5rKCkKICAgICAgICAgICAgICAgIGlmICghY3VycmVudENodW5rKSB7IHJldHVybiB9CiAgICAgICAgICAgICAgICBjb25zdCBsYXN0Q2h1bmsgPSB0aGlzLnRva2VuQ2h1bmtzUG9zW3RoaXMudG9rZW5DaHVua3NQb3MubGVuZ3RoIC0gMV0KICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Q2h1bmsudG9rZW4gIT09IGxhc3RDaHVuay50b2tlbikgewogICAgICAgICAgICAgICAgICAgIHRoaXMudG9MYXRlcmFsVG9rZW4oZmFsc2UpCiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICB9LAoKICAgICAgICB0b0xhdGVyYWxUb2tlbih0b0xlZnQpIHsKICAgICAgICAgICAgY29uc3QgY3VycmVudENodW5rID0gdGhpcy5nZXRDdXJyZW50VG9rZW5DaHVuaygpCiAgICAgICAgICAgIGlmICghY3VycmVudENodW5rKSB7CiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdEZpcnN0VmFsaWRWYWx1ZSgpCiAgICAgICAgICAgICAgICByZXR1cm4KICAgICAgICAgICAgfQogICAgICAgICAgICBjb25zdCBjdXJyZW50Q2h1bmtJbmRleCA9IHRoaXMudG9rZW5DaHVua3NQb3MuZmluZEluZGV4KGNoayA9PiBjaGsudG9rZW4gPT09IGN1cnJlbnRDaHVuay50b2tlbikKICAgICAgICAgICAgaWYgKCghdG9MZWZ0ICYmIGN1cnJlbnRDaHVua0luZGV4ID49IHRoaXMudG9rZW5DaHVua3NQb3MubGVuZ3RoIC0gMSkgfHwgKHRvTGVmdCAmJiBjdXJyZW50Q2h1bmtJbmRleCA9PT0gMCkpIHsKICAgICAgICAgICAgICAgIGlmICh0aGlzLmRlYnVnTW9kZSkgewogICAgICAgICAgICAgICAgICAgIGlmICh0b0xlZnQpIHsKICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWJ1Z0xvZygnWW91XCdyZSBpbiB0aGUgbGVmdG1vc3Qgc2xvdCBhbHJlYWR5JykKICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRlYnVnTG9nKCdZb3VcJ3JlIGluIHRoZSByaWdodG1vc3Qgc2xvdCBhbHJlYWR5JykKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICByZXR1cm4KICAgICAgICAgICAgfQogICAgICAgICAgICBjb25zdCB0YXJnZXRTbG90UG9zID0gdG9MZWZ0ID8gdGhpcy50b2tlbkNodW5rc1Bvc1tjdXJyZW50Q2h1bmtJbmRleCAtIDFdIDogdGhpcy50b2tlbkNodW5rc1Bvc1tjdXJyZW50Q2h1bmtJbmRleCArIDFdCiAgICAgICAgICAgIHRoaXMuZGVib3VuY2VTZXRJbnB1dFNlbGVjdGlvbih0YXJnZXRTbG90UG9zKQogICAgICAgIH0sCgogICAgICAgIGlzQ3VzdG9tQXBtVGV4dChpbnB1dERhdGEpIHsKICAgICAgICAgICAgaWYgKCFpbnB1dERhdGEgfHwgIWlucHV0RGF0YS5sZW5ndGgpIHsgcmV0dXJuIGZhbHNlIH0KICAgICAgICAgICAgaWYgKHRoaXMuYW1UZXh0ICYmIHRoaXMuYW1UZXh0ID09PSBpbnB1dERhdGEpIHsKICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFwbVR5cGUgPT09ICdBJyA/ICdBTScgOiAnYW0nCiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKHRoaXMucG1UZXh0ICYmIHRoaXMucG1UZXh0ID09PSBpbnB1dERhdGEpIHsKICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFwbVR5cGUgPT09ICdBJyA/ICdQTScgOiAncG0nCiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIGZhbHNlCiAgICAgICAgfSwKCiAgICAgICAgcmVwbGFjZUN1c3RvbUFwbVRleHQoaW5wdXRTdHJpbmcpIHsKICAgICAgICAgICAgaWYgKHRoaXMuYW1UZXh0ICYmIHRoaXMuYW1UZXh0Lmxlbmd0aCAmJiBpbnB1dFN0cmluZy5pbmNsdWRlcyh0aGlzLmFtVGV4dCkpIHsKICAgICAgICAgICAgICAgIHJldHVybiBpbnB1dFN0cmluZy5yZXBsYWNlKG5ldyBSZWdFeHAodGhpcy5hbVRleHQsICdnJyksIHRoaXMuYXBtVHlwZSA9PT0gJ0EnID8gJ0FNJyA6ICdhbScpCiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5wbVRleHQgJiYgdGhpcy5wbVRleHQubGVuZ3RoICYmIGlucHV0U3RyaW5nLmluY2x1ZGVzKHRoaXMucG1UZXh0KSkgewogICAgICAgICAgICAgICAgcmV0dXJuIGlucHV0U3RyaW5nLnJlcGxhY2UobmV3IFJlZ0V4cCh0aGlzLnBtVGV4dCwgJ2cnKSwgdGhpcy5hcG1UeXBlID09PSAnQScgPyAnUE0nIDogJ3BtJykKICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gaW5wdXRTdHJpbmcKICAgICAgICB9LAoKICAgICAgICBjaGVja0Ryb3BEaXJlY3Rpb24oKSB7CiAgICAgICAgICAgIGlmICghdGhpcy4kZWwpIHsgcmV0dXJuIH0KICAgICAgICAgICAgbGV0IGNvbnRhaW5lcgogICAgICAgICAgICBpZiAodGhpcy5jb250YWluZXJJZCAmJiB0aGlzLmNvbnRhaW5lcklkLmxlbmd0aCkgewogICAgICAgICAgICAgICAgY29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5jb250YWluZXJJZCkKICAgICAgICAgICAgICAgIGlmICghY29udGFpbmVyICYmIHRoaXMuZGVidWdNb2RlKSB7CiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWJ1Z0xvZyhgQ29udGFpbmVyIHdpdGggaWQgIiR7dGhpcy5jb250YWluZXJJZH0iIG5vdCBmb3VuZC4gRmFsbGJhY2sgdG8gZG9jdW1lbnQgYm9keS5gKQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICAgIGNvbnN0IGVsID0gdGhpcy4kZWwKICAgICAgICAgICAgbGV0IHNwYWNlRG93bgogICAgICAgICAgICBpZiAoY29udGFpbmVyICYmIGNvbnRhaW5lci5vZmZzZXRIZWlnaHQpIHsKICAgICAgICAgICAgICAgIC8vIFZhbGlkIGNvbnRhaW5lciBmb3VuZAogICAgICAgICAgICAgICAgc3BhY2VEb3duID0gKGNvbnRhaW5lci5vZmZzZXRUb3AgKyBjb250YWluZXIub2Zmc2V0SGVpZ2h0KSAtIChlbC5vZmZzZXRUb3AgKyBlbC5vZmZzZXRIZWlnaHQpCiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAvLyBGYWxsYmFjayB0byBkb2N1bWVudCBib2R5CiAgICAgICAgICAgICAgICBjb25zdCBkb2NIZWlnaHQgPSBNYXRoLm1heChkb2N1bWVudC5ib2R5LnNjcm9sbEhlaWdodCwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbEhlaWdodCwgZG9jdW1lbnQuYm9keS5vZmZzZXRIZWlnaHQsIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5vZmZzZXRIZWlnaHQsIGRvY3VtZW50LmJvZHkuY2xpZW50SGVpZ2h0LCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0KQogICAgICAgICAgICAgICAgc3BhY2VEb3duID0gZG9jSGVpZ2h0IC0gKGVsLm9mZnNldFRvcCArIGVsLm9mZnNldEhlaWdodCkKICAgICAgICAgICAgfQogICAgICAgICAgICB0aGlzLmZvcmNlRHJvcE9uVG9wID0gdGhpcy5vcHRzLmRyb3BPZmZzZXRIZWlnaHQgPiBzcGFjZURvd24KICAgICAgICB9LAoKICAgICAgICAvLwogICAgICAgIC8vIEhlbHBlcnMKICAgICAgICAvLwoKICAgICAgICBpczEyaFJhbmdlKHZhbHVlKSB7CiAgICAgICAgICAgIHJldHVybiAvXlxkezEsMn0oYXxwfEF8UCkkLy50ZXN0KHZhbHVlKQogICAgICAgIH0sCgogICAgICAgIG1hdGNoMTJoUmFuZ2UodmFsdWUpIHsKICAgICAgICAgICAgcmV0dXJuIHZhbHVlLm1hdGNoKC9eKFxkezEsMn0pKGF8cHxBfFApJC8pCiAgICAgICAgfSwKCiAgICAgICAgaXNOdW1iZXIodmFsdWUpIHsKICAgICAgICAgICAgcmV0dXJuICFpc05hTihwYXJzZUZsb2F0KHZhbHVlKSkgJiYgaXNGaW5pdGUodmFsdWUpCiAgICAgICAgfSwKCiAgICAgICAgaXNCYXNpY1R5cGUodHlwZSkgewogICAgICAgICAgICByZXR1cm4gQ09ORklHLkJBU0lDX1RZUEVTLmluY2x1ZGVzKHR5cGUpCiAgICAgICAgfSwKCiAgICAgICAgbG93ZXJDYXNlZEFwbShhcG1WYWx1ZSkgewogICAgICAgICAgICByZXR1cm4gKGFwbVZhbHVlIHx8ICcnKS50b0xvd2VyQ2FzZSgpCiAgICAgICAgfSwKCiAgICAgICAgZ2V0VG9rZW5SZWdleCh0b2tlbikgewogICAgICAgICAgICBzd2l0Y2ggKHRva2VuKSB7CiAgICAgICAgICAgICAgICBjYXNlICdISCc6CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICcoWzAxXVswLTldfDJbMC0zXXxIezJ9KScKICAgICAgICAgICAgICAgIGNhc2UgJ0gnOgogICAgICAgICAgICAgICAgICAgIHJldHVybiAnKFswLTldezF9fDFbMC05XXwyWzAtM118SHsxfSknCiAgICAgICAgICAgICAgICBjYXNlICdoaCc6CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICcoMFsxLTldfDFbMC0yXXxoezJ9KScKICAgICAgICAgICAgICAgIGNhc2UgJ2gnOgogICAgICAgICAgICAgICAgICAgIHJldHVybiAnKFsxLTldezF9fDFbMC0yXXxoezF9KScKICAgICAgICAgICAgICAgIGNhc2UgJ2trJzoKICAgICAgICAgICAgICAgICAgICByZXR1cm4gJygwWzEtOV18MVswLTldfDJbMC00XXxrezJ9KScKICAgICAgICAgICAgICAgIGNhc2UgJ2snOgogICAgICAgICAgICAgICAgICAgIHJldHVybiAnKFsxLTldezF9fDFbMC05XXwyWzAtNF18a3sxfSknCiAgICAgICAgICAgICAgICBjYXNlICdtbSc6CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICcoWzAtNV1bMC05XXxtezJ9KScKICAgICAgICAgICAgICAgIGNhc2UgJ3NzJzoKICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyhbMC01XVswLTldfHN7Mn0pJwogICAgICAgICAgICAgICAgY2FzZSAnbSc6CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICcoWzAtOV17MX18WzEtNV1bMC05XXxtezF9KScKICAgICAgICAgICAgICAgIGNhc2UgJ3MnOgogICAgICAgICAgICAgICAgICAgIHJldHVybiAnKFswLTldezF9fFsxLTVdWzAtOV18c3sxfSknCiAgICAgICAgICAgICAgICBjYXNlICdBJzoKICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyhBTXxQTXxBezF9KScKICAgICAgICAgICAgICAgIGNhc2UgJ2EnOgogICAgICAgICAgICAgICAgICAgIHJldHVybiAnKGFtfHBtfGF7MX0pJwogICAgICAgICAgICAgICAgZGVmYXVsdDoKICAgICAgICAgICAgICAgICAgICByZXR1cm4gJycKICAgICAgICAgICAgfQogICAgICAgIH0sCgogICAgICAgIGlzRW1wdHlWYWx1ZSh0YXJnZXRUb2tlbiwgdGVzdFZhbHVlKSB7CiAgICAgICAgICAgIHJldHVybiAoIXRlc3RWYWx1ZSB8fCAhdGVzdFZhbHVlLmxlbmd0aCkgfHwgKHRlc3RWYWx1ZSAmJiB0ZXN0VmFsdWUgPT09IHRhcmdldFRva2VuKQogICAgICAgIH0sCgogICAgICAgIGlzVmFsaWRWYWx1ZSh0YXJnZXRUb2tlbiwgdGVzdFZhbHVlKSB7CiAgICAgICAgICAgIGlmICghdGFyZ2V0VG9rZW4gfHwgdGhpcy5pc0VtcHR5VmFsdWUodGFyZ2V0VG9rZW4sIHRlc3RWYWx1ZSkpIHsgcmV0dXJuIGZhbHNlIH0KICAgICAgICAgICAgY29uc3QgdG9rZW5SZWdleFN0ciA9IHRoaXMuZ2V0VG9rZW5SZWdleCh0YXJnZXRUb2tlbikKICAgICAgICAgICAgaWYgKCF0b2tlblJlZ2V4U3RyIHx8ICF0b2tlblJlZ2V4U3RyLmxlbmd0aCkgeyByZXR1cm4gZmFsc2UgfQogICAgICAgICAgICByZXR1cm4gKG5ldyBSZWdFeHAoYF4ke3Rva2VuUmVnZXhTdHJ9JGApKS50ZXN0KHRlc3RWYWx1ZSkKICAgICAgICB9LAoKICAgICAgICBzYW5pdGl6ZWRWYWx1ZSh0YXJnZXRUb2tlbiwgaW5wdXRWYWx1ZSkgewogICAgICAgICAgICBpZiAodGhpcy5pc1ZhbGlkVmFsdWUodGFyZ2V0VG9rZW4sIGlucHV0VmFsdWUpKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gaW5wdXRWYWx1ZQogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiAnJwogICAgICAgIH0sCgogICAgICAgIGdldFRva2VuVHlwZSh0b2tlbikgewogICAgICAgICAgICByZXR1cm4gdGhpcy5pblVzZS50eXBlc1t0aGlzLmluVXNlLnRva2Vucy5pbmRleE9mKHRva2VuKV0gfHwgJycKICAgICAgICB9LAoKICAgICAgICBnZXRUb2tlbkJ5VHlwZSh0eXBlKSB7CiAgICAgICAgICAgIHJldHVybiB0aGlzW2Ake3R5cGV9VHlwZWBdIHx8ICcnCiAgICAgICAgfSwKCiAgICAgICAgaXNNaW51dGVPclNlY29uZCh0eXBlKSB7CiAgICAgICAgICAgIHJldHVybiBbJ21pbnV0ZScsICdzZWNvbmQnXS5pbmNsdWRlcyh0eXBlKQogICAgICAgIH0sCgogICAgICAgIGRlYnVnTG9nKGxvZ1RleHQpIHsKICAgICAgICAgICAgaWYgKCFsb2dUZXh0IHx8ICFsb2dUZXh0Lmxlbmd0aCkgeyByZXR1cm4gfQogICAgICAgICAgICBsZXQgaWRlbnRpZmllciA9ICcnCiAgICAgICAgICAgIGlmICh0aGlzLmlkKSB7CiAgICAgICAgICAgICAgICBpZGVudGlmaWVyICs9IGAjJHt0aGlzLmlkfWAKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAodGhpcy5uYW1lKSB7CiAgICAgICAgICAgICAgICBpZGVudGlmaWVyICs9IGBbbmFtZT0ke3RoaXMubmFtZX1dYAogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmICh0aGlzLmlucHV0Q2xhc3MpIHsKICAgICAgICAgICAgICAgIGxldCBpbnB1dENsYXNzZXMgPSBbXQogICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmlucHV0Q2xhc3MgPT09ICdzdHJpbmcnKSB7CiAgICAgICAgICAgICAgICAgICAgaW5wdXRDbGFzc2VzID0gdGhpcy5pbnB1dENsYXNzLnNwbGl0KC9ccy9nKQogICAgICAgICAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHRoaXMuaW5wdXRDbGFzcykpIHsKICAgICAgICAgICAgICAgICAgICBpbnB1dENsYXNzZXMgPSBbXS5jb25jYXQoW10sIHRoaXMuaW5wdXRDbGFzcykKICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMuaW5wdXRDbGFzcyA9PT0gJ29iamVjdCcpIHsKICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyh0aGlzLmlucHV0Q2xhc3MpLmZvckVhY2goY2xzTmFtZSA9PiB7CiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmlucHV0Q2xhc3NbY2xzTmFtZV0pIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0Q2xhc3Nlcy5wdXNoKGNsc05hbWUpCiAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICB9KQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgZm9yIChsZXQgaW5wdXRDbGFzcyBvZiBpbnB1dENsYXNzZXMpIHsKICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXRDbGFzcyAmJiBpbnB1dENsYXNzLnRyaW0oKS5sZW5ndGgpIHsKICAgICAgICAgICAgICAgICAgICAgICAgaWRlbnRpZmllciArPSBgLiR7aW5wdXRDbGFzcy50cmltKCl9YAogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgICBjb25zdCBmaW5hbExvZ1RleHQgPSBgREVCVUc6ICR7bG9nVGV4dH0ke2lkZW50aWZpZXIgPyBgXG5cdCgke2lkZW50aWZpZXJ9KWAgOiAnJ31gCiAgICAgICAgICAgIGlmICh3aW5kb3cuY29uc29sZS5kZWJ1ZyAmJiB0eXBlb2Ygd2luZG93LmNvbnNvbGUuZGVidWcgPT09ICdmdW5jdGlvbicpIHsKICAgICAgICAgICAgICAgIHdpbmRvdy5jb25zb2xlLmRlYnVnKGZpbmFsTG9nVGV4dCkKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIHdpbmRvdy5jb25zb2xlLmxvZyhmaW5hbExvZ1RleHQpCiAgICAgICAgICAgIH0KICAgICAgICB9CiAgICB9LAoKICAgIG1vdW50ZWQoKSB7CiAgICAgICAgd2luZG93LmNsZWFyVGltZW91dCh0aGlzLmRlYm91bmNlVGltZXIpCiAgICAgICAgd2luZG93LmNsZWFyVGltZW91dCh0aGlzLnNlbGVjdGlvblRpbWVyKQogICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5rYklucHV0VGltZXIpCiAgICAgICAgdGhpcy5yZW5kZXJGb3JtYXQoKQogICAgfSwKCiAgICBiZWZvcmVEZXN0cm95KCkgewogICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5kZWJvdW5jZVRpbWVyKQogICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5zZWxlY3Rpb25UaW1lcikKICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMua2JJbnB1dFRpbWVyKQogICAgfQp9Cg=="},{"version":3,"sources":["VueTimePicker.vue"],"names":[],"mappings":";AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA","file":"VueTimePicker.vue","sourceRoot":"src/uiComponents","sourcesContent":["<script>\nconst CONFIG = {\n    HOUR_TOKENS: ['HH', 'H', 'hh', 'h', 'kk', 'k'],\n    MINUTE_TOKENS: ['mm', 'm'],\n    SECOND_TOKENS: ['ss', 's'],\n    APM_TOKENS: ['A', 'a'],\n    BASIC_TYPES: ['hour', 'minute', 'second', 'apm']\n}\n\nconst DEFAULT_OPTIONS = {\n    format: 'HH:mm',\n    minuteInterval: 1,\n    secondInterval: 1,\n    hourRange: null,\n    minuteRange: null,\n    secondRange: null,\n    hideDisabledHours: false,\n    hideDisabledMinutes: false,\n    hideDisabledSeconds: false,\n    hideDisabledItems: false,\n    hideDropdown: false,\n    blurDelay: 300,\n    manualInputTimeout: 1000,\n    dropOffsetHeight: 160\n}\n\nexport default {\n    name: 'VueTimepicker',\n    props: {\n        value: { type: [Object, String] },\n        format: { type: String },\n        minuteInterval: { type: [Number, String] },\n        secondInterval: { type: [Number, String] },\n\n        hourRange: { type: Array },\n        minuteRange: { type: Array },\n        secondRange: { type: Array },\n        apmLabelEnabled: { type: Boolean, default: false },\n        hideDisabledHours: { type: Boolean, default: false },\n        hideDisabledMinutes: { type: Boolean, default: false },\n        hideDisabledSeconds: { type: Boolean, default: false },\n        hideDisabledItems: { type: Boolean, default: false },\n\n        hideClearButton: { type: Boolean, default: false },\n        disabled: { type: Boolean, default: false },\n        closeOnComplete: { type: Boolean, default: false },\n\n        id: { type: String },\n        name: { type: String },\n        inputClass: { type: [String, Object, Array] },\n        placeholder: { type: String },\n        tabindex: { type: [Number, String], default: 0 },\n        inputWidth: { type: String },\n        autocomplete: { type: String, default: 'off' },\n\n        hourLabel: { type: String },\n        minuteLabel: { type: String },\n        secondLabel: { type: String },\n        apmLabel: { type: String },\n        amText: { type: String },\n        pmText: { type: String },\n\n        blurDelay: { type: [Number, String] },\n        advancedKeyboard: { type: Boolean, default: false },\n\n        lazy: { type: Boolean, default: false },\n        autoScroll: { type: Boolean, default: false },\n\n        dropDirection: { type: String, default: 'down' },\n        dropOffsetHeight: { type: [Number, String] },\n        containerId: { type: String },\n        appendToBody: { type: Boolean, default: false },\n\n        manualInput: { type: Boolean, default: false },\n        manualInputTimeout: { type: [Number, String] },\n        hideDropdown: { type: Boolean, default: false },\n        fixedDropdownButton: { type: Boolean, default: false },\n\n        debugMode: { type: Boolean, default: false }\n    },\n\n    data() {\n        return {\n            timeValue: {},\n\n            hours: [],\n            minutes: [],\n            seconds: [],\n            apms: [],\n\n            isActive: false,\n            showDropdown: false,\n            isFocusing: false,\n            debounceTimer: undefined,\n\n            hourType: 'HH',\n            minuteType: 'mm',\n            secondType: '',\n            apmType: '',\n            hour: '',\n            minute: '',\n            second: '',\n            apm: '',\n            fullValues: undefined,\n            bakDisplayTime: undefined,\n            doClearApmChecking: false,\n\n            selectionTimer: undefined,\n            kbInputTimer: undefined,\n            kbInputLog: '',\n            bakCurrentPos: undefined,\n            forceDropOnTop: false\n        }\n    },\n\n    computed: {\n        opts() {\n            const options = Object.assign({}, DEFAULT_OPTIONS)\n\n            if (this.format && this.format.length) {\n                options.format = String(this.format)\n            }\n\n            if (this.isNumber(this.minuteInterval)) {\n                options.minuteInterval = +this.minuteInterval\n            }\n            // minuteInterval failsafe\n            if (!options.minuteInterval || options.minuteInterval < 1 || options.minuteInterval > 60) {\n                if (this.debugMode) {\n                    if (options.minuteInterval > 60) {\n                        this.debugLog(`\"minute-interval\" should be less than 60. Current value is ${this.minuteInterval}`)\n                    } else if (options.minuteInterval === 0 || options.minuteInterval < 1) {\n                        this.debugLog(`\"minute-interval\" should be NO less than 1. Current value is ${this.minuteInterval}`)\n                    }\n                }\n                if (options.minuteInterval === 0) {\n                    options.minuteInterval = 60\n                } else {\n                    options.minuteInterval = 1\n                }\n            }\n\n            if (this.isNumber(this.secondInterval)) {\n                options.secondInterval = +this.secondInterval\n            }\n            // secondInterval failsafe\n            if (!options.secondInterval || options.secondInterval < 1 || options.secondInterval > 60) {\n                if (this.debugMode) {\n                    if (options.secondInterval > 60) {\n                        this.debugLog(`\"second-interval\" should be less than 60. Current value is ${this.secondInterval}`)\n                    } else if (options.secondInterval === 0 || options.secondInterval < 1) {\n                        this.debugLog(`\"second-interval\" should be NO less than 1. Current value is ${this.secondInterval}`)\n                    }\n                }\n                if (options.secondInterval === 0) {\n                    options.secondInterval = 60\n                } else {\n                    options.secondInterval = 1\n                }\n            }\n\n            if (this.hourRange && Array.isArray(this.hourRange)) {\n                options.hourRange = JSON.parse(JSON.stringify(this.hourRange))\n                if (!this.hourRange.length && this.debugMode) {\n                    this.debugLog('The \"hour-range\" array is empty (length === 0)')\n                }\n            }\n\n            if (this.minuteRange && Array.isArray(this.minuteRange)) {\n                options.minuteRange = JSON.parse(JSON.stringify(this.minuteRange))\n                if (!this.minuteRange.length && this.debugMode) {\n                    this.debugLog('The \"minute-range\" array is empty (length === 0)')\n                }\n            }\n\n            if (this.secondRange && Array.isArray(this.secondRange)) {\n                options.secondRange = JSON.parse(JSON.stringify(this.secondRange))\n                if (!this.secondRange.length && this.debugMode) {\n                    this.debugLog('The \"second-range\" array is empty (length === 0)')\n                }\n            }\n\n            if (this.hideDisabledItems) {\n                options.hideDisabledItems = true\n            }\n\n            if (this.hideDisabledHours || this.hideDisabledItems) {\n                options.hideDisabledHours = true\n            }\n            if (this.hideDisabledMinutes || this.hideDisabledItems) {\n                options.hideDisabledMinutes = true\n            }\n            if (this.hideDisabledSeconds || this.hideDisabledItems) {\n                options.hideDisabledSeconds = true\n            }\n\n            if (this.hideDropdown) {\n                if (this.manualInput) {\n                    options.hideDropdown = true\n                } else if (this.debugMode) {\n                    this.debugLog('\"hide-dropdown\" only works with \"manual-input\" mode')\n                }\n            }\n\n            if (this.blurDelay && +this.blurDelay > 0) {\n                options.blurDelay = +this.blurDelay\n            }\n\n            if (this.manualInputTimeout && +this.manualInputTimeout > 0) {\n                options.manualInputTimeout = +this.manualInputTimeout\n            }\n\n            if (this.dropOffsetHeight && +this.dropOffsetHeight > 0) {\n                options.dropOffsetHeight = +this.dropOffsetHeight\n            }\n\n            return options\n        },\n\n        useStringValue() {\n            return typeof this.value === 'string'\n        },\n\n        formatString() {\n            return this.opts.format || DEFAULT_OPTIONS.format\n        },\n\n        inUse() {\n            const typesInUse = CONFIG.BASIC_TYPES.filter(type => this.getTokenByType(type))\n            // Sort types and tokens by their sequence in the \"format\" string\n            typesInUse.sort((l, r) => {\n                return this.formatString.indexOf(this.getTokenByType(l) || null) - this.formatString.indexOf(this.getTokenByType(r) || null)\n            })\n            const tokensInUse = typesInUse.map(type => this.getTokenByType(type))\n            return {\n                hour: !!this.hourType,\n                minute: !!this.minuteType,\n                second: !!this.secondType,\n                apm: !!this.apmType,\n                types: typesInUse || [],\n                tokens: tokensInUse || []\n            }\n        },\n\n        displayTime() {\n            let formatString = String(this.formatString)\n            if (this.hour) {\n                formatString = formatString.replace(new RegExp(this.hourType, 'g'), this.hour)\n            }\n            if (this.minute) {\n                formatString = formatString.replace(new RegExp(this.minuteType, 'g'), this.minute)\n            }\n            if (this.second && this.secondType) {\n                formatString = formatString.replace(new RegExp(this.secondType, 'g'), this.second)\n            }\n            if (this.apm && this.apmType) {\n                formatString = formatString.replace(new RegExp(this.apmType, 'g'), this.apm)\n            }\n            return formatString\n        },\n\n        customDisplayTime() {\n            if (!this.amText && !this.pmText) {\n                return this.displayTime\n            }\n            return this.displayTime.replace(new RegExp(this.apm, 'g'), this.apmDisplayText(this.apm))\n        },\n\n        inputIsEmpty() {\n            return this.formatString === this.displayTime\n        },\n\n        allValueSelected() {\n            if (\n                (this.inUse.hour && !this.hour) ||\n                (this.inUse.minute && !this.minute) ||\n                (this.inUse.second && !this.second) ||\n                (this.inUse.apm && !this.apm)\n            ) {\n                return false\n            }\n            return true\n        },\n\n        columnsSequence() {\n            return this.inUse.types.map(type => type) || []\n        },\n\n        showClearBtn() {\n            if (this.hideClearButton || this.disabled) {\n                return false\n            }\n            return !this.inputIsEmpty\n        },\n\n        showDropdownBtn() {\n            if (this.fixedDropdownButton) { return true }\n            if (this.opts.hideDropdown && this.isActive && !this.showDropdown) {\n                return true\n            }\n            return false\n        },\n\n        baseOn12Hours() {\n            return this.hourType === 'h' || this.hourType === 'hh'\n        },\n\n        hourRangeIn24HrFormat() {\n            if (!this.hourType || !this.opts.hourRange) { return false }\n            if (!this.opts.hourRange.length) { return [] }\n\n            const range = []\n            this.opts.hourRange.forEach(value => {\n                if (value instanceof Array) {\n                    if (value.length > 2 && this.debugMode) {\n                        this.debugLog(`Nested array within \"hour-range\" must contain no more than two items. Only the first two items of ${JSON.stringify(value)} will be taken into account.`)\n                    }\n\n                    let start = value[0]\n                    let end = value[1] || value[0]\n\n                    if (this.is12hRange(start)) {\n                        start = this.translate12hRange(start)\n                    }\n                    if (this.is12hRange(end)) {\n                        end = this.translate12hRange(end)\n                    }\n\n                    for (let i = +start; i <= +end; i++) {\n                        if (i < 0 || i > 24) { continue }\n                        if (!range.includes(i)) {\n                            range.push(i)\n                        }\n                    }\n                } else {\n                    if (this.is12hRange(value)) {\n                        value = this.translate12hRange(value)\n                    } else {\n                        value = +value\n                    }\n                    if (value < 0 || value > 24) { return }\n                    if (!range.includes(value)) {\n                        range.push(value)\n                    }\n                }\n            })\n            range.sort((l, r) => { return l - r })\n            return range\n        },\n\n        restrictedHourRange() {\n            // No restriction\n            if (!this.hourRangeIn24HrFormat) { return false }\n            // 12-Hour\n            if (this.baseOn12Hours) {\n                const range = this.hourRangeIn24HrFormat.map((value) => {\n                    if (value === 12) {\n                        return '12p'\n                    } else if (value === 24 || value === 0) {\n                        return '12a'\n                    }\n                    return value > 12 ? `${value % 12}p` : `${value}a`\n                })\n                return range\n            }\n            // 24-Hour\n            return this.hourRangeIn24HrFormat\n        },\n\n        validHoursList() {\n            if (!this.manualInput) { return false }\n            if (this.restrictedHourRange) {\n                let list = []\n                if (this.baseOn12Hours) {\n                    list = this.restrictedHourRange.map(hr => {\n                        const l = hr.substr(0, hr.length - 1)\n                        const r = hr.substr(-1)\n                        return `${this.formatValue(this.hourType, l)}${r}`\n                    })\n                    const am12Index = list.indexOf('12a')\n                    if (am12Index > 0) {\n                        // Make '12a' the first item in h/hh\n                        list.unshift(list.splice(am12Index, 1)[0])\n                    }\n                    return list\n                }\n                list = this.restrictedHourRange.map(hr => {\n                    return this.formatValue(this.hourType, hr)\n                })\n                if (list.length > 1 && list[0] && list[0] === '24') {\n                    // Make '24' the last item in k/kk\n                    list.push(list.shift())\n                }\n                return list\n            }\n            if (this.baseOn12Hours) {\n                return [].concat([], this.hours.map(hr => `${hr}a`), this.hours.map(hr => `${hr}p`))\n            }\n            return this.hours\n        },\n\n        has() {\n            const result = {\n                customApmText: false\n            }\n            const apmEnabled = !!this.apmType\n\n            if (apmEnabled && this.hourRangeIn24HrFormat && this.hourRangeIn24HrFormat.length) {\n                const range = [].concat([], this.hourRangeIn24HrFormat)\n                result.am = range.some(value => value < 12 || value === 24)\n                result.pm = range.some(value => value >= 12 && value < 24)\n            } else {\n                result.am = apmEnabled\n                result.pm = apmEnabled\n            }\n            if ((this.amText && this.amText.length) || (this.pmText && this.pmText.length)) {\n                result.customApmText = true\n            }\n            return result\n        },\n\n        minuteRangeList() {\n            if (!this.minuteType || !this.opts.minuteRange) { return false }\n            if (!this.opts.minuteRange.length) { return [] }\n            return this.renderRangeList(this.opts.minuteRange, 'minute')\n        },\n\n        secondRangeList() {\n            if (!this.secondType || !this.opts.secondRange) { return false }\n            if (!this.opts.secondRange.length) { return [] }\n            return this.renderRangeList(this.opts.secondRange, 'second')\n        },\n\n        hourLabelText() {\n            return this.hourLabel || this.hourType\n        },\n        minuteLabelText() {\n            return this.minuteLabel || this.minuteType\n        },\n        secondLabelText() {\n            return this.secondLabel || this.secondType\n        },\n        apmLabelText() {\n            return this.apmLabel || this.apmType\n        },\n\n        inputWidthStyle() {\n            if (!this.inputWidth || !this.inputWidth.length) { return }\n            return {\n                width: this.inputWidth\n            }\n        },\n\n        tokenRegexBase() {\n            return this.inUse.tokens.join('|')\n        },\n\n        tokenChunks() {\n            if (!this.manualInput && !this.useStringValue) { return false }\n\n            const formatString = String(this.formatString)\n            const tokensRegxStr = `(${this.tokenRegexBase})+?`\n            const tokensMatchAll = this.getMatchAllByRegex(formatString, tokensRegxStr)\n\n            const tokenChunks = []\n            for (let tkMatch of tokensMatchAll) {\n                const rawToken = tkMatch[0]\n                const tokenMatchItem = {\n                    index: tkMatch.index,\n                    token: rawToken,\n                    type: this.getTokenType(rawToken),\n                    needsCalibrate: rawToken.length < 2,\n                    len: (rawToken || '').length\n                }\n                tokenChunks.push(tokenMatchItem)\n            }\n            return tokenChunks\n        },\n\n        needsPosCalibrate() {\n            if (!this.manualInput) { return false }\n            return this.tokenChunks.some(chk => chk.needsCalibrate)\n        },\n\n        tokenChunksPos() {\n            if (!this.manualInput) { return false }\n            if (!this.needsPosCalibrate) {\n                return this.tokenChunks.map(chk => {\n                    return {\n                        token: chk.token,\n                        type: chk.type,\n                        start: chk.index,\n                        end: chk.index + chk.len\n                    }\n                })\n            }\n            const list = []\n            let calibrateLen = 0\n            this.tokenChunks.forEach(chk => {\n                let chunkCurrentLen\n                // Adjust for customized AM/PM text\n                if (chk.type === 'apm' && this.has.customApmText) {\n                    if (this.apm && this.apm.length) {\n                        const customApmText = this.apm.toLowerCase() === 'am' ? this.amText : this.pmText\n                        chunkCurrentLen = (customApmText && customApmText.length) ? customApmText.length : chk.len\n                    } else {\n                        chunkCurrentLen = chk.len\n                    }\n                    // Others\n                } else {\n                    chunkCurrentLen = this[chk.type] && this[chk.type].length ? this[chk.type].length : chk.len\n                }\n                list.push({\n                    token: chk.token,\n                    type: chk.type,\n                    start: chk.index + calibrateLen,\n                    end: chk.index + calibrateLen + chunkCurrentLen\n                })\n                if (chk.needsCalibrate && chunkCurrentLen > chk.len) {\n                    calibrateLen += (chunkCurrentLen - chk.len)\n                }\n            })\n            return list\n        },\n\n        invalidValues() {\n            if (this.inputIsEmpty) { return [] }\n            if (!this.restrictedHourRange && !this.minuteRangeList && !this.secondRangeList && this.opts.minuteInterval === 1 && this.opts.secondInterval === 1) { return [] }\n\n            const result = []\n            if (this.inUse.hour && !this.isEmptyValue(this.hourType, this.hour) && (!this.isValidValue(this.hourType, this.hour) || this.isDisabled('hour', this.hour))) {\n                result.push('hour')\n            }\n            if (this.inUse.minute && !this.isEmptyValue(this.minuteType, this.minute) && (!this.isValidValue(this.minuteType, this.minute) || this.isDisabled('minute', this.minute) || this.notInInterval('minute', this.minute))) {\n                result.push('minute')\n            }\n            if (this.inUse.second && !this.isEmptyValue(this.secondType, this.second) && (!this.isValidValue(this.secondType, this.second) || this.isDisabled('second', this.second) || this.notInInterval('second', this.second))) {\n                result.push('second')\n            }\n            if (this.inUse.apm && !this.isEmptyValue(this.apmType, this.apm) && (!this.isValidValue(this.apmType, this.apm) || this.isDisabled('apm', this.apm))) {\n                result.push('apm')\n            }\n            if (result.length) {\n                return result\n            }\n            return []\n        },\n\n        hasInvalidInput() {\n            return Boolean(this.invalidValues && this.invalidValues.length)\n        },\n\n        autoDirectionEnabled() {\n            return this.dropDirection === 'auto'\n        },\n\n        dropdownDirClass() {\n            if (this.autoDirectionEnabled) {\n                return this.forceDropOnTop ? 'drop-up' : 'drop-down'\n            }\n            return this.dropDirection === 'up' ? 'drop-up' : 'drop-down'\n        }\n    },\n\n    watch: {\n        'opts.format'(newValue) {\n            this.renderFormat(newValue)\n        },\n        'opts.minuteInterval'(newInteval) {\n            this.renderList('minute', newInteval)\n        },\n        'opts.secondInterval'(newInteval) {\n            this.renderList('second', newInteval)\n        },\n        value: {\n            deep: true,\n            handler() {\n                this.readValues()\n            }\n        },\n        displayTime() {\n            this.fillValues()\n        },\n        disabled(toDisabled) {\n            if (toDisabled) {\n                // Force close dropdown and reset status when disabled\n                if (this.isActive) {\n                    this.isActive = false\n                }\n                if (this.showDropdown) {\n                    this.showDropdown = false\n                }\n            }\n        },\n        'invalidValues.length'(newLength, oldLength) {\n            if (newLength && newLength >= 1) {\n                this.$emit('error', this.invalidValues)\n            } else if (oldLength && oldLength >= 1) {\n                this.$emit('error', [])\n            }\n        }\n    },\n\n    methods: {\n        formatValue(token, i) {\n            if (!this.isNumber(i)) { return '' }\n            i = +i\n            switch (token) {\n                case 'H':\n                case 'h':\n                case 'k':\n                case 'm':\n                case 's':\n                    if (['h', 'k'].includes(token) && i === 0) {\n                        return token === 'k' ? '24' : '12'\n                    }\n                    return String(i)\n                case 'HH':\n                case 'mm':\n                case 'ss':\n                case 'hh':\n                case 'kk':\n                    if (['hh', 'kk'].includes(token) && i === 0) {\n                        return token === 'kk' ? '24' : '12'\n                    }\n                    return i < 10 ? `0${i}` : String(i)\n                default:\n                    return ''\n            }\n        },\n\n        checkAcceptingType(validValues, formatString) {\n            if (!validValues || !formatString || !formatString.length) { return '' }\n            for (let i = 0; i < validValues.length; i++) {\n                if (formatString.indexOf(validValues[i]) > -1) {\n                    return validValues[i]\n                }\n            }\n            return ''\n        },\n\n        renderFormat(newFormat) {\n            newFormat = newFormat || this.opts.format || DEFAULT_OPTIONS.format\n\n            let hourType = this.checkAcceptingType(CONFIG.HOUR_TOKENS, newFormat)\n            let minuteType = this.checkAcceptingType(CONFIG.MINUTE_TOKENS, newFormat)\n            this.secondType = this.checkAcceptingType(CONFIG.SECOND_TOKENS, newFormat)\n            this.apmType = this.checkAcceptingType(CONFIG.APM_TOKENS, newFormat)\n\n            // Failsafe checking\n            if (!hourType && !minuteType && !this.secondType && !this.apmType) {\n                if (this.debugMode && this.format) {\n                    this.debugLog(`No valid tokens found in your defined \"format\" string \"${this.format}\". Fallback to the default \"HH:mm\" format.`)\n                }\n                hourType = 'HH'\n                minuteType = 'mm'\n            }\n            this.hourType = hourType\n            this.minuteType = minuteType\n\n            this.hourType ? this.renderHoursList() : this.hours = []\n            this.minuteType ? this.renderList('minute') : this.minutes = []\n            this.secondType ? this.renderList('second') : this.seconds = []\n            this.apmType ? this.renderApmList() : this.apms = []\n\n            this.$nextTick(() => {\n                this.readValues()\n            })\n        },\n\n        renderHoursList() {\n            const hoursCount = this.baseOn12Hours ? 12 : 24\n            const hours = []\n            for (let i = 0; i < hoursCount; i++) {\n                if (this.hourType === 'k' || this.hourType === 'kk') {\n                    hours.push(this.formatValue(this.hourType, i + 1))\n                } else {\n                    hours.push(this.formatValue(this.hourType, i))\n                }\n            }\n            this.hours = hours\n        },\n\n        renderList(listType, interval) {\n            if (!this.isMinuteOrSecond(listType)) { return }\n\n            const isMinute = listType === 'minute'\n            interval = interval || (isMinute ? (this.opts.minuteInterval || DEFAULT_OPTIONS.minuteInterval) : (this.opts.secondInterval || DEFAULT_OPTIONS.secondInterval))\n\n            const result = []\n            for (let i = 0; i < 60; i += interval) {\n                result.push(this.formatValue(isMinute ? this.minuteType : this.secondType, i))\n            }\n            isMinute ? this.minutes = result : this.seconds = result\n        },\n\n        renderApmList() {\n            this.apms = this.apmType === 'A' ? ['AM', 'PM'] : ['am', 'pm']\n        },\n\n        readValues() {\n            if (this.useStringValue) {\n                if (this.debugMode) {\n                    this.debugLog(`Received a string value: \"${this.value}\"`)\n                }\n                this.readStringValues(this.value)\n            } else {\n                if (this.debugMode) {\n                    this.debugLog(`Received an object value: \"${JSON.stringify(this.value || {})}\"`)\n                }\n                this.readObjectValues(this.value)\n            }\n        },\n\n        readObjectValues(objValue) {\n            const timeValue = JSON.parse(JSON.stringify(objValue || {}))\n            const values = Object.keys(timeValue)\n\n            // Failsafe for empty `v-model` object\n            if (values.length === 0) {\n                this.addFallbackValues()\n                return\n            }\n\n            CONFIG.BASIC_TYPES.forEach(type => {\n                const token = this.getTokenByType(type)\n                if (values.indexOf(token) > -1) {\n                    const sanitizedValue = this.sanitizedValue(token, timeValue[token])\n                    this[type] = sanitizedValue\n                    timeValue[token] = sanitizedValue\n                } else {\n                    this[type] = ''\n                }\n            })\n            this.timeValue = timeValue\n        },\n\n        getMatchAllByRegex(testString, regexString) {\n            const str = 'polyfillTest'\n            const needsPolyfill = Boolean(!str.matchAll || typeof str.matchAll !== 'function')\n            return needsPolyfill ? this.polyfillMatchAll(testString, regexString) : testString.matchAll(new RegExp(regexString, 'g'))\n        },\n\n        readStringValues(stringValue) {\n            // Failsafe for empty `v-model` string\n            if (!stringValue || !stringValue.length) {\n                this.addFallbackValues()\n                return\n            }\n\n            const formatString = String(this.formatString)\n            const tokensRegxStr = `(${this.tokenRegexBase})+?`\n            const othersRegxStr = `[^(${this.tokenRegexBase})]+`\n\n            const tokensMatchAll = this.getMatchAllByRegex(formatString, tokensRegxStr)\n            const othersMatchAll = this.getMatchAllByRegex(formatString, othersRegxStr)\n\n            const chunks = []\n            const tokenChunks = []\n\n            for (let tkMatch of tokensMatchAll) {\n                const tokenMatchItem = {\n                    index: tkMatch.index,\n                    token: tkMatch[0],\n                    isValueToken: true\n                }\n                chunks.push(tokenMatchItem)\n                tokenChunks.push(tokenMatchItem)\n            }\n\n            for (let otMatch of othersMatchAll) {\n                chunks.push({\n                    index: otMatch.index,\n                    token: otMatch[0]\n                })\n            }\n\n            chunks.sort((l, r) => l.index < r.index ? -1 : 1)\n\n            let regexCombo = ''\n            chunks.forEach(chunk => {\n                if (chunk.isValueToken) {\n                    const tokenRegex = this.getTokenRegex(chunk.token) || ''\n                    regexCombo += tokenRegex\n                } else {\n                    const safeChars = chunk.token.replace(/\\\\{0}(\\*|\\?|\\.|\\+)/g, '\\\\$1')\n                    regexCombo += `(?:${safeChars})`\n                }\n            })\n\n            const comboReg = new RegExp(regexCombo)\n\n            // Do test before match\n            if (comboReg.test(stringValue)) {\n                const matchResults = stringValue.match(new RegExp(regexCombo))\n                const valueResults = matchResults.slice(1, tokenChunks.length + 1)\n                const timeValue = {}\n                valueResults.forEach((value, vrIndex) => {\n                    if (tokenChunks[vrIndex]) {\n                        const targetToken = tokenChunks[vrIndex].token\n                        timeValue[targetToken] = this.setValueFromString(value, targetToken)\n                    }\n                })\n                this.timeValue = timeValue\n\n                if (this.debugMode) {\n                    const tokenChunksForLog = tokenChunks.map(tChunk => tChunk && tChunk.token)\n                    this.debugLog(`Successfully parsed values ${JSON.stringify(valueResults)}\\nfor ${JSON.stringify(tokenChunksForLog)}\\nin format pattern '${this.formatString}'`)\n                }\n            } else {\n                if (this.debugMode) {\n                    this.debugLog(`The input string in \"v-model\" does NOT match the \"format\" pattern\\nformat: ${this.formatString}\\nv-model: ${stringValue}`)\n                }\n            }\n        },\n\n        polyfillMatchAll(targetString, regxStr) {\n            const matchesList = targetString.match(new RegExp(regxStr, 'g'))\n            const result = []\n            const indicesReg = []\n            if (matchesList && matchesList.length) {\n                matchesList.forEach(matchedItem => {\n                    const existIndex = indicesReg.findIndex(idxItem => idxItem.str === matchedItem)\n                    let index\n                    if (existIndex >= 0) {\n                        if (indicesReg[existIndex] && indicesReg[existIndex].regex) {\n                            index = indicesReg[existIndex].regex.exec(targetString).index\n                        }\n                    } else {\n                        const itemIndicesRegex = new RegExp(matchedItem, 'g')\n                        index = itemIndicesRegex.exec(targetString).index\n                        indicesReg.push({\n                            str: String(matchedItem),\n                            regex: itemIndicesRegex\n                        })\n                    }\n                    result.push({\n                        0: String(matchedItem),\n                        index: index\n                    })\n                })\n            }\n            return result\n        },\n\n        addFallbackValues() {\n            const timeValue = {}\n            this.inUse.types.forEach(type => {\n                timeValue[this.getTokenByType(type)] = ''\n            })\n            this.timeValue = timeValue\n        },\n\n        setValueFromString(parsedValue, token) {\n            if (!token || !parsedValue) { return '' }\n            const tokenType = this.getTokenType(token)\n            if (!tokenType || !tokenType.length) { return '' }\n            const stdValue = (parsedValue !== this.getTokenByType(tokenType)) ? parsedValue : ''\n            this[tokenType] = stdValue\n            return stdValue\n        },\n\n        fillValues(forceEmit) {\n            const fullValues = {}\n\n            const baseHour = this.hour\n            const baseHourType = this.hourType\n\n            let apmValue\n\n            // Hour type or hour value is NOT set in the \"format\" string\n            if (!baseHourType || !this.isNumber(baseHour)) {\n                CONFIG.HOUR_TOKENS.forEach(token => fullValues[token] = '')\n                apmValue = this.lowerCasedApm(this.apm || '')\n                fullValues.a = apmValue\n                fullValues.A = apmValue.toUpperCase()\n\n                // Both Hour type and value are set\n            } else {\n                const hourValue = +baseHour\n                const apmValue = (this.baseOn12Hours && this.apm) ? this.lowerCasedApm(this.apm) : false\n\n                CONFIG.HOUR_TOKENS.forEach((token) => {\n                    if (token === baseHourType) {\n                        fullValues[token] = baseHour\n                        return\n                    }\n\n                    let value\n                    let apm\n                    switch (token) {\n                        case 'H':\n                        case 'HH':\n                        case 'k':\n                        case 'kk':\n                            if (this.baseOn12Hours) {\n                                if (apmValue === 'pm') {\n                                    value = hourValue < 12 ? hourValue + 12 : hourValue\n                                } else if (['k', 'kk'].includes(token)) {\n                                    value = hourValue === 12 ? 24 : hourValue\n                                } else {\n                                    value = hourValue % 12\n                                }\n                            } else {\n                                if (['k', 'kk'].includes(token)) {\n                                    value = hourValue === 0 ? 24 : hourValue\n                                } else {\n                                    value = hourValue % 24\n                                }\n                            }\n                            fullValues[token] = this.formatValue(token, value)\n                            break\n                        case 'h':\n                        case 'hh':\n                            // h <-> hh\n                            if (this.baseOn12Hours) {\n                                value = hourValue\n                                apm = apmValue || ''\n                                // Read from other hour formats\n                            } else {\n                                if (hourValue > 11 && hourValue < 24) {\n                                    apm = 'pm'\n                                    value = hourValue === 12 ? 12 : hourValue % 12\n                                } else {\n                                    apm = 'am'\n                                    value = hourValue % 12 === 0 ? 12 : hourValue\n                                }\n                            }\n                            fullValues[token] = this.formatValue(token, value)\n                            fullValues.a = apm\n                            fullValues.A = apm.toUpperCase()\n                            break\n                    }\n                })\n            }\n\n            fullValues.m = this.formatValue('m', this.minute)\n            fullValues.mm = this.formatValue('mm', this.minute)\n            fullValues.s = this.formatValue('s', this.second)\n            fullValues.ss = this.formatValue('ss', this.second)\n\n            this.fullValues = fullValues\n\n            // On lazy mode, emit `input` and `change` events only when:\n            // - The user pick a new value and then close the dropdown\n            // - The user click the (\"x\") clear button\n            if (!this.lazy || forceEmit) {\n                this.emitTimeValue()\n            }\n\n            if (this.closeOnComplete && this.allValueSelected && this.showDropdown) {\n                this.toggleActive()\n            }\n        },\n\n        getFullData() {\n            if (!this.fullValues) {\n                this.fillValues()\n            }\n            return {\n                data: JSON.parse(JSON.stringify(this.fullValues)),\n                displayTime: this.inputIsEmpty ? '' : String(this.displayTime)\n            }\n        },\n\n        emitTimeValue() {\n            if (this.lazy && this.bakDisplayTime === this.displayTime) {\n                if (this.debugMode) {\n                    this.debugLog('The value does not change on `lazy` mode. Skip the emitting `input` and `change` event.')\n                }\n                return\n            }\n\n            const fullData = this.getFullData()\n\n            if (this.useStringValue) {\n                this.$emit('input', fullData.displayTime)\n            } else {\n                const fullValues = fullData.data\n                const tokensInUse = this.inUse.tokens || []\n                const timeValue = {}\n                tokensInUse.forEach((token) => {\n                    timeValue[token] = fullValues[token] || ''\n                })\n                this.$emit('input', JSON.parse(JSON.stringify(timeValue)))\n            }\n\n            this.$emit('change', fullData)\n        },\n\n        translate12hRange(value) {\n            const valueT = this.match12hRange(value)\n            if (+valueT[1] === 12) {\n                return +valueT[1] + (valueT[2].toLowerCase() === 'p' ? 0 : 12)\n            }\n            return +valueT[1] + (valueT[2].toLowerCase() === 'p' ? 12 : 0)\n        },\n\n        isDisabled(type, value) {\n            if (!this.isBasicType(type) || !this.inUse[type]) { return true }\n            switch (type) {\n                case 'hour':\n                    return this.isDisabledHour(value)\n                case 'minute':\n                case 'second':\n                    if (!this[`${type}RangeList`]) {\n                        return false\n                    }\n                    return !this[`${type}RangeList`].includes(value)\n                case 'apm':\n                    if (!this.restrictedHourRange) {\n                        return false\n                    }\n                    return !this.has[this.lowerCasedApm(value)]\n                default:\n                    return true\n            }\n        },\n\n        isDisabledHour(value) {\n            if (!this.restrictedHourRange) { return false }\n            if (this.baseOn12Hours) {\n                if (!this.apm || !this.apm.length) {\n                    return false\n                } else {\n                    const token = this.apm.toLowerCase() === 'am' ? 'a' : 'p'\n                    return !this.restrictedHourRange.includes(`${+value}${token}`)\n                }\n            }\n            // Fallback for 'HH' and 'H hour format with a `hour-range` in a 12-hour form\n            if (\n                (this.hourType === 'HH' || this.hourType === 'H') &&\n                +value === 0 && this.restrictedHourRange.includes(24)\n            ) {\n                return false\n            }\n            return !this.restrictedHourRange.includes(+value)\n        },\n\n        notInInterval(section, value) {\n            if (!section || !this.isMinuteOrSecond(section)) { return }\n            if (this.opts[`${section}Interval`] === 1) { return false }\n            return +value % this.opts[`${section}Interval`] !== 0\n        },\n\n        renderRangeList(rawRange, section) {\n            if (!rawRange || !section || !this.isMinuteOrSecond(section)) { return [] }\n            const range = []\n            let formatedValue\n            rawRange.forEach(value => {\n                if (value instanceof Array) {\n                    if (value.length > 2 && this.debugMode) {\n                        this.debugLog(`Nested array within \"${section}-range\" must contain no more than two items. Only the first two items of ${JSON.stringify(value)} will be taken into account.`)\n                    }\n                    const start = value[0]\n                    const end = value[1] || value[0]\n                    for (let i = +start; i <= +end; i++) {\n                        if (i < 0 || i > 59) { continue }\n                        formatedValue = this.formatValue(this.getTokenByType(section), i)\n                        if (!range.includes(formatedValue)) {\n                            range.push(formatedValue)\n                        }\n                    }\n                } else {\n                    if (+value < 0 || +value > 59) { return }\n                    formatedValue = this.formatValue(this.getTokenByType(section), value)\n                    if (!range.includes(formatedValue)) {\n                        range.push(formatedValue)\n                    }\n                }\n            })\n            range.sort((l, r) => { return l - r })\n            // Debug Mode\n            if (this.debugMode) {\n                const fullList = (section === 'minute' ? this.minutes : this.seconds) || []\n                const validItems = fullList.filter(item => range.includes(item))\n                if (!validItems || !validItems.length) {\n                    if (section === 'minute') {\n                        this.debugLog(`The minute list is empty due to the \"minute-range\" config\\nminute-range: ${JSON.stringify(this.minuteRange)}\\nminute-interval: ${this.opts.minuteInterval}`)\n                    } else {\n                        this.debugLog(`The second list is empty due to the \"second-range\" config\\nsecond-range: ${JSON.stringify(this.secondRange)}\\nsecond-interval: ${this.opts.secondInterval}`)\n                    }\n                }\n            }\n            return range\n        },\n\n        forceApmSelection() {\n            if (this.manualInput) {\n                // Skip this to allow users to paste a string value from the clipboard in Manual Input mode\n                return\n            }\n            if (this.apmType && !this.apm) {\n                if (this.has.am || this.has.pm) {\n                    this.doClearApmChecking = true\n                    const apmValue = this.has.am ? 'am' : 'pm'\n                    this.apm = this.apmType === 'A' ? apmValue.toUpperCase() : apmValue\n                }\n            }\n        },\n\n        emptyApmSelection() {\n            if (this.doClearApmChecking && this.hour === '' && this.minute === '' && this.second === '') {\n                this.apm = ''\n            }\n            this.doClearApmChecking = false\n        },\n\n        apmDisplayText(apmValue) {\n            if (this.amText && this.lowerCasedApm(apmValue) === 'am') {\n                return this.amText\n            }\n            if (this.pmText && this.lowerCasedApm(apmValue) === 'pm') {\n                return this.pmText\n            }\n            return apmValue\n        },\n\n        toggleActive() {\n            if (this.disabled) { return }\n            this.isActive = !this.isActive\n\n            if (this.isActive) {\n                this.isFocusing = true\n                if (this.manualInput) {\n                    this.$emit('focus')\n                }\n                if (!this.opts.hideDropdown) {\n                    this.setDropdownState(true)\n                }\n                // Record to check if value did change in the later phase\n                if (this.lazy) {\n                    this.bakDisplayTime = String(this.displayTime || '')\n                }\n                if (this.manualInput && !this.inputIsEmpty) {\n                    this.$nextTick(() => {\n                        if (this.$refs.input && this.$refs.input.selectionStart === 0 && this.$refs.input.selectionEnd === this.displayTime.length) {\n                            // Select the first slot instead of the whole value string when tabbed in\n                            this.selectFirstSlot()\n                        }\n                    })\n                }\n            } else {\n                if (this.showDropdown) {\n                    this.setDropdownState(false)\n                } else if (this.manualInput) {\n                    this.$emit('blur', this.getFullData())\n                }\n                this.isFocusing = false\n                if (this.lazy) {\n                    this.fillValues(true)\n                    this.bakDisplayTime = undefined\n                }\n            }\n\n            if (this.restrictedHourRange && this.baseOn12Hours) {\n                this.showDropdown ? this.forceApmSelection() : this.emptyApmSelection()\n            }\n            if (this.showDropdown) {\n                this.checkForAutoScroll()\n            }\n        },\n\n        setDropdownState(toShow, fromUserClick = false) {\n            if (toShow) {\n                if (this.appendToBody) {\n                    this.appendDropdownToBody()\n                }\n                this.keepFocusing()\n                if (this.autoDirectionEnabled) {\n                    this.checkDropDirection()\n                }\n                this.showDropdown = true\n                this.$emit('open')\n                if (fromUserClick) {\n                    if (this.fixedDropdownButton) {\n                        this.isActive = true\n                    }\n                    this.$emit('blur', this.getFullData())\n                    this.checkForAutoScroll()\n                }\n            } else {\n                this.showDropdown = false\n                this.$emit('close', this.getFullData())\n                if (this.appendToBody) {\n                    this.removeDropdownFromBody()\n                }\n            }\n        },\n\n        appendDropdownToBody() {\n            const dropdown = this.$refs && this.$refs.dropdown\n            const body = document.getElementsByTagName('body')[0]\n            if (body && dropdown) {\n                window.addEventListener('scroll', this.updateDropdownPos)\n                dropdown.classList.add('vue__time-picker-dropdown')\n                this.updateDropdownPos()\n                body.appendChild(dropdown)\n            }\n        },\n\n        updateDropdownPos() {\n            if (!this.appendToBody) { return }\n            const dropdown = this.$refs && this.$refs.dropdown\n            const body = document.getElementsByTagName('body')[0]\n            if (body && dropdown) {\n                const box = this.$el.getBoundingClientRect()\n                if (this.dropdownDirClass === 'drop-up') {\n                    dropdown.style.bottom = `${window.innerHeight - box.y}px`\n                    dropdown.style.top = 'auto'\n                } else {\n                    dropdown.style.top = `${box.y + box.height}px`\n                    dropdown.style.bottom = 'auto'\n                }\n                dropdown.style.left = `${box.x}px`\n            }\n        },\n\n        removeDropdownFromBody() {\n            const dropdown = this.$refs && this.$refs.dropdown\n            const body = document.getElementsByTagName('body')[0]\n            if (body && dropdown && body.contains(dropdown)) {\n                body.removeChild(dropdown)\n            }\n            if (dropdown) {\n                dropdown.classList.remove('vue__time-picker-dropdown')\n                dropdown.style.top = ''\n                dropdown.style.bottom = ''\n                dropdown.style.left = ''\n                this.$el.appendChild(dropdown)\n            }\n            window.removeEventListener('scroll', this.updateDropdownPos)\n        },\n\n        blurEvent() {\n            if (this.manualInput && !this.opts.hideDropdown) {\n                // hideDropdown's `blur` event is handled somewhere else\n                this.$emit('blur', this.getFullData())\n            }\n        },\n\n        select(type, value) {\n            if (this.isBasicType(type) && !this.isDisabled(type, value)) {\n                this[type] = value\n                if (this.doClearApmChecking) {\n                    this.doClearApmChecking = false\n                }\n            }\n        },\n\n        clearTime() {\n            if (this.disabled) { return }\n            this.hour = ''\n            this.minute = ''\n            this.second = ''\n            this.apm = ''\n\n            if (this.manualInput && this.$refs && this.$refs.input && this.$refs.input.value.length) {\n                this.$refs.input.value = ''\n            }\n\n            if (this.lazy) {\n                this.fillValues(true)\n            }\n        },\n\n        //\n        // Auto-Scroll\n        //\n\n        checkForAutoScroll() {\n            if (this.inputIsEmpty) { return }\n            if (this.autoScroll) {\n                this.$nextTick(() => {\n                    this.scrollToSelectedValues()\n                })\n            } else if (this.advancedKeyboard) {\n                // Auto-focus on selected value in the first column for advanced-keyboard\n                this.$nextTick(() => {\n                    const firstColumn = this.inUse.types[0]\n                    this.scrollToSelected(firstColumn, true)\n                })\n            }\n        },\n\n        scrollToSelected(column, allowFallback = false) {\n            if (!this.timeValue || this.inputIsEmpty) { return }\n            let targetList\n            if (this.appendToBody && this.$refs && this.$refs.dropdown) {\n                targetList = this.$refs.dropdown.querySelectorAll(`ul.${column}s`)[0]\n            } else {\n                targetList = this.$el.querySelectorAll(`ul.${column}s`)[0]\n            }\n            let targetValue = this.activeItemInCol(column)[0]\n            if (!targetValue && allowFallback) {\n                // No value selected in the target column, fallback to the first found valid item\n                targetValue = this.validItemsInCol(column)[0]\n            }\n            if (targetList && targetValue) {\n                targetList.scrollTop = targetValue.offsetTop - 40\n                if (this.advancedKeyboard) {\n                    targetValue.focus()\n                }\n            }\n        },\n\n        scrollToSelectedValues() {\n            if (!this.timeValue || this.inputIsEmpty) { return }\n            this.inUse.types.forEach(section => {\n                this.scrollToSelected(section)\n            })\n        },\n\n        //\n        // Additional Keyboard Navigation\n        //\n\n        onFocus() {\n            if (this.disabled) { return }\n            if (!this.isFocusing) {\n                this.isFocusing = true\n            }\n            if (!this.isActive) {\n                this.toggleActive()\n            }\n        },\n\n        escBlur() {\n            if (this.disabled) { return }\n            window.clearTimeout(this.debounceTimer)\n            this.isFocusing = false\n            const inputBox = this.$el.querySelectorAll('input.display-time')[0]\n            if (inputBox) {\n                inputBox.blur()\n            }\n        },\n\n        debounceBlur() {\n            if (this.disabled) { return }\n            this.isFocusing = false\n            window.clearTimeout(this.debounceTimer)\n            this.debounceTimer = window.setTimeout(() => {\n                window.clearTimeout(this.debounceTimer)\n                this.onBlur()\n            }, this.opts.blurDelay)\n        },\n\n        onBlur() {\n            if (!this.disabled && !this.isFocusing && this.isActive) {\n                this.toggleActive()\n            }\n        },\n\n        keepFocusing() {\n            if (this.disabled) { return }\n            window.clearTimeout(this.debounceTimer)\n            if (!this.isFocusing) {\n                this.isFocusing = true\n            }\n        },\n\n        onTab(column, value, evt) {\n            if (this.appendToBody && evt.shiftKey) {\n                const firstColumn = this.inUse.types[0]\n                if (column !== firstColumn) { return }\n                const firstValidValue = this.validItemsInCol(firstColumn)[0]\n                // Is the first valid item in the first column\n                if (firstValidValue && firstValidValue.getAttribute('data-key') === String(value)) {\n                    evt.preventDefault()\n                    // Focus back on <input>\n                    if (this.$refs && this.$refs.input) {\n                        this.$refs.input.focus()\n                    }\n                }\n            }\n        },\n\n        validItemsInCol(column) {\n            const columnClass = `${column}s`\n            if (this.appendToBody && this.$refs && this.$refs.dropdown) {\n                return this.$refs.dropdown.querySelectorAll(`ul.${columnClass} > li:not(.hint):not([disabled])`)\n            }\n            return this.$el.querySelectorAll(`ul.${columnClass} > li:not(.hint):not([disabled])`)\n        },\n\n        activeItemInCol(column) {\n            const columnClass = `${column}s`\n            if (this.appendToBody && this.$refs && this.$refs.dropdown) {\n                return this.$refs.dropdown.querySelectorAll(`ul.${columnClass} > li.active:not(.hint)`)\n            }\n            return this.$el.querySelectorAll(`ul.${columnClass} > li.active:not(.hint)`)\n        },\n\n        getClosestSibling(column, dataKey, getPrevious = false) {\n            const siblingsInCol = this.validItemsInCol(column)\n            const selfIndex = Array.prototype.findIndex.call(siblingsInCol, (sbl) => {\n                return sbl.getAttribute('data-key') === dataKey\n            })\n\n            // Already the first item\n            if (getPrevious && selfIndex === 0) {\n                return siblingsInCol[siblingsInCol.length - 1]\n            }\n            // Already the last item\n            if (!getPrevious && selfIndex === siblingsInCol.length - 1) {\n                return siblingsInCol[0]\n            }\n            // Selected value not in the valid values list\n            if (selfIndex < 0) {\n                return siblingsInCol[0]\n            }\n\n            if (getPrevious) {\n                return siblingsInCol[selfIndex - 1]\n            }\n            return siblingsInCol[selfIndex + 1]\n        },\n\n        prevItem(column, dataKey, isManualInput = false) {\n            const targetItem = this.getClosestSibling(column, dataKey, true)\n            if (targetItem) {\n                return isManualInput ? targetItem : targetItem.focus()\n            }\n        },\n\n        nextItem(column, dataKey, isManualInput = false) {\n            const targetItem = this.getClosestSibling(column, dataKey, false)\n            if (targetItem) {\n                return isManualInput ? targetItem : targetItem.focus()\n            }\n        },\n\n        getSideColumnName(currentColumn, toLeft = false) {\n            const currentColumnIndex = this.inUse.types.indexOf(currentColumn)\n            if (toLeft && currentColumnIndex <= 0) {\n                if (this.debugMode) {\n                    this.debugLog('You\\'re in the leftmost list already')\n                }\n                return\n            } else if (!toLeft && currentColumnIndex === (this.inUse.types.length - 1)) {\n                if (this.debugMode) {\n                    this.debugLog('You\\'re in the rightmost list already')\n                }\n                return\n            }\n            return this.inUse.types[toLeft ? currentColumnIndex - 1 : currentColumnIndex + 1]\n        },\n\n        getFirstItemInSideColumn(currentColumn, toLeft = false) {\n            const targetColumn = this.getSideColumnName(currentColumn, toLeft)\n            if (!targetColumn) { return }\n            const listItems = this.validItemsInCol(targetColumn)\n            if (listItems && listItems[0]) {\n                return listItems[0]\n            }\n        },\n\n        getActiveItemInSideColumn(currentColumn, toLeft = false) {\n            const targetColumn = this.getSideColumnName(currentColumn, toLeft)\n            if (!targetColumn) { return }\n            const activeItems = this.activeItemInCol(targetColumn)\n            if (activeItems && activeItems[0]) {\n                return activeItems[0]\n            }\n        },\n\n        toLeftColumn(currentColumn) {\n            const targetItem = this.getActiveItemInSideColumn(currentColumn, true) || this.getFirstItemInSideColumn(currentColumn, true)\n            if (targetItem) {\n                targetItem.focus()\n            }\n        },\n\n        toRightColumn(currentColumn) {\n            const targetItem = this.getActiveItemInSideColumn(currentColumn, false) || this.getFirstItemInSideColumn(currentColumn, false)\n            if (targetItem) {\n                targetItem.focus()\n            }\n        },\n\n        //\n        // Manual Input\n        //\n\n        onMouseDown() {\n            if (!this.manualInput) { return }\n            window.clearTimeout(this.selectionTimer)\n            this.selectionTimer = window.setTimeout(() => {\n                window.clearTimeout(this.selectionTimer)\n                if (this.$refs && this.$refs.input) {\n                    const nearestSlot = this.getNearestChunkByPos(this.$refs.input.selectionStart || 0)\n                    this.debounceSetInputSelection(nearestSlot)\n                }\n            }, 50)\n        },\n\n        keyDownHandler(evt) {\n            if (evt.isComposing || evt.keyCode === 229) {\n                // Skip IME inputs\n                evt.preventDefault()\n                evt.stopPropagation()\n                return false\n            }\n            // Numbers\n            if ((evt.keyCode >= 48 && evt.keyCode <= 57) || (evt.keyCode >= 96 && evt.keyCode <= 105)) {\n                evt.preventDefault()\n                this.keyboardInput(evt.key)\n                // A|P|M\n            } else if ([65, 80, 77].includes(evt.keyCode)) {\n                evt.preventDefault()\n                this.keyboardInput(evt.key, true)\n                // Arrow keys\n            } else if (evt.keyCode >= 37 && evt.keyCode <= 40) {\n                evt.preventDefault()\n                this.clearKbInputLog()\n                this.arrowHandler(evt)\n                // Delete|Backspace\n            } else if (evt.keyCode === 8 || evt.keyCode === 46) {\n                evt.preventDefault()\n                this.clearKbInputLog()\n                this.clearTime()\n                // Tab\n            } else if (evt.keyCode === 9) {\n                this.clearKbInputLog()\n                this.tabHandler(evt)\n                // Colon|Space\n            } else if (evt.keyCode === 186 || evt.keyCode === 32) {\n                evt.preventDefault()\n                this.clearKbInputLog()\n                this.toNextSlot()\n                // Prevent any Non-ESC and non-pasting inputs\n            } else if (evt.keyCode !== 27 && !(evt.metaKey || evt.ctrlKey)) {\n                evt.preventDefault()\n            }\n        },\n\n        onCompostionStart(evt) {\n            evt.preventDefault()\n            evt.stopPropagation()\n            this.bakCurrentPos = this.getCurrentTokenChunk()\n            return false\n        },\n\n        onCompostionEnd(evt) {\n            evt.preventDefault()\n            evt.stopPropagation()\n\n            const cpsData = evt.data\n            let inputIsCustomApmText = false\n            if (this.has.customApmText) {\n                inputIsCustomApmText = this.isCustomApmText(cpsData)\n            }\n            if (inputIsCustomApmText) {\n                this.setSanitizedValueToSection('apm', inputIsCustomApmText)\n            }\n\n            this.$refs.input.value = this.has.customApmText ? this.customDisplayTime : this.displayTime\n\n            this.$nextTick(() => {\n                if (this.bakCurrentPos) {\n                    const bakPos = JSON.parse(JSON.stringify(this.bakCurrentPos))\n                    if (inputIsCustomApmText) {\n                        bakPos.end = (bakPos.start + cpsData.length)\n                    }\n                    this.debounceSetInputSelection(bakPos)\n                    this.bakCurrentPos = null\n                }\n            })\n            return false\n        },\n\n        pasteHandler(evt) {\n            evt.preventDefault()\n            let pastingText = (evt.clipboardData || window.clipboardData).getData('text')\n            if (this.debugMode) {\n                this.debugLog(`Pasting value \"${pastingText}\" from clipboard`)\n            }\n            if (!pastingText || !pastingText.length) { return }\n\n            // Replace custom AM/PM text (if any)\n            if (this.has.customApmText) {\n                pastingText = this.replaceCustomApmText(pastingText)\n            }\n\n            if (this.inputIsEmpty) {\n                this.readStringValues(pastingText)\n            } else {\n                this.kbInputLog = pastingText.substr(-2, 2)\n                this.setKbInput()\n                this.debounceClearKbLog()\n            }\n        },\n\n        arrowHandler(evt) {\n            const direction = { 37: 'L', 38: 'U', 39: 'R', 40: 'D' }[evt.keyCode]\n            if (direction === 'U' || direction === 'D') {\n                if (this.inputIsEmpty) {\n                    this.selectFirstValidValue()\n                } else {\n                    const currentChunk = this.getCurrentTokenChunk()\n                    if (!currentChunk) {\n                        this.selectFirstValidValue()\n                        return\n                    }\n                    const tokenType = currentChunk.type\n                    this.getClosestValidItemInCol(tokenType, this[tokenType], direction)\n                    const newChunkPos = this.getCurrentTokenChunk()\n                    this.debounceSetInputSelection(newChunkPos)\n                }\n            } else if (direction === 'R') {\n                this.toLateralToken(false)\n            } else if (direction === 'L') {\n                this.toLateralToken(true)\n            }\n        },\n\n        tabHandler(evt) {\n            if (!this.inputIsEmpty && this.tokenChunksPos && this.tokenChunksPos.length) {\n                const currentChunk = this.getCurrentTokenChunk()\n                if (!currentChunk) { return }\n                const firstChunk = this.tokenChunksPos[0]\n                const lastChunk = this.tokenChunksPos[this.tokenChunksPos.length - 1]\n                if ((evt.shiftKey && currentChunk.token !== firstChunk.token) || (!evt.shiftKey && currentChunk.token !== lastChunk.token)) {\n                    evt.preventDefault()\n                    this.toLateralToken(evt.shiftKey)\n                }\n            } else if (this.appendToBody && this.advancedKeyboard) {\n                if (evt.shiftKey) { return }\n                evt.preventDefault()\n                if (this.inputIsEmpty) {\n                    const firstColumn = this.inUse.types[0]\n                    const targetValue = this.validItemsInCol(firstColumn)[0]\n                    if (targetValue) {\n                        targetValue.focus()\n                    }\n                }\n            }\n        },\n\n        keyboardInput(newChar, isApm = false) {\n            const currentChunk = this.getCurrentTokenChunk()\n            if (!currentChunk || (currentChunk.type !== 'apm' && isApm) || (currentChunk.type === 'apm' && !isApm)) { return }\n            this.kbInputLog = `${this.kbInputLog.substr(-1)}${newChar}`\n            this.setKbInput()\n            this.debounceClearKbLog()\n        },\n\n        clearKbInputLog() {\n            window.clearTimeout(this.kbInputTimer)\n            this.kbInputLog = ''\n        },\n\n        debounceClearKbLog() {\n            window.clearTimeout(this.kbInputTimer)\n            this.kbInputTimer = window.setTimeout(() => {\n                this.clearKbInputLog()\n            }, this.opts.manualInputTimeout)\n        },\n\n        setKbInput(value) {\n            value = value || this.kbInputLog\n            const currentChunk = this.getCurrentTokenChunk()\n            if (!currentChunk || !value || !value.length) { return }\n            const chunkType = currentChunk.type\n            const chunkToken = currentChunk.token\n\n            let validValue\n            if (chunkType === 'apm') {\n                if (this.lowerCasedApm(value).includes('a')) {\n                    validValue = 'am'\n                } else if (this.lowerCasedApm(value).includes('p')) {\n                    validValue = 'pm'\n                }\n                if (validValue) {\n                    validValue = chunkToken === 'A' ? validValue.toUpperCase() : validValue\n                }\n            } else {\n                if (this.isValidValue(chunkToken, value)) {\n                    validValue = value\n                } else {\n                    const lastInputValue = this.formatValue(chunkToken, value.substr(-1))\n                    if (this.isValidValue(chunkToken, lastInputValue)) {\n                        validValue = lastInputValue\n                    }\n                }\n            }\n\n            if (validValue) {\n                this.setSanitizedValueToSection(chunkType, validValue)\n                const newChunkPos = this.getCurrentTokenChunk()\n                this.debounceSetInputSelection(newChunkPos)\n            }\n            if (this.debugMode) {\n                if (validValue) {\n                    this.debugLog(`Successfully set value \"${validValue}\" from latest input \"${value}\" for the \"${chunkType}\" slot`)\n                } else {\n                    this.debugLog(`Value \"${value}\" is invalid in the \"${chunkType}\" slot`)\n                }\n            }\n        },\n\n        // Form Autofill\n        onChange() {\n            if (!this.manualInput || !this.$refs || !this.$refs.input) { return }\n            const autoFillValue = this.$refs.input.value || ''\n            if (autoFillValue && autoFillValue.length) {\n                this.readStringValues(autoFillValue)\n            }\n        },\n\n        getNearestChunkByPos(startPos) {\n            if (!this.tokenChunksPos || !this.tokenChunksPos.length) { return }\n            let nearest\n            let nearestDelta = -1\n            for (let i = 0; i < this.tokenChunksPos.length; i++) {\n                const chunk = JSON.parse(JSON.stringify(this.tokenChunksPos[i]))\n                if (chunk.start === startPos) {\n                    return chunk\n                }\n                const delta = Math.abs(chunk.start - startPos)\n                if (nearestDelta < 0) {\n                    nearest = chunk\n                    nearestDelta = delta\n                } else {\n                    if (nearestDelta <= delta) {\n                        return nearest\n                    }\n                    nearestDelta = delta\n                    nearest = chunk\n                }\n            }\n            return nearest\n        },\n\n        selectFirstValidValue() {\n            if (!this.tokenChunksPos || !this.tokenChunksPos.length) { return }\n            const firstSlotType = this.tokenChunksPos[0].type\n            if (firstSlotType === 'hour') {\n                this.getClosestHourItem()\n            } else {\n                this.getClosestValidItemInCol(firstSlotType, this[firstSlotType])\n            }\n            this.selectFirstSlot()\n        },\n\n        getClosestHourItem(currentValue, direction = 'U') {\n            if (!this.validHoursList || !this.validHoursList.length) {\n                if (this.debugMode) {\n                    this.debugLog(`No valid hour values found, please check your \"hour-range\" config\\nhour-range: ${JSON.stringify(this.hourRange)}`)\n                }\n                return\n            }\n            if (!currentValue) {\n                this.setManualHour(this.validHoursList[0])\n                return\n            }\n            const currentIndex = this.validHoursList.findIndex(item => {\n                if (!this.baseOn12Hours) {\n                    return item === currentValue\n                } else {\n                    const valueKey = `${currentValue}${this.lowerCasedApm(this.apm) === 'pm' ? 'p' : 'a'}`\n                    return item === valueKey\n                }\n            })\n            let nextIndex\n            if (currentIndex === -1) {\n                nextIndex = 0\n            } else if (direction === 'D') {\n                nextIndex = currentIndex === 0 ? this.validHoursList.length - 1 : currentIndex - 1\n            } else {\n                nextIndex = (currentIndex + 1) % this.validHoursList.length\n            }\n            const nextItem = this.validHoursList[nextIndex]\n            this.setManualHour(nextItem)\n        },\n\n        getClosestValidItemInCol(column, currentValue, direction = 'U') {\n            if (column === 'hour') {\n                this.getClosestHourItem(currentValue, direction)\n            } else {\n                const nextItem = direction === 'D' ? this.prevItem(column, this[column], true) : this.nextItem(column, this[column], true)\n                if (nextItem) {\n                    this.select(column, nextItem.getAttribute('data-key'))\n                }\n            }\n        },\n\n        setSanitizedValueToSection(section, inputValue) {\n            if (!section || !this.getTokenByType(section)) { return }\n            // NOTE: Disabled values are allowed here, followed by an 'error' event, though\n            const sanitizedValue = this.sanitizedValue(this.getTokenByType(section), inputValue)\n            this[section] = sanitizedValue\n        },\n\n        setManualHour(nextItem) {\n            if (this.is12hRange(nextItem)) {\n                const hourT = this.match12hRange(nextItem)\n                const apmValue = hourT[2] === 'a' ? 'AM' : 'PM'\n                this.setSanitizedValueToSection('apm', this.apmType === 'a' ? apmValue.toLowerCase() : apmValue)\n                this.setSanitizedValueToSection('hour', hourT[1])\n            } else {\n                this.setSanitizedValueToSection('hour', nextItem)\n            }\n        },\n\n        debounceSetInputSelection({ start = 0, end = 0 }) {\n            this.$nextTick(() => {\n                this.setInputSelectionRange(start, end)\n            })\n            window.clearTimeout(this.selectionTimer)\n            this.selectionTimer = window.setTimeout(() => {\n                window.clearTimeout(this.selectionTimer)\n                // Double-check selection for 12hr format\n                if (this.$refs.input && (this.$refs.input.selectionStart !== start || this.$refs.input.selectionEnd !== end)) {\n                    this.setInputSelectionRange(start, end)\n                }\n            }, 30)\n        },\n\n        setInputSelectionRange(start, end) {\n            if (this.$refs && this.$refs.input) {\n                this.$refs.input.setSelectionRange(start, end)\n            }\n        },\n\n        getCurrentTokenChunk() {\n            return this.getNearestChunkByPos((this.$refs.input && this.$refs.input.selectionStart) || 0)\n        },\n\n        selectFirstSlot() {\n            const firstChunkPos = this.getNearestChunkByPos(0)\n            this.debounceSetInputSelection(firstChunkPos)\n        },\n\n        toNextSlot() {\n            if (!this.inputIsEmpty && this.tokenChunksPos && this.tokenChunksPos.length) {\n                const currentChunk = this.getCurrentTokenChunk()\n                if (!currentChunk) { return }\n                const lastChunk = this.tokenChunksPos[this.tokenChunksPos.length - 1]\n                if (currentChunk.token !== lastChunk.token) {\n                    this.toLateralToken(false)\n                }\n            }\n        },\n\n        toLateralToken(toLeft) {\n            const currentChunk = this.getCurrentTokenChunk()\n            if (!currentChunk) {\n                this.selectFirstValidValue()\n                return\n            }\n            const currentChunkIndex = this.tokenChunksPos.findIndex(chk => chk.token === currentChunk.token)\n            if ((!toLeft && currentChunkIndex >= this.tokenChunksPos.length - 1) || (toLeft && currentChunkIndex === 0)) {\n                if (this.debugMode) {\n                    if (toLeft) {\n                        this.debugLog('You\\'re in the leftmost slot already')\n                    } else {\n                        this.debugLog('You\\'re in the rightmost slot already')\n                    }\n                }\n                return\n            }\n            const targetSlotPos = toLeft ? this.tokenChunksPos[currentChunkIndex - 1] : this.tokenChunksPos[currentChunkIndex + 1]\n            this.debounceSetInputSelection(targetSlotPos)\n        },\n\n        isCustomApmText(inputData) {\n            if (!inputData || !inputData.length) { return false }\n            if (this.amText && this.amText === inputData) {\n                return this.apmType === 'A' ? 'AM' : 'am'\n            }\n            if (this.pmText && this.pmText === inputData) {\n                return this.apmType === 'A' ? 'PM' : 'pm'\n            }\n            return false\n        },\n\n        replaceCustomApmText(inputString) {\n            if (this.amText && this.amText.length && inputString.includes(this.amText)) {\n                return inputString.replace(new RegExp(this.amText, 'g'), this.apmType === 'A' ? 'AM' : 'am')\n            } else if (this.pmText && this.pmText.length && inputString.includes(this.pmText)) {\n                return inputString.replace(new RegExp(this.pmText, 'g'), this.apmType === 'A' ? 'PM' : 'pm')\n            }\n            return inputString\n        },\n\n        checkDropDirection() {\n            if (!this.$el) { return }\n            let container\n            if (this.containerId && this.containerId.length) {\n                container = document.getElementById(this.containerId)\n                if (!container && this.debugMode) {\n                    this.debugLog(`Container with id \"${this.containerId}\" not found. Fallback to document body.`)\n                }\n            }\n            const el = this.$el\n            let spaceDown\n            if (container && container.offsetHeight) {\n                // Valid container found\n                spaceDown = (container.offsetTop + container.offsetHeight) - (el.offsetTop + el.offsetHeight)\n            } else {\n                // Fallback to document body\n                const docHeight = Math.max(document.body.scrollHeight, document.documentElement.scrollHeight, document.body.offsetHeight, document.documentElement.offsetHeight, document.body.clientHeight, document.documentElement.clientHeight)\n                spaceDown = docHeight - (el.offsetTop + el.offsetHeight)\n            }\n            this.forceDropOnTop = this.opts.dropOffsetHeight > spaceDown\n        },\n\n        //\n        // Helpers\n        //\n\n        is12hRange(value) {\n            return /^\\d{1,2}(a|p|A|P)$/.test(value)\n        },\n\n        match12hRange(value) {\n            return value.match(/^(\\d{1,2})(a|p|A|P)$/)\n        },\n\n        isNumber(value) {\n            return !isNaN(parseFloat(value)) && isFinite(value)\n        },\n\n        isBasicType(type) {\n            return CONFIG.BASIC_TYPES.includes(type)\n        },\n\n        lowerCasedApm(apmValue) {\n            return (apmValue || '').toLowerCase()\n        },\n\n        getTokenRegex(token) {\n            switch (token) {\n                case 'HH':\n                    return '([01][0-9]|2[0-3]|H{2})'\n                case 'H':\n                    return '([0-9]{1}|1[0-9]|2[0-3]|H{1})'\n                case 'hh':\n                    return '(0[1-9]|1[0-2]|h{2})'\n                case 'h':\n                    return '([1-9]{1}|1[0-2]|h{1})'\n                case 'kk':\n                    return '(0[1-9]|1[0-9]|2[0-4]|k{2})'\n                case 'k':\n                    return '([1-9]{1}|1[0-9]|2[0-4]|k{1})'\n                case 'mm':\n                    return '([0-5][0-9]|m{2})'\n                case 'ss':\n                    return '([0-5][0-9]|s{2})'\n                case 'm':\n                    return '([0-9]{1}|[1-5][0-9]|m{1})'\n                case 's':\n                    return '([0-9]{1}|[1-5][0-9]|s{1})'\n                case 'A':\n                    return '(AM|PM|A{1})'\n                case 'a':\n                    return '(am|pm|a{1})'\n                default:\n                    return ''\n            }\n        },\n\n        isEmptyValue(targetToken, testValue) {\n            return (!testValue || !testValue.length) || (testValue && testValue === targetToken)\n        },\n\n        isValidValue(targetToken, testValue) {\n            if (!targetToken || this.isEmptyValue(targetToken, testValue)) { return false }\n            const tokenRegexStr = this.getTokenRegex(targetToken)\n            if (!tokenRegexStr || !tokenRegexStr.length) { return false }\n            return (new RegExp(`^${tokenRegexStr}$`)).test(testValue)\n        },\n\n        sanitizedValue(targetToken, inputValue) {\n            if (this.isValidValue(targetToken, inputValue)) {\n                return inputValue\n            }\n            return ''\n        },\n\n        getTokenType(token) {\n            return this.inUse.types[this.inUse.tokens.indexOf(token)] || ''\n        },\n\n        getTokenByType(type) {\n            return this[`${type}Type`] || ''\n        },\n\n        isMinuteOrSecond(type) {\n            return ['minute', 'second'].includes(type)\n        },\n\n        debugLog(logText) {\n            if (!logText || !logText.length) { return }\n            let identifier = ''\n            if (this.id) {\n                identifier += `#${this.id}`\n            }\n            if (this.name) {\n                identifier += `[name=${this.name}]`\n            }\n            if (this.inputClass) {\n                let inputClasses = []\n                if (typeof this.inputClass === 'string') {\n                    inputClasses = this.inputClass.split(/\\s/g)\n                } else if (Array.isArray(this.inputClass)) {\n                    inputClasses = [].concat([], this.inputClass)\n                } else if (typeof this.inputClass === 'object') {\n                    Object.keys(this.inputClass).forEach(clsName => {\n                        if (this.inputClass[clsName]) {\n                            inputClasses.push(clsName)\n                        }\n                    })\n                }\n                for (let inputClass of inputClasses) {\n                    if (inputClass && inputClass.trim().length) {\n                        identifier += `.${inputClass.trim()}`\n                    }\n                }\n            }\n            const finalLogText = `DEBUG: ${logText}${identifier ? `\\n\\t(${identifier})` : ''}`\n            if (window.console.debug && typeof window.console.debug === 'function') {\n                window.console.debug(finalLogText)\n            } else {\n                window.console.log(finalLogText)\n            }\n        }\n    },\n\n    mounted() {\n        window.clearTimeout(this.debounceTimer)\n        window.clearTimeout(this.selectionTimer)\n        window.clearTimeout(this.kbInputTimer)\n        this.renderFormat()\n    },\n\n    beforeDestroy() {\n        window.clearTimeout(this.debounceTimer)\n        window.clearTimeout(this.selectionTimer)\n        window.clearTimeout(this.kbInputTimer)\n    }\n}\n</script>\n\n<template>\n    <span class=\"vue__time-picker time-picker\" :style=\"inputWidthStyle\">\n        <input type=\"text\" class=\"display-time\" ref=\"input\"\n            :class=\"[inputClass, { 'is-empty': inputIsEmpty, 'invalid': hasInvalidInput, 'all-selected': allValueSelected, 'disabled': disabled, 'has-custom-icon': $slots && $slots.icon }]\"\n            :style=\"inputWidthStyle\" :id=\"id\" :name=\"name\" :value=\"inputIsEmpty ? null : customDisplayTime\"\n            :placeholder=\"placeholder ? placeholder : formatString\" :tabindex=\"disabled ? -1 : tabindex\"\n            :disabled=\"disabled\" :readonly=\"!manualInput\" :autocomplete=\"autocomplete\" @focus=\"onFocus\" @change=\"onChange\"\n            @blur=\"debounceBlur(); blurEvent()\" @mousedown=\"onMouseDown\" @keydown=\"keyDownHandler\"\n            @compositionstart=\"onCompostionStart\" @compositionend=\"onCompostionEnd\" @paste=\"pasteHandler\"\n            @keydown.esc.exact=\"escBlur\" />\n        <div class=\"controls\" v-if=\"showClearBtn || showDropdownBtn\" tabindex=\"-1\">\n            <span v-if=\"!isActive && showClearBtn\" class=\"clear-btn\" tabindex=\"-1\"\n                :class=\"{ 'has-custom-btn': $slots && $slots.clearButton }\" @click=\"clearTime\">\n                <slot name=\"clearButton\"><span class=\"char\">&times;</span></slot>\n            </span>\n            <span v-if=\"showDropdownBtn\" class=\"dropdown-btn\" tabindex=\"-1\"\n                :class=\"{ 'has-custom-btn': $slots && $slots.dropdownButton }\"\n                @click=\"setDropdownState(fixedDropdownButton ? !showDropdown : true, true)\" @mousedown=\"keepFocusing\">\n                <slot name=\"dropdownButton\"><span class=\"char\">&dtrif;</span></slot>\n            </span>\n        </div>\n        <div class=\"custom-icon\" v-if=\"$slots && $slots.icon\">\n            <slot name=\"icon\"></slot>\n        </div>\n        <div class=\"time-picker-overlay\" v-if=\"showDropdown\" @click=\"toggleActive\" tabindex=\"-1\"></div>\n        <div class=\"dropdown\" ref=\"dropdown\" v-show=\"showDropdown\" tabindex=\"-1\" :class=\"[dropdownDirClass]\"\n            :style=\"inputWidthStyle\" @mouseup=\"keepFocusing\" @click.stop=\"\">\n            <div class=\"select-list\" :style=\"inputWidthStyle\" tabindex=\"-1\">\n                <!-- Common Keyboard Support: less event listeners -->\n                <template v-if=\"!advancedKeyboard\">\n                    <template v-for=\"column in columnsSequence\">\n                        <ul v-if=\"column === 'hour'\" :key=\"column\" class=\"hours\" @scroll=\"keepFocusing\">\n                            <li class=\"hint\" v-text=\"hourLabelText\"></li>\n                            <template v-for=\"(hr, hIndex) in hours\">\n                                <li v-if=\"!opts.hideDisabledHours || (opts.hideDisabledHours && !isDisabled('hour', hr))\"\n                                    :key=\"hIndex\" :class=\"{ active: hour === hr }\" :disabled=\"isDisabled('hour', hr)\"\n                                    :data-key=\"hr\" v-text=\"hr\" @click=\"select('hour', hr)\"></li>\n                            </template>\n                        </ul>\n                        <ul v-if=\"column === 'minute'\" :key=\"column\" class=\"minutes\" @scroll=\"keepFocusing\">\n                            <li class=\"hint\" v-text=\"minuteLabelText\"></li>\n                            <template v-for=\"(m, mIndex) in minutes\">\n                                <li v-if=\"!opts.hideDisabledMinutes || (opts.hideDisabledMinutes && !isDisabled('minute', m))\"\n                                    :key=\"mIndex\" :class=\"{ active: minute === m }\" :disabled=\"isDisabled('minute', m)\"\n                                    :data-key=\"m\" v-text=\"m\" @click=\"select('minute', m)\"></li>\n                            </template>\n                        </ul>\n                        <ul v-if=\"column === 'second'\" :key=\"column\" class=\"seconds\" @scroll=\"keepFocusing\">\n                            <template v-for=\"(s, sIndex) in seconds\">\n                                <li v-if=\"!opts.hideDisabledSeconds || (opts.hideDisabledSeconds && !isDisabled('second', s))\"\n                                    :key=\"sIndex\" :class=\"{ active: second === s }\" :disabled=\"isDisabled('second', s)\"\n                                    :data-key=\"s\" v-text=\"s\" @click=\"select('second', s)\"></li>\n                            </template>\n                        </ul>\n                        <ul v-if=\"column === 'apm'\" :key=\"column\" class=\"apms\" @scroll=\"keepFocusing\">\n                            <div v-if=\"!apmLabelEnabled\" style=\"margin:2.3rem\"></div>\n                            <li class=\"hint\" v-text=\"apmLabelText\" v-if=\"apmLabelEnabled\"></li>\n                            <template v-for=\"(a, aIndex) in apms\">\n                                <li v-if=\"!opts.hideDisabledHours || (opts.hideDisabledHours && !isDisabled('apm', a))\"\n                                    :key=\"aIndex\" :class=\"{ active: apm === a }\" :disabled=\"isDisabled('apm', a)\"\n                                    :data-key=\"a\" v-text=\"apmDisplayText(a)\" @click=\"select('apm', a)\"></li>\n                            </template>\n                        </ul>\n                    </template>\n                </template><!-- / Common Keyboard Support -->\n\n                <!--\n                                                                                                                                                                                                                                                                                                                            Advanced Keyboard Support\n                                                                                                                                                                                                                                                                                                                            Addeds hundreds of additional event lisenters\n                                                                                                                                                                                                                                                                                                                          -->\n                <template v-if=\"advancedKeyboard\">\n                    <template v-for=\"column in columnsSequence\">\n                        <ul v-if=\"column === 'hour'\" :key=\"column\" class=\"hours\" tabindex=\"-1\" @scroll=\"keepFocusing\">\n                            <li class=\"hint\" v-text=\"hourLabelText\" tabindex=\"-1\"></li>\n                            <template v-for=\"(hr, hIndex) in hours\">\n                                <li v-if=\"!opts.hideDisabledHours || (opts.hideDisabledHours && !isDisabled('hour', hr))\"\n                                    :key=\"hIndex\" :class=\"{ active: hour === hr }\"\n                                    :tabindex=\"isDisabled('hour', hr) ? -1 : tabindex\" :data-key=\"hr\"\n                                    :disabled=\"isDisabled('hour', hr)\" v-text=\"hr\" @click=\"select('hour', hr)\"\n                                    @keydown.tab=\"onTab('hour', hr, $event)\" @keydown.space.prevent=\"select('hour', hr)\"\n                                    @keydown.enter.prevent=\"select('hour', hr)\" @keydown.up.prevent=\"prevItem('hour', hr)\"\n                                    @keydown.down.prevent=\"nextItem('hour', hr)\"\n                                    @keydown.left.prevent=\"toLeftColumn('hour')\"\n                                    @keydown.right.prevent=\"toRightColumn('hour')\" @keydown.esc.exact=\"debounceBlur\"\n                                    @blur=\"debounceBlur\" @focus=\"keepFocusing\"></li>\n                            </template>\n                        </ul>\n                        <ul v-if=\"column === 'minute'\" :key=\"column\" class=\"minutes\" tabindex=\"-1\" @scroll=\"keepFocusing\">\n                            <li class=\"hint\" v-text=\"minuteLabelText\" tabindex=\"-1\"></li>\n                            <template v-for=\"(m, mIndex) in minutes\">\n                                <li v-if=\"!opts.hideDisabledMinutes || (opts.hideDisabledMinutes && !isDisabled('minute', m))\"\n                                    :key=\"mIndex\" :class=\"{ active: minute === m }\"\n                                    :tabindex=\"isDisabled('minute', m) ? -1 : tabindex\" :data-key=\"m\"\n                                    :disabled=\"isDisabled('minute', m)\" v-text=\"m\" @click=\"select('minute', m)\"\n                                    @keydown.tab=\"onTab('minute', m, $event)\" @keydown.space.prevent=\"select('minute', m)\"\n                                    @keydown.enter.prevent=\"select('minute', m)\" @keydown.up.prevent=\"prevItem('minute', m)\"\n                                    @keydown.down.prevent=\"nextItem('minute', m)\"\n                                    @keydown.left.prevent=\"toLeftColumn('minute')\"\n                                    @keydown.right.prevent=\"toRightColumn('minute')\" @keydown.esc.exact=\"debounceBlur\"\n                                    @blur=\"debounceBlur\" @focus=\"keepFocusing\"></li>\n                            </template>\n                            <v-btn> </v-btn>\n\n                        </ul>\n                        <ul v-if=\"column === 'second'\" :key=\"column\" class=\"seconds\" tabindex=\"-1\" @scroll=\"keepFocusing\">\n                            <button></button>\n                            <li class=\"hint\" v-text=\"secondLabelText\" tabindex=\"-1\"></li>\n                            <template v-for=\"(s, sIndex) in seconds\">\n                                <li v-if=\"!opts.hideDisabledSeconds || (opts.hideDisabledSeconds && !isDisabled('second', s))\"\n                                    :key=\"sIndex\" :class=\"{ active: second === s }\"\n                                    :tabindex=\"isDisabled('second', s) ? -1 : tabindex\" :data-key=\"s\"\n                                    :disabled=\"isDisabled('second', s)\" v-text=\"s\" @click=\"select('second', s)\"\n                                    @keydown.tab=\"onTab('second', s, $event)\" @keydown.space.prevent=\"select('second', s)\"\n                                    @keydown.enter.prevent=\"select('second', s)\" @keydown.up.prevent=\"prevItem('second', s)\"\n                                    @keydown.down.prevent=\"nextItem('second', s)\"\n                                    @keydown.left.prevent=\"toLeftColumn('second')\"\n                                    @keydown.right.prevent=\"toRightColumn('second')\" @keydown.esc.exact=\"debounceBlur\"\n                                    @blur=\"debounceBlur\" @focus=\"keepFocusing\"></li>\n                            </template>\n                        </ul>\n                        <ul v-if=\"column === 'apm'\" :key=\"column\" class=\"apms\" tabindex=\"-1\" @scroll=\"keepFocusing\">\n                            <li class=\"hint\" v-text=\"apmLabelText\" tabindex=\"-1\" v-if=\"apmLabelEnabled\"></li>\n                            <template v-for=\"(a, aIndex) in apms\">\n                                <li v-if=\"!opts.hideDisabledHours || (opts.hideDisabledHours && !isDisabled('apm', a))\"\n                                    :key=\"aIndex\" :class=\"{ active: apm === a }\"\n                                    :tabindex=\"isDisabled('apm', a) ? -1 : tabindex\" :data-key=\"a\"\n                                    :disabled=\"isDisabled('apm', a)\" v-text=\"apmDisplayText(a)\" @click=\"select('apm', a)\"\n                                    @keydown.tab=\"onTab('apm', a, $event)\" @keydown.space.prevent=\"select('apm', a)\"\n                                    @keydown.enter.prevent=\"select('apm', a)\" @keydown.up.prevent=\"prevItem('apm', a)\"\n                                    @keydown.down.prevent=\"nextItem('apm', a)\" @keydown.left.prevent=\"toLeftColumn('apm')\"\n                                    @keydown.right.prevent=\"toRightColumn('apm')\" @keydown.esc.exact=\"debounceBlur\"\n                                    @blur=\"debounceBlur\" @focus=\"keepFocusing\"></li>\n                            </template>\n                        </ul>\n                    </template>\n                </template><!-- / Advanced Keyboard Support -->\n            </div>\n        </div>\n    </span>\n</template>\n\n<style>\n.vue__time-picker {\n    display: inline-block;\n    position: relative;\n    font-size: 1em;\n    width: 10em;\n    font-family: sans-serif;\n    vertical-align: middle;\n}\n\n.vue__time-picker * {\n    box-sizing: border-box;\n}\n\n.vue__time-picker input.display-time {\n    border: 1px solid #d2d2d2;\n    width: 10em;\n    height: 2.2em;\n    padding: 0.3em 0.5em;\n    font-size: 1em;\n}\n\n.vue__time-picker input.has-custom-icon {\n    padding-left: 1.8em;\n}\n\n.vue__time-picker input.display-time.invalid:not(.skip-error-style) {\n    border-color: #cc0033;\n    outline-color: #cc0033;\n}\n\n.vue__time-picker input.display-time:disabled,\n.vue__time-picker input.display-time.disabled {\n    color: #d2d2d2;\n}\n\n.vue__time-picker .controls {\n    position: absolute;\n    top: 0;\n    bottom: 0;\n    right: 0;\n    z-index: 3;\n\n    display: flex;\n    flex-flow: row nowrap;\n    justify-content: flex-end;\n    align-items: stretch;\n\n    /* Prevent browser focusing on the controls layer */\n    pointer-events: none;\n}\n\n.vue__time-picker .controls>* {\n    cursor: pointer;\n\n    width: auto;\n    display: flex;\n    flex-flow: column nowrap;\n    justify-content: center;\n    align-items: center;\n\n    padding: 0 0.35em;\n\n    color: #d2d2d2;\n    line-height: 100%;\n    font-style: normal;\n\n    /* Resume pointer-events on children components */\n    pointer-events: initial;\n\n    transition: color .2s, opacity .2s;\n}\n\n.vue__time-picker .controls>*:hover {\n    color: #797979;\n}\n\n.vue__time-picker .controls>*:focus,\n.vue__time-picker .controls>*:active {\n    outline: 0;\n}\n\n.vue__time-picker .controls .char {\n    font-size: 1.1em;\n    line-height: 100%;\n\n    /* Vertical align fixes for webkit browsers only */\n    -webkit-margin-before: -0.15em;\n}\n\n.vue__time-picker .custom-icon {\n    z-index: 2;\n    position: absolute;\n    left: 0;\n    top: 0;\n    bottom: 0;\n    width: 1.8em;\n\n    display: flex;\n    flex-flow: column nowrap;\n    justify-content: center;\n    align-items: center;\n\n    /* pass down mouse events to the <input> underneath */\n    pointer-events: none;\n}\n\n.vue__time-picker .custom-icon img,\n.vue__time-picker .custom-icon svg,\n.vue__time-picker .controls img,\n.vue__time-picker .controls svg {\n    display: inline-block;\n    vertical-align: middle;\n    margin: 0;\n    border: 0;\n    outline: 0;\n    max-width: 1em;\n    height: auto;\n}\n\n.vue__time-picker .time-picker-overlay {\n    z-index: 4;\n    position: fixed;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n}\n\n.vue__time-picker .dropdown,\n.vue__time-picker-dropdown {\n    position: absolute;\n    z-index: 5;\n    top: calc(2.2em + 2px);\n    left: 0;\n    background: #fff;\n    box-shadow: 0 1px 6px rgba(0, 0, 0, 0.15);\n    width: 10em;\n    height: 10em;\n    font-weight: normal;\n}\n\n/* Dropdown class when \"append-to-body\" is on */\n.vue__time-picker-dropdown {\n    position: fixed;\n    z-index: 100;\n}\n\n.vue__time-picker .dropdown.drop-up,\n.vue__time-picker-dropdown.drop-up {\n    top: auto;\n    bottom: calc(2.2em + 1px);\n}\n\n.vue__time-picker .dropdown .select-list,\n.vue__time-picker-dropdown .select-list {\n    width: 10em;\n    height: 10em;\n    overflow: hidden;\n    display: flex;\n    flex-flow: row nowrap;\n    align-items: stretch;\n    justify-content: space-between;\n}\n\n.vue__time-picker .dropdown .select-list:focus,\n.vue__time-picker .dropdown .select-list:active,\n.vue__time-picker-dropdown .select-list:focus,\n.vue__time-picker-dropdown .select-list:active {\n    outline: 0;\n}\n\n.vue__time-picker .dropdown ul,\n.vue__time-picker-dropdown ul {\n    padding: 0;\n    margin: 0;\n    list-style: none;\n    outline: 0;\n\n    flex: 1 1 0.00001px;\n    overflow-x: hidden;\n    overflow-y: auto;\n}\n\n.vue__time-picker .dropdown ul.minutes,\n.vue__time-picker .dropdown ul.seconds,\n.vue__time-picker .dropdown ul.apms,\n.vue__time-picker-dropdown ul.minutes,\n.vue__time-picker-dropdown ul.seconds,\n.vue__time-picker-dropdown ul.apms {\n    border-left: 1px solid #fff;\n}\n\n.vue__time-picker .dropdown ul li,\n.vue__time-picker-dropdown ul li {\n    list-style: none;\n    text-align: center;\n    padding: 0.3em 0;\n    color: #161616;\n}\n\n.vue__time-picker .dropdown ul li:not(.hint):not([disabled]):hover,\n.vue__time-picker .dropdown ul li:not(.hint):not([disabled]):focus,\n.vue__time-picker-dropdown ul li:not(.hint):not([disabled]):hover,\n.vue__time-picker-dropdown ul li:not(.hint):not([disabled]):focus {\n    background: rgba(0, 0, 0, .08);\n    color: #161616;\n    cursor: pointer;\n}\n\n.vue__time-picker .dropdown ul li:not([disabled]).active,\n.vue__time-picker .dropdown ul li:not([disabled]).active:hover,\n.vue__time-picker .dropdown ul li:not([disabled]).active:focus,\n.vue__time-picker-dropdown ul li:not([disabled]).active,\n.vue__time-picker-dropdown ul li:not([disabled]).active:hover,\n.vue__time-picker-dropdown ul li:not([disabled]).active:focus {\n    background: #41B883;\n    color: #fff;\n}\n\n.vue__time-picker .dropdown ul li[disabled],\n.vue__time-picker .dropdown ul li[disabled]:hover,\n.vue__time-picker-dropdown ul li[disabled],\n.vue__time-picker-dropdown ul li[disabled]:hover {\n    background: transparent;\n    opacity: 0.3;\n    cursor: not-allowed;\n}\n\n.vue__time-picker .dropdown .hint,\n.vue__time-picker-dropdown .hint {\n    color: #a5a5a5;\n    cursor: default;\n    font-size: 0.8em;\n}\n</style>\n"]}]}