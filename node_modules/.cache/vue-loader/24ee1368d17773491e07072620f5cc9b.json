{"remainingRequest":"/home/vignesh/DIVRT/guest-webapp/node_modules/vue-loader/lib/index.js??vue-loader-options!/home/vignesh/DIVRT/guest-webapp/src/uiComponents/SpherePhoneNumberInput/assets/RecycleScroller.vue?vue&type=style&index=0&lang=css&","dependencies":[{"path":"/home/vignesh/DIVRT/guest-webapp/src/uiComponents/SpherePhoneNumberInput/assets/RecycleScroller.vue","mtime":1686725510912},{"path":"/home/vignesh/DIVRT/guest-webapp/node_modules/css-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/vignesh/DIVRT/guest-webapp/node_modules/vue-loader/lib/loaders/stylePostLoader.js","mtime":499162500000},{"path":"/home/vignesh/DIVRT/guest-webapp/node_modules/postcss-loader/src/index.js","mtime":499162500000},{"path":"/home/vignesh/DIVRT/guest-webapp/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/vignesh/DIVRT/guest-webapp/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:CgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCi52dWUtcmVjeWNsZS1zY3JvbGxlciB7CiAgcG9zaXRpb246IHJlbGF0aXZlOwp9CgoudnVlLXJlY3ljbGUtc2Nyb2xsZXIuZGlyZWN0aW9uLXZlcnRpY2FsOm5vdCgucGFnZS1tb2RlKSB7CiAgb3ZlcmZsb3cteTogYXV0bzsKfQoKLnZ1ZS1yZWN5Y2xlLXNjcm9sbGVyLmRpcmVjdGlvbi1ob3Jpem9udGFsOm5vdCgucGFnZS1tb2RlKSB7CiAgb3ZlcmZsb3cteDogYXV0bzsKfQoKLnZ1ZS1yZWN5Y2xlLXNjcm9sbGVyLmRpcmVjdGlvbi1ob3Jpem9udGFsIHsKICBkaXNwbGF5OiBmbGV4Owp9CgoudnVlLXJlY3ljbGUtc2Nyb2xsZXJfX3Nsb3QgewogIGZsZXg6IGF1dG8gMCAwOwp9CgoudnVlLXJlY3ljbGUtc2Nyb2xsZXJfX2l0ZW0td3JhcHBlciB7CiAgZmxleDogMTsKICBib3gtc2l6aW5nOiBib3JkZXItYm94OwogIG92ZXJmbG93OiBoaWRkZW47CiAgcG9zaXRpb246IHJlbGF0aXZlOwp9CgoudnVlLXJlY3ljbGUtc2Nyb2xsZXIucmVhZHkgLnZ1ZS1yZWN5Y2xlLXNjcm9sbGVyX19pdGVtLXZpZXcgewogIHBvc2l0aW9uOiBhYnNvbHV0ZTsKICB0b3A6IDA7CiAgbGVmdDogMDsKICB3aWxsLWNoYW5nZTogdHJhbnNmb3JtOwp9CgoudnVlLXJlY3ljbGUtc2Nyb2xsZXIuZGlyZWN0aW9uLXZlcnRpY2FsIC52dWUtcmVjeWNsZS1zY3JvbGxlcl9faXRlbS13cmFwcGVyIHsKICB3aWR0aDogMTAwJTsKfQoKLnZ1ZS1yZWN5Y2xlLXNjcm9sbGVyLmRpcmVjdGlvbi1ob3Jpem9udGFsIC52dWUtcmVjeWNsZS1zY3JvbGxlcl9faXRlbS13cmFwcGVyIHsKICBoZWlnaHQ6IDEwMCU7Cn0KCi52dWUtcmVjeWNsZS1zY3JvbGxlci5yZWFkeS5kaXJlY3Rpb24tdmVydGljYWwgLnZ1ZS1yZWN5Y2xlLXNjcm9sbGVyX19pdGVtLXZpZXcgewogIHdpZHRoOiAxMDAlOwp9CgoudnVlLXJlY3ljbGUtc2Nyb2xsZXIucmVhZHkuZGlyZWN0aW9uLWhvcml6b250YWwgLnZ1ZS1yZWN5Y2xlLXNjcm9sbGVyX19pdGVtLXZpZXcgewogIGhlaWdodDogMTAwJTsKfQo="},{"version":3,"sources":["RecycleScroller.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8vBA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA","file":"RecycleScroller.vue","sourceRoot":"src/uiComponents/SpherePhoneNumberInput/assets","sourcesContent":["<template>\n    <div\n      v-observe-visibility=\"handleVisibilityChange\"\n      class=\"vue-recycle-scroller\"\n      :class=\"{\n        ready,\n        'page-mode': pageMode,\n        [`direction-${direction}`]: true,\n      }\"\n      @scroll.passive=\"handleScroll\"\n    >\n      <div\n        v-if=\"$slots.before\"\n        ref=\"before\"\n        class=\"vue-recycle-scroller__slot\"\n      >\n        <slot\n          name=\"before\"\n        />\n      </div>\n  \n      <component\n        :is=\"listTag\"\n        ref=\"wrapper\"\n        :style=\"{ [direction === 'vertical' ? 'minHeight' : 'minWidth']: totalSize + 'px' }\"\n        class=\"vue-recycle-scroller__item-wrapper\"\n        :class=\"listClass\"\n      >\n        <component\n          :is=\"itemTag\"\n          v-for=\"view of pool\"\n          :key=\"view.nr.id\"\n          :style=\"ready ? {\n            transform: `translate${direction === 'vertical' ? 'Y' : 'X'}(${view.position}px) translate${direction === 'vertical' ? 'X' : 'Y'}(${view.offset}px)`,\n            width: gridItems ? `${direction === 'vertical' ? itemSecondarySize || itemSize : itemSize}px` : undefined,\n            height: gridItems ? `${direction === 'horizontal' ? itemSecondarySize || itemSize : itemSize}px` : undefined,\n          } : null\"\n          class=\"vue-recycle-scroller__item-view\"\n          :class=\"[\n            itemClass,\n            {\n              hover: !skipHover && hoverKey === view.nr.key\n            },\n          ]\"\n          v-on=\"skipHover ? {} : {\n            mouseenter: () => { hoverKey = view.nr.key },\n            mouseleave: () => { hoverKey = null },\n          }\"\n        >\n          <slot\n            :item=\"view.item\"\n            :index=\"view.nr.index\"\n            :active=\"view.nr.used\"\n          />\n        </component>\n  \n        <slot\n          name=\"empty\"\n        />\n      </component>\n  \n      <div\n        v-if=\"$slots.after\"\n        ref=\"after\"\n        class=\"vue-recycle-scroller__slot\"\n      >\n        <slot\n          name=\"after\"\n        />\n      </div>\n  \n      <ResizeObserver @notify=\"handleResize\" />\n    </div>\n  </template>\n  \n  <script>\n  import { shallowReactive, markRaw } from 'vue'\n  import { ResizeObserver } from 'vue-resize'\n  import { ObserveVisibility } from 'vue-observe-visibility'\n  import { getScrollParent } from '../assets/ScrollParent'\n  import config from '../config'\n  import { props, simpleArray } from './common'\n  import { supportsPassive } from '../assets/util'\n  \n  let uid = 0\n  \n  export default {\n    name: 'RecycleScroller',\n  \n    components: {\n      ResizeObserver,\n    },\n  \n    directives: {\n      ObserveVisibility,\n    },\n  \n    props: {\n      ...props,\n  \n      itemSize: {\n        type: Number,\n        default: null,\n      },\n  \n      gridItems: {\n        type: Number,\n        default: undefined,\n      },\n  \n      itemSecondarySize: {\n        type: Number,\n        default: undefined,\n      },\n  \n      minItemSize: {\n        type: [Number, String],\n        default: null,\n      },\n  \n      sizeField: {\n        type: String,\n        default: 'size',\n      },\n  \n      typeField: {\n        type: String,\n        default: 'type',\n      },\n  \n      buffer: {\n        type: Number,\n        default: 200,\n      },\n  \n      pageMode: {\n        type: Boolean,\n        default: false,\n      },\n  \n      prerender: {\n        type: Number,\n        default: 0,\n      },\n  \n      emitUpdate: {\n        type: Boolean,\n        default: false,\n      },\n  \n      updateInterval: {\n        type: Number,\n        default: 0,\n      },\n  \n      skipHover: {\n        type: Boolean,\n        default: false,\n      },\n  \n      listTag: {\n        type: String,\n        default: 'div',\n      },\n  \n      itemTag: {\n        type: String,\n        default: 'div',\n      },\n  \n      listClass: {\n        type: [String, Object, Array],\n        default: '',\n      },\n  \n      itemClass: {\n        type: [String, Object, Array],\n        default: '',\n      },\n    },\n  \n    emits: [\n      'resize',\n      'visible',\n      'hidden',\n      'update',\n      'scroll-start',\n      'scroll-end',\n    ],\n  \n    data () {\n      return {\n        pool: [],\n        totalSize: 0,\n        ready: false,\n        hoverKey: null,\n      }\n    },\n  \n    computed: {\n      sizes () {\n        if (this.itemSize === null) {\n          const sizes = {\n            '-1': { accumulator: 0 },\n          }\n          const items = this.items\n          const field = this.sizeField\n          const minItemSize = this.minItemSize\n          let computedMinSize = 10000\n          let accumulator = 0\n          let current\n          for (let i = 0, l = items.length; i < l; i++) {\n            current = items[i][field] || minItemSize\n            if (current < computedMinSize) {\n              computedMinSize = current\n            }\n            accumulator += current\n            sizes[i] = { accumulator, size: current }\n          }\n          // eslint-disable-next-line\n          this.$_computedMinItemSize = computedMinSize\n          return sizes\n        }\n        return []\n      },\n  \n      simpleArray,\n  \n      itemIndexByKey () {\n        const { keyField, items } = this\n        const result = {}\n        for (let i = 0, l = items.length; i < l; i++) {\n          result[items[i][keyField]] = i\n        }\n        return result\n      },\n    },\n  \n    watch: {\n      items () {\n        this.updateVisibleItems(true)\n      },\n  \n      pageMode () {\n        this.applyPageMode()\n        this.updateVisibleItems(false)\n      },\n  \n      sizes: {\n        handler () {\n          this.updateVisibleItems(false)\n        },\n        deep: true,\n      },\n  \n      gridItems () {\n        this.updateVisibleItems(true)\n      },\n  \n      itemSecondarySize () {\n        this.updateVisibleItems(true)\n      },\n    },\n  \n    created () {\n      this.$_startIndex = 0\n      this.$_endIndex = 0\n      this.$_views = new Map()\n      this.$_unusedViews = new Map()\n      this.$_scrollDirty = false\n      this.$_lastUpdateScrollPosition = 0\n  \n      // In SSR mode, we also prerender the same number of item for the first render\n      // to avoir mismatch between server and client templates\n      if (this.prerender) {\n        this.$_prerender = true\n        this.updateVisibleItems(false)\n      }\n  \n      if (this.gridItems && !this.itemSize) {\n        console.error('[vue-recycle-scroller] You must provide an itemSize when using gridItems')\n      }\n    },\n  \n    mounted () {\n      this.applyPageMode()\n      this.$nextTick(() => {\n        // In SSR mode, render the real number of visible items\n        this.$_prerender = false\n        this.updateVisibleItems(true)\n        this.ready = true\n      })\n    },\n  \n    activated () {\n      const lastPosition = this.$_lastUpdateScrollPosition\n      if (typeof lastPosition === 'number') {\n        this.$nextTick(() => {\n          this.scrollToPosition(lastPosition)\n        })\n      }\n    },\n  \n    beforeUnmount () {\n      this.removeListeners()\n    },\n  \n    methods: {\n      addView (pool, index, item, key, type) {\n        const nr = markRaw({\n          id: uid++,\n          index,\n          used: true,\n          key,\n          type,\n        })\n        const view = shallowReactive({\n          item,\n          position: 0,\n          nr,\n        })\n        pool.push(view)\n        return view\n      },\n  \n      unuseView (view, fake = false) {\n        const unusedViews = this.$_unusedViews\n        const type = view.nr.type\n        let unusedPool = unusedViews.get(type)\n        if (!unusedPool) {\n          unusedPool = []\n          unusedViews.set(type, unusedPool)\n        }\n        unusedPool.push(view)\n        if (!fake) {\n          view.nr.used = false\n          view.position = -9999\n        }\n      },\n  \n      handleResize () {\n        this.$emit('resize')\n        if (this.ready) this.updateVisibleItems(false)\n      },\n  \n      handleScroll (event) {\n        if (!this.$_scrollDirty) {\n          this.$_scrollDirty = true\n          if (this.$_updateTimeout) return\n  \n          const requestUpdate = () => requestAnimationFrame(() => {\n            this.$_scrollDirty = false\n            const { continuous } = this.updateVisibleItems(false, true)\n  \n            // It seems sometimes chrome doesn't fire scroll event :/\n            // When non continous scrolling is ending, we force a refresh\n            if (!continuous) {\n              clearTimeout(this.$_refreshTimout)\n              this.$_refreshTimout = setTimeout(this.handleScroll, this.updateInterval + 100)\n            }\n          })\n  \n          requestUpdate()\n  \n          // Schedule the next update with throttling\n          if (this.updateInterval) {\n            this.$_updateTimeout = setTimeout(() => {\n              this.$_updateTimeout = 0\n              if (this.$_scrollDirty) requestUpdate()\n            }, this.updateInterval)\n          }\n        }\n      },\n  \n      handleVisibilityChange (isVisible, entry) {\n        if (this.ready) {\n          if (isVisible || entry.boundingClientRect.width !== 0 || entry.boundingClientRect.height !== 0) {\n            this.$emit('visible')\n            requestAnimationFrame(() => {\n              this.updateVisibleItems(false)\n            })\n          } else {\n            this.$emit('hidden')\n          }\n        }\n      },\n  \n      updateVisibleItems (checkItem, checkPositionDiff = false) {\n        const itemSize = this.itemSize\n        const gridItems = this.gridItems || 1\n        const itemSecondarySize = this.itemSecondarySize || itemSize\n        const minItemSize = this.$_computedMinItemSize\n        const typeField = this.typeField\n        const keyField = this.simpleArray ? null : this.keyField\n        const items = this.items\n        const count = items.length\n        const sizes = this.sizes\n        const views = this.$_views\n        const unusedViews = this.$_unusedViews\n        const pool = this.pool\n        const itemIndexByKey = this.itemIndexByKey\n        let startIndex, endIndex\n        let totalSize\n        let visibleStartIndex, visibleEndIndex\n  \n        if (!count) {\n          startIndex = endIndex = visibleStartIndex = visibleEndIndex = totalSize = 0\n        } else if (this.$_prerender) {\n          startIndex = visibleStartIndex = 0\n          endIndex = visibleEndIndex = Math.min(this.prerender, items.length)\n          totalSize = null\n        } else {\n          const scroll = this.getScroll()\n  \n          // Skip update if use hasn't scrolled enough\n          if (checkPositionDiff) {\n            let positionDiff = scroll.start - this.$_lastUpdateScrollPosition\n            if (positionDiff < 0) positionDiff = -positionDiff\n            if ((itemSize === null && positionDiff < minItemSize) || positionDiff < itemSize) {\n              return {\n                continuous: true,\n              }\n            }\n          }\n          this.$_lastUpdateScrollPosition = scroll.start\n  \n          const buffer = this.buffer\n          scroll.start -= buffer\n          scroll.end += buffer\n  \n          // account for leading slot\n          let beforeSize = 0\n          if (this.$refs.before) {\n            beforeSize = this.$refs.before.scrollHeight\n            scroll.start -= beforeSize\n          }\n  \n          // account for trailing slot\n          if (this.$refs.after) {\n            const afterSize = this.$refs.after.scrollHeight\n            scroll.end += afterSize\n          }\n  \n          // Variable size mode\n          if (itemSize === null) {\n            let h\n            let a = 0\n            let b = count - 1\n            let i = ~~(count / 2)\n            let oldI\n  \n            // Searching for startIndex\n            do {\n              oldI = i\n              h = sizes[i].accumulator\n              if (h < scroll.start) {\n                a = i\n              } else if (i < count - 1 && sizes[i + 1].accumulator > scroll.start) {\n                b = i\n              }\n              i = ~~((a + b) / 2)\n            } while (i !== oldI)\n            i < 0 && (i = 0)\n            startIndex = i\n  \n            // For container style\n            totalSize = sizes[count - 1].accumulator\n  \n            // Searching for endIndex\n            for (endIndex = i; endIndex < count && sizes[endIndex].accumulator < scroll.end; endIndex++);\n            if (endIndex === -1) {\n              endIndex = items.length - 1\n            } else {\n              endIndex++\n              // Bounds\n              endIndex > count && (endIndex = count)\n            }\n  \n            // search visible startIndex\n            for (visibleStartIndex = startIndex; visibleStartIndex < count && (beforeSize + sizes[visibleStartIndex].accumulator) < scroll.start; visibleStartIndex++);\n  \n            // search visible endIndex\n            for (visibleEndIndex = visibleStartIndex; visibleEndIndex < count && (beforeSize + sizes[visibleEndIndex].accumulator) < scroll.end; visibleEndIndex++);\n          } else {\n            // Fixed size mode\n            startIndex = ~~(scroll.start / itemSize * gridItems)\n            const remainer = startIndex % gridItems\n            startIndex -= remainer\n            endIndex = Math.ceil(scroll.end / itemSize * gridItems)\n            visibleStartIndex = Math.max(0, Math.floor((scroll.start - beforeSize) / itemSize * gridItems))\n            visibleEndIndex = Math.floor((scroll.end - beforeSize) / itemSize * gridItems)\n  \n            // Bounds\n            startIndex < 0 && (startIndex = 0)\n            endIndex > count && (endIndex = count)\n            visibleStartIndex < 0 && (visibleStartIndex = 0)\n            visibleEndIndex > count && (visibleEndIndex = count)\n  \n            totalSize = Math.ceil(count / gridItems) * itemSize\n          }\n        }\n  \n        if (endIndex - startIndex > config.itemsLimit) {\n          this.itemsLimitError()\n        }\n  \n        this.totalSize = totalSize\n  \n        let view\n  \n        const continuous = startIndex <= this.$_endIndex && endIndex >= this.$_startIndex\n  \n        // Unuse views that are no longer visible\n        if (continuous) {\n          for (let i = 0, l = pool.length; i < l; i++) {\n            view = pool[i]\n            if (view.nr.used) {\n              // Update view item index\n              if (checkItem) {\n                view.nr.index = itemIndexByKey[view.item[keyField]]\n              }\n  \n              // Check if index is still in visible range\n              if (\n                view.nr.index == null ||\n                view.nr.index < startIndex ||\n                view.nr.index >= endIndex\n              ) {\n                this.unuseView(view)\n              }\n            }\n          }\n        }\n  \n        const unusedIndex = continuous ? null : new Map()\n  \n        let item, type\n        let v\n        for (let i = startIndex; i < endIndex; i++) {\n          item = items[i]\n          const key = keyField ? item[keyField] : item\n          if (key == null) {\n            throw new Error(`Key is ${key} on item (keyField is '${keyField}')`)\n          }\n          view = views.get(key)\n  \n          if (!itemSize && !sizes[i].size) {\n            if (view) this.unuseView(view)\n            continue\n          }\n  \n          type = item[typeField]\n  \n          let unusedPool = unusedViews.get(type)\n          let newlyUsedView = false\n  \n          // No view assigned to item\n          if (!view) {\n            if (continuous) {\n              // Reuse existing view\n              if (unusedPool && unusedPool.length) {\n                view = unusedPool.pop()\n              } else {\n                view = this.addView(pool, i, item, key, type)\n              }\n            } else {\n              // Use existing view\n              // We don't care if they are already used\n              // because we are not in continous scrolling\n              v = unusedIndex.get(type) || 0\n  \n              if (!unusedPool || v >= unusedPool.length) {\n                view = this.addView(pool, i, item, key, type)\n                this.unuseView(view, true)\n                unusedPool = unusedViews.get(type)\n              }\n  \n              view = unusedPool[v]\n              unusedIndex.set(type, v + 1)\n            }\n  \n            // Assign view to item\n            views.delete(view.nr.key)\n            view.nr.used = true\n            view.nr.index = i\n            view.nr.key = key\n            view.nr.type = type\n            views.set(key, view)\n  \n            newlyUsedView = true\n          } else {\n            // View already assigned to item\n            if (!view.nr.used) {\n              view.nr.used = true\n              newlyUsedView = true\n              if (unusedPool) {\n                const index = unusedPool.indexOf(view)\n                if (index !== -1) unusedPool.splice(index, 1)\n              }\n            }\n          }\n  \n          // Always set item in case it's a new object with the same key\n          view.item = item\n  \n          if (newlyUsedView) {\n            if (i === items.length - 1) this.$emit('scroll-end')\n            if (i === 0) this.$emit('scroll-start')\n          }\n  \n          // Update position\n          if (itemSize === null) {\n            view.position = sizes[i - 1].accumulator\n            view.offset = 0\n          } else {\n            view.position = Math.floor(i / gridItems) * itemSize\n            view.offset = (i % gridItems) * itemSecondarySize\n          }\n        }\n  \n        this.$_startIndex = startIndex\n        this.$_endIndex = endIndex\n  \n        if (this.emitUpdate) this.$emit('update', startIndex, endIndex, visibleStartIndex, visibleEndIndex)\n  \n        // After the user has finished scrolling\n        // Sort views so text selection is correct\n        clearTimeout(this.$_sortTimer)\n        this.$_sortTimer = setTimeout(this.sortViews, this.updateInterval + 300)\n  \n        return {\n          continuous,\n        }\n      },\n  \n      getListenerTarget () {\n        let target = getScrollParent(this.$el)\n        // Fix global scroll target for Chrome and Safari\n        if (window.document && (target === window.document.documentElement || target === window.document.body)) {\n          target = window\n        }\n        return target\n      },\n  \n      getScroll () {\n        const { $el: el, direction } = this\n        const isVertical = direction === 'vertical'\n        let scrollState\n  \n        if (this.pageMode) {\n          const bounds = el.getBoundingClientRect()\n          const boundsSize = isVertical ? bounds.height : bounds.width\n          let start = -(isVertical ? bounds.top : bounds.left)\n          let size = isVertical ? window.innerHeight : window.innerWidth\n          if (start < 0) {\n            size += start\n            start = 0\n          }\n          if (start + size > boundsSize) {\n            size = boundsSize - start\n          }\n          scrollState = {\n            start,\n            end: start + size,\n          }\n        } else if (isVertical) {\n          scrollState = {\n            start: el.scrollTop,\n            end: el.scrollTop + el.clientHeight,\n          }\n        } else {\n          scrollState = {\n            start: el.scrollLeft,\n            end: el.scrollLeft + el.clientWidth,\n          }\n        }\n  \n        return scrollState\n      },\n  \n      applyPageMode () {\n        if (this.pageMode) {\n          this.addListeners()\n        } else {\n          this.removeListeners()\n        }\n      },\n  \n      addListeners () {\n        this.listenerTarget = this.getListenerTarget()\n        this.listenerTarget.addEventListener('scroll', this.handleScroll, supportsPassive\n          ? {\n              passive: true,\n            }\n          : false)\n        this.listenerTarget.addEventListener('resize', this.handleResize)\n      },\n  \n      removeListeners () {\n        if (!this.listenerTarget) {\n          return\n        }\n  \n        this.listenerTarget.removeEventListener('scroll', this.handleScroll)\n        this.listenerTarget.removeEventListener('resize', this.handleResize)\n  \n        this.listenerTarget = null\n      },\n  \n      scrollToItem (index) {\n        let scroll\n        const gridItems = this.gridItems || 1\n        if (this.itemSize === null) {\n          scroll = index > 0 ? this.sizes[index - 1].accumulator : 0\n        } else {\n          scroll = Math.floor(index / gridItems) * this.itemSize\n        }\n        this.scrollToPosition(scroll)\n      },\n  \n      scrollToPosition (position) {\n        const direction = this.direction === 'vertical'\n          ? { scroll: 'scrollTop', start: 'top' }\n          : { scroll: 'scrollLeft', start: 'left' }\n  \n        let viewport\n        let scrollDirection\n        let scrollDistance\n  \n        if (this.pageMode) {\n          const viewportEl = getScrollParent(this.$el)\n          // HTML doesn't overflow like other elements\n          const scrollTop = viewportEl.tagName === 'HTML' ? 0 : viewportEl[direction.scroll]\n          const bounds = viewportEl.getBoundingClientRect()\n  \n          const scroller = this.$el.getBoundingClientRect()\n          const scrollerPosition = scroller[direction.start] - bounds[direction.start]\n  \n          viewport = viewportEl\n          scrollDirection = direction.scroll\n          scrollDistance = position + scrollTop + scrollerPosition\n        } else {\n          viewport = this.$el\n          scrollDirection = direction.scroll\n          scrollDistance = position\n        }\n  \n        viewport[scrollDirection] = scrollDistance\n      },\n  \n      itemsLimitError () {\n        setTimeout(() => {\n          console.log('It seems the scroller element isn\\'t scrolling, so it tries to render all the items at once.', 'Scroller:', this.$el)\n          console.log('Make sure the scroller has a fixed height (or width) and \\'overflow-y\\' (or \\'overflow-x\\') set to \\'auto\\' so it can scroll correctly and only render the items visible in the scroll viewport.')\n        })\n        throw new Error('Rendered items limit reached')\n      },\n  \n      sortViews () {\n        this.pool.sort((viewA, viewB) => viewA.nr.index - viewB.nr.index)\n      },\n    },\n  }\n  </script>\n  \n  <style>\n  .vue-recycle-scroller {\n    position: relative;\n  }\n  \n  .vue-recycle-scroller.direction-vertical:not(.page-mode) {\n    overflow-y: auto;\n  }\n  \n  .vue-recycle-scroller.direction-horizontal:not(.page-mode) {\n    overflow-x: auto;\n  }\n  \n  .vue-recycle-scroller.direction-horizontal {\n    display: flex;\n  }\n  \n  .vue-recycle-scroller__slot {\n    flex: auto 0 0;\n  }\n  \n  .vue-recycle-scroller__item-wrapper {\n    flex: 1;\n    box-sizing: border-box;\n    overflow: hidden;\n    position: relative;\n  }\n  \n  .vue-recycle-scroller.ready .vue-recycle-scroller__item-view {\n    position: absolute;\n    top: 0;\n    left: 0;\n    will-change: transform;\n  }\n  \n  .vue-recycle-scroller.direction-vertical .vue-recycle-scroller__item-wrapper {\n    width: 100%;\n  }\n  \n  .vue-recycle-scroller.direction-horizontal .vue-recycle-scroller__item-wrapper {\n    height: 100%;\n  }\n  \n  .vue-recycle-scroller.ready.direction-vertical .vue-recycle-scroller__item-view {\n    width: 100%;\n  }\n  \n  .vue-recycle-scroller.ready.direction-horizontal .vue-recycle-scroller__item-view {\n    height: 100%;\n  }\n  </style>"]}]}