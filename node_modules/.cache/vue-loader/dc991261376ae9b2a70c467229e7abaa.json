{"remainingRequest":"/home/vignesh/DIVRT/guest-webapp/node_modules/vue-loader/lib/index.js??vue-loader-options!/home/vignesh/DIVRT/guest-webapp/src/uiComponents/VueTimePicker.vue?vue&type=script&lang=js&","dependencies":[{"path":"/home/vignesh/DIVRT/guest-webapp/src/uiComponents/VueTimePicker.vue","mtime":1677651506113},{"path":"/home/vignesh/DIVRT/guest-webapp/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/vignesh/DIVRT/guest-webapp/node_modules/babel-loader/lib/index.js","mtime":315532800000},{"path":"/home/vignesh/DIVRT/guest-webapp/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/vignesh/DIVRT/guest-webapp/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:CmNvbnN0IENPTkZJRyA9IHsKICAgIEhPVVJfVE9LRU5TOiBbJ0hIJywgJ0gnLCAnaGgnLCAnaCcsICdraycsICdrJ10sCiAgICBNSU5VVEVfVE9LRU5TOiBbJ21tJywgJ20nXSwKICAgIFNFQ09ORF9UT0tFTlM6IFsnc3MnLCAncyddLAogICAgQVBNX1RPS0VOUzogWydBJywgJ2EnXSwKICAgIEJBU0lDX1RZUEVTOiBbJ2hvdXInLCAnbWludXRlJywgJ3NlY29uZCcsICdhcG0nXQp9Cgpjb25zdCBERUZBVUxUX09QVElPTlMgPSB7CiAgICBmb3JtYXQ6ICdISDptbScsCiAgICBtaW51dGVJbnRlcnZhbDogMSwKICAgIHNlY29uZEludGVydmFsOiAxLAogICAgaG91clJhbmdlOiBudWxsLAogICAgbWludXRlUmFuZ2U6IG51bGwsCiAgICBzZWNvbmRSYW5nZTogbnVsbCwKICAgIGhpZGVEaXNhYmxlZEhvdXJzOiBmYWxzZSwKICAgIGhpZGVEaXNhYmxlZE1pbnV0ZXM6IGZhbHNlLAogICAgaGlkZURpc2FibGVkU2Vjb25kczogZmFsc2UsCiAgICBoaWRlRGlzYWJsZWRJdGVtczogZmFsc2UsCiAgICBoaWRlRHJvcGRvd246IGZhbHNlLAogICAgYmx1ckRlbGF5OiAzMDAsCiAgICBtYW51YWxJbnB1dFRpbWVvdXQ6IDEwMDAsCiAgICBkcm9wT2Zmc2V0SGVpZ2h0OiAxNjAKfQoKZXhwb3J0IGRlZmF1bHQgewogICAgbmFtZTogJ1Z1ZVRpbWVwaWNrZXInLAogICAgcHJvcHM6IHsKICAgICAgICB2YWx1ZTogeyB0eXBlOiBbT2JqZWN0LCBTdHJpbmddIH0sCiAgICAgICAgZm9ybWF0OiB7IHR5cGU6IFN0cmluZyB9LAogICAgICAgIG1pbnV0ZUludGVydmFsOiB7IHR5cGU6IFtOdW1iZXIsIFN0cmluZ10gfSwKICAgICAgICBzZWNvbmRJbnRlcnZhbDogeyB0eXBlOiBbTnVtYmVyLCBTdHJpbmddIH0sCgogICAgICAgIGhvdXJSYW5nZTogeyB0eXBlOiBBcnJheSB9LAogICAgICAgIG1pbnV0ZVJhbmdlOiB7IHR5cGU6IEFycmF5IH0sCiAgICAgICAgc2Vjb25kUmFuZ2U6IHsgdHlwZTogQXJyYXkgfSwKCiAgICAgICAgaGlkZURpc2FibGVkSG91cnM6IHsgdHlwZTogQm9vbGVhbiwgZGVmYXVsdDogZmFsc2UgfSwKICAgICAgICBoaWRlRGlzYWJsZWRNaW51dGVzOiB7IHR5cGU6IEJvb2xlYW4sIGRlZmF1bHQ6IGZhbHNlIH0sCiAgICAgICAgaGlkZURpc2FibGVkU2Vjb25kczogeyB0eXBlOiBCb29sZWFuLCBkZWZhdWx0OiBmYWxzZSB9LAogICAgICAgIGhpZGVEaXNhYmxlZEl0ZW1zOiB7IHR5cGU6IEJvb2xlYW4sIGRlZmF1bHQ6IGZhbHNlIH0sCgogICAgICAgIGhpZGVDbGVhckJ1dHRvbjogeyB0eXBlOiBCb29sZWFuLCBkZWZhdWx0OiBmYWxzZSB9LAogICAgICAgIGRpc2FibGVkOiB7IHR5cGU6IEJvb2xlYW4sIGRlZmF1bHQ6IGZhbHNlIH0sCiAgICAgICAgY2xvc2VPbkNvbXBsZXRlOiB7IHR5cGU6IEJvb2xlYW4sIGRlZmF1bHQ6IGZhbHNlIH0sCgogICAgICAgIGlkOiB7IHR5cGU6IFN0cmluZyB9LAogICAgICAgIG5hbWU6IHsgdHlwZTogU3RyaW5nIH0sCiAgICAgICAgaW5wdXRDbGFzczogeyB0eXBlOiBbU3RyaW5nLCBPYmplY3QsIEFycmF5XSB9LAogICAgICAgIHBsYWNlaG9sZGVyOiB7IHR5cGU6IFN0cmluZyB9LAogICAgICAgIHRhYmluZGV4OiB7IHR5cGU6IFtOdW1iZXIsIFN0cmluZ10sIGRlZmF1bHQ6IDAgfSwKICAgICAgICBpbnB1dFdpZHRoOiB7IHR5cGU6IFN0cmluZyB9LAogICAgICAgIGF1dG9jb21wbGV0ZTogeyB0eXBlOiBTdHJpbmcsIGRlZmF1bHQ6ICdvZmYnIH0sCgogICAgICAgIGhvdXJMYWJlbDogeyB0eXBlOiBTdHJpbmcgfSwKICAgICAgICBtaW51dGVMYWJlbDogeyB0eXBlOiBTdHJpbmcgfSwKICAgICAgICBzZWNvbmRMYWJlbDogeyB0eXBlOiBTdHJpbmcgfSwKICAgICAgICBhcG1MYWJlbDogeyB0eXBlOiBTdHJpbmcgfSwKICAgICAgICBhbVRleHQ6IHsgdHlwZTogU3RyaW5nIH0sCiAgICAgICAgcG1UZXh0OiB7IHR5cGU6IFN0cmluZyB9LAoKICAgICAgICBibHVyRGVsYXk6IHsgdHlwZTogW051bWJlciwgU3RyaW5nXSB9LAogICAgICAgIGFkdmFuY2VkS2V5Ym9hcmQ6IHsgdHlwZTogQm9vbGVhbiwgZGVmYXVsdDogZmFsc2UgfSwKCiAgICAgICAgbGF6eTogeyB0eXBlOiBCb29sZWFuLCBkZWZhdWx0OiBmYWxzZSB9LAogICAgICAgIGF1dG9TY3JvbGw6IHsgdHlwZTogQm9vbGVhbiwgZGVmYXVsdDogZmFsc2UgfSwKCiAgICAgICAgZHJvcERpcmVjdGlvbjogeyB0eXBlOiBTdHJpbmcsIGRlZmF1bHQ6ICdkb3duJyB9LAogICAgICAgIGRyb3BPZmZzZXRIZWlnaHQ6IHsgdHlwZTogW051bWJlciwgU3RyaW5nXSB9LAogICAgICAgIGNvbnRhaW5lcklkOiB7IHR5cGU6IFN0cmluZyB9LAogICAgICAgIGFwcGVuZFRvQm9keTogeyB0eXBlOiBCb29sZWFuLCBkZWZhdWx0OiBmYWxzZSB9LAoKICAgICAgICBtYW51YWxJbnB1dDogeyB0eXBlOiBCb29sZWFuLCBkZWZhdWx0OiBmYWxzZSB9LAogICAgICAgIG1hbnVhbElucHV0VGltZW91dDogeyB0eXBlOiBbTnVtYmVyLCBTdHJpbmddIH0sCiAgICAgICAgaGlkZURyb3Bkb3duOiB7IHR5cGU6IEJvb2xlYW4sIGRlZmF1bHQ6IGZhbHNlIH0sCiAgICAgICAgZml4ZWREcm9wZG93bkJ1dHRvbjogeyB0eXBlOiBCb29sZWFuLCBkZWZhdWx0OiBmYWxzZSB9LAoKICAgICAgICBkZWJ1Z01vZGU6IHsgdHlwZTogQm9vbGVhbiwgZGVmYXVsdDogZmFsc2UgfQogICAgfSwKCiAgICBkYXRhKCkgewogICAgICAgIHJldHVybiB7CiAgICAgICAgICAgIHRpbWVWYWx1ZToge30sCgogICAgICAgICAgICBob3VyczogW10sCiAgICAgICAgICAgIG1pbnV0ZXM6IFtdLAogICAgICAgICAgICBzZWNvbmRzOiBbXSwKICAgICAgICAgICAgYXBtczogW10sCgogICAgICAgICAgICBpc0FjdGl2ZTogZmFsc2UsCiAgICAgICAgICAgIHNob3dEcm9wZG93bjogZmFsc2UsCiAgICAgICAgICAgIGlzRm9jdXNpbmc6IGZhbHNlLAogICAgICAgICAgICBkZWJvdW5jZVRpbWVyOiB1bmRlZmluZWQsCgogICAgICAgICAgICBob3VyVHlwZTogJ0hIJywKICAgICAgICAgICAgbWludXRlVHlwZTogJ21tJywKICAgICAgICAgICAgc2Vjb25kVHlwZTogJycsCiAgICAgICAgICAgIGFwbVR5cGU6ICcnLAogICAgICAgICAgICBob3VyOiAnJywKICAgICAgICAgICAgbWludXRlOiAnJywKICAgICAgICAgICAgc2Vjb25kOiAnJywKICAgICAgICAgICAgYXBtOiAnJywKICAgICAgICAgICAgZnVsbFZhbHVlczogdW5kZWZpbmVkLAogICAgICAgICAgICBiYWtEaXNwbGF5VGltZTogdW5kZWZpbmVkLAogICAgICAgICAgICBkb0NsZWFyQXBtQ2hlY2tpbmc6IGZhbHNlLAoKICAgICAgICAgICAgc2VsZWN0aW9uVGltZXI6IHVuZGVmaW5lZCwKICAgICAgICAgICAga2JJbnB1dFRpbWVyOiB1bmRlZmluZWQsCiAgICAgICAgICAgIGtiSW5wdXRMb2c6ICcnLAogICAgICAgICAgICBiYWtDdXJyZW50UG9zOiB1bmRlZmluZWQsCiAgICAgICAgICAgIGZvcmNlRHJvcE9uVG9wOiBmYWxzZQogICAgICAgIH0KICAgIH0sCgogICAgY29tcHV0ZWQ6IHsKICAgICAgICBvcHRzKCkgewogICAgICAgICAgICBjb25zdCBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9PUFRJT05TKQoKICAgICAgICAgICAgaWYgKHRoaXMuZm9ybWF0ICYmIHRoaXMuZm9ybWF0Lmxlbmd0aCkgewogICAgICAgICAgICAgICAgb3B0aW9ucy5mb3JtYXQgPSBTdHJpbmcodGhpcy5mb3JtYXQpCiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIGlmICh0aGlzLmlzTnVtYmVyKHRoaXMubWludXRlSW50ZXJ2YWwpKSB7CiAgICAgICAgICAgICAgICBvcHRpb25zLm1pbnV0ZUludGVydmFsID0gK3RoaXMubWludXRlSW50ZXJ2YWwKICAgICAgICAgICAgfQogICAgICAgICAgICAvLyBtaW51dGVJbnRlcnZhbCBmYWlsc2FmZQogICAgICAgICAgICBpZiAoIW9wdGlvbnMubWludXRlSW50ZXJ2YWwgfHwgb3B0aW9ucy5taW51dGVJbnRlcnZhbCA8IDEgfHwgb3B0aW9ucy5taW51dGVJbnRlcnZhbCA+IDYwKSB7CiAgICAgICAgICAgICAgICBpZiAodGhpcy5kZWJ1Z01vZGUpIHsKICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5taW51dGVJbnRlcnZhbCA+IDYwKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVidWdMb2coYCJtaW51dGUtaW50ZXJ2YWwiIHNob3VsZCBiZSBsZXNzIHRoYW4gNjAuIEN1cnJlbnQgdmFsdWUgaXMgJHt0aGlzLm1pbnV0ZUludGVydmFsfWApCiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLm1pbnV0ZUludGVydmFsID09PSAwIHx8IG9wdGlvbnMubWludXRlSW50ZXJ2YWwgPCAxKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVidWdMb2coYCJtaW51dGUtaW50ZXJ2YWwiIHNob3VsZCBiZSBOTyBsZXNzIHRoYW4gMS4gQ3VycmVudCB2YWx1ZSBpcyAke3RoaXMubWludXRlSW50ZXJ2YWx9YCkKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5taW51dGVJbnRlcnZhbCA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgIG9wdGlvbnMubWludXRlSW50ZXJ2YWwgPSA2MAogICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICBvcHRpb25zLm1pbnV0ZUludGVydmFsID0gMQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CgogICAgICAgICAgICBpZiAodGhpcy5pc051bWJlcih0aGlzLnNlY29uZEludGVydmFsKSkgewogICAgICAgICAgICAgICAgb3B0aW9ucy5zZWNvbmRJbnRlcnZhbCA9ICt0aGlzLnNlY29uZEludGVydmFsCiAgICAgICAgICAgIH0KICAgICAgICAgICAgLy8gc2Vjb25kSW50ZXJ2YWwgZmFpbHNhZmUKICAgICAgICAgICAgaWYgKCFvcHRpb25zLnNlY29uZEludGVydmFsIHx8IG9wdGlvbnMuc2Vjb25kSW50ZXJ2YWwgPCAxIHx8IG9wdGlvbnMuc2Vjb25kSW50ZXJ2YWwgPiA2MCkgewogICAgICAgICAgICAgICAgaWYgKHRoaXMuZGVidWdNb2RlKSB7CiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuc2Vjb25kSW50ZXJ2YWwgPiA2MCkgewogICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRlYnVnTG9nKGAic2Vjb25kLWludGVydmFsIiBzaG91bGQgYmUgbGVzcyB0aGFuIDYwLiBDdXJyZW50IHZhbHVlIGlzICR7dGhpcy5zZWNvbmRJbnRlcnZhbH1gKQogICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5zZWNvbmRJbnRlcnZhbCA9PT0gMCB8fCBvcHRpb25zLnNlY29uZEludGVydmFsIDwgMSkgewogICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRlYnVnTG9nKGAic2Vjb25kLWludGVydmFsIiBzaG91bGQgYmUgTk8gbGVzcyB0aGFuIDEuIEN1cnJlbnQgdmFsdWUgaXMgJHt0aGlzLnNlY29uZEludGVydmFsfWApCiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuc2Vjb25kSW50ZXJ2YWwgPT09IDApIHsKICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnNlY29uZEludGVydmFsID0gNjAKICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5zZWNvbmRJbnRlcnZhbCA9IDEKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQoKICAgICAgICAgICAgaWYgKHRoaXMuaG91clJhbmdlICYmIEFycmF5LmlzQXJyYXkodGhpcy5ob3VyUmFuZ2UpKSB7CiAgICAgICAgICAgICAgICBvcHRpb25zLmhvdXJSYW5nZSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodGhpcy5ob3VyUmFuZ2UpKQogICAgICAgICAgICAgICAgaWYgKCF0aGlzLmhvdXJSYW5nZS5sZW5ndGggJiYgdGhpcy5kZWJ1Z01vZGUpIHsKICAgICAgICAgICAgICAgICAgICB0aGlzLmRlYnVnTG9nKCdUaGUgImhvdXItcmFuZ2UiIGFycmF5IGlzIGVtcHR5IChsZW5ndGggPT09IDApJykKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQoKICAgICAgICAgICAgaWYgKHRoaXMubWludXRlUmFuZ2UgJiYgQXJyYXkuaXNBcnJheSh0aGlzLm1pbnV0ZVJhbmdlKSkgewogICAgICAgICAgICAgICAgb3B0aW9ucy5taW51dGVSYW5nZSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodGhpcy5taW51dGVSYW5nZSkpCiAgICAgICAgICAgICAgICBpZiAoIXRoaXMubWludXRlUmFuZ2UubGVuZ3RoICYmIHRoaXMuZGVidWdNb2RlKSB7CiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWJ1Z0xvZygnVGhlICJtaW51dGUtcmFuZ2UiIGFycmF5IGlzIGVtcHR5IChsZW5ndGggPT09IDApJykKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQoKICAgICAgICAgICAgaWYgKHRoaXMuc2Vjb25kUmFuZ2UgJiYgQXJyYXkuaXNBcnJheSh0aGlzLnNlY29uZFJhbmdlKSkgewogICAgICAgICAgICAgICAgb3B0aW9ucy5zZWNvbmRSYW5nZSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodGhpcy5zZWNvbmRSYW5nZSkpCiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuc2Vjb25kUmFuZ2UubGVuZ3RoICYmIHRoaXMuZGVidWdNb2RlKSB7CiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWJ1Z0xvZygnVGhlICJzZWNvbmQtcmFuZ2UiIGFycmF5IGlzIGVtcHR5IChsZW5ndGggPT09IDApJykKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQoKICAgICAgICAgICAgaWYgKHRoaXMuaGlkZURpc2FibGVkSXRlbXMpIHsKICAgICAgICAgICAgICAgIG9wdGlvbnMuaGlkZURpc2FibGVkSXRlbXMgPSB0cnVlCiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIGlmICh0aGlzLmhpZGVEaXNhYmxlZEhvdXJzIHx8IHRoaXMuaGlkZURpc2FibGVkSXRlbXMpIHsKICAgICAgICAgICAgICAgIG9wdGlvbnMuaGlkZURpc2FibGVkSG91cnMgPSB0cnVlCiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKHRoaXMuaGlkZURpc2FibGVkTWludXRlcyB8fCB0aGlzLmhpZGVEaXNhYmxlZEl0ZW1zKSB7CiAgICAgICAgICAgICAgICBvcHRpb25zLmhpZGVEaXNhYmxlZE1pbnV0ZXMgPSB0cnVlCiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKHRoaXMuaGlkZURpc2FibGVkU2Vjb25kcyB8fCB0aGlzLmhpZGVEaXNhYmxlZEl0ZW1zKSB7CiAgICAgICAgICAgICAgICBvcHRpb25zLmhpZGVEaXNhYmxlZFNlY29uZHMgPSB0cnVlCiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIGlmICh0aGlzLmhpZGVEcm9wZG93bikgewogICAgICAgICAgICAgICAgaWYgKHRoaXMubWFudWFsSW5wdXQpIHsKICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmhpZGVEcm9wZG93biA9IHRydWUKICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5kZWJ1Z01vZGUpIHsKICAgICAgICAgICAgICAgICAgICB0aGlzLmRlYnVnTG9nKCciaGlkZS1kcm9wZG93biIgb25seSB3b3JrcyB3aXRoICJtYW51YWwtaW5wdXQiIG1vZGUnKQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CgogICAgICAgICAgICBpZiAodGhpcy5ibHVyRGVsYXkgJiYgK3RoaXMuYmx1ckRlbGF5ID4gMCkgewogICAgICAgICAgICAgICAgb3B0aW9ucy5ibHVyRGVsYXkgPSArdGhpcy5ibHVyRGVsYXkKICAgICAgICAgICAgfQoKICAgICAgICAgICAgaWYgKHRoaXMubWFudWFsSW5wdXRUaW1lb3V0ICYmICt0aGlzLm1hbnVhbElucHV0VGltZW91dCA+IDApIHsKICAgICAgICAgICAgICAgIG9wdGlvbnMubWFudWFsSW5wdXRUaW1lb3V0ID0gK3RoaXMubWFudWFsSW5wdXRUaW1lb3V0CiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIGlmICh0aGlzLmRyb3BPZmZzZXRIZWlnaHQgJiYgK3RoaXMuZHJvcE9mZnNldEhlaWdodCA+IDApIHsKICAgICAgICAgICAgICAgIG9wdGlvbnMuZHJvcE9mZnNldEhlaWdodCA9ICt0aGlzLmRyb3BPZmZzZXRIZWlnaHQKICAgICAgICAgICAgfQoKICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMKICAgICAgICB9LAoKICAgICAgICB1c2VTdHJpbmdWYWx1ZSgpIHsKICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiB0aGlzLnZhbHVlID09PSAnc3RyaW5nJwogICAgICAgIH0sCgogICAgICAgIGZvcm1hdFN0cmluZygpIHsKICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0cy5mb3JtYXQgfHwgREVGQVVMVF9PUFRJT05TLmZvcm1hdAogICAgICAgIH0sCgogICAgICAgIGluVXNlKCkgewogICAgICAgICAgICBjb25zdCB0eXBlc0luVXNlID0gQ09ORklHLkJBU0lDX1RZUEVTLmZpbHRlcih0eXBlID0+IHRoaXMuZ2V0VG9rZW5CeVR5cGUodHlwZSkpCiAgICAgICAgICAgIC8vIFNvcnQgdHlwZXMgYW5kIHRva2VucyBieSB0aGVpciBzZXF1ZW5jZSBpbiB0aGUgImZvcm1hdCIgc3RyaW5nCiAgICAgICAgICAgIHR5cGVzSW5Vc2Uuc29ydCgobCwgcikgPT4gewogICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0U3RyaW5nLmluZGV4T2YodGhpcy5nZXRUb2tlbkJ5VHlwZShsKSB8fCBudWxsKSAtIHRoaXMuZm9ybWF0U3RyaW5nLmluZGV4T2YodGhpcy5nZXRUb2tlbkJ5VHlwZShyKSB8fCBudWxsKQogICAgICAgICAgICB9KQogICAgICAgICAgICBjb25zdCB0b2tlbnNJblVzZSA9IHR5cGVzSW5Vc2UubWFwKHR5cGUgPT4gdGhpcy5nZXRUb2tlbkJ5VHlwZSh0eXBlKSkKICAgICAgICAgICAgcmV0dXJuIHsKICAgICAgICAgICAgICAgIGhvdXI6ICEhdGhpcy5ob3VyVHlwZSwKICAgICAgICAgICAgICAgIG1pbnV0ZTogISF0aGlzLm1pbnV0ZVR5cGUsCiAgICAgICAgICAgICAgICBzZWNvbmQ6ICEhdGhpcy5zZWNvbmRUeXBlLAogICAgICAgICAgICAgICAgYXBtOiAhIXRoaXMuYXBtVHlwZSwKICAgICAgICAgICAgICAgIHR5cGVzOiB0eXBlc0luVXNlIHx8IFtdLAogICAgICAgICAgICAgICAgdG9rZW5zOiB0b2tlbnNJblVzZSB8fCBbXQogICAgICAgICAgICB9CiAgICAgICAgfSwKCiAgICAgICAgZGlzcGxheVRpbWUoKSB7CiAgICAgICAgICAgIGxldCBmb3JtYXRTdHJpbmcgPSBTdHJpbmcodGhpcy5mb3JtYXRTdHJpbmcpCiAgICAgICAgICAgIGlmICh0aGlzLmhvdXIpIHsKICAgICAgICAgICAgICAgIGZvcm1hdFN0cmluZyA9IGZvcm1hdFN0cmluZy5yZXBsYWNlKG5ldyBSZWdFeHAodGhpcy5ob3VyVHlwZSwgJ2cnKSwgdGhpcy5ob3VyKQogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmICh0aGlzLm1pbnV0ZSkgewogICAgICAgICAgICAgICAgZm9ybWF0U3RyaW5nID0gZm9ybWF0U3RyaW5nLnJlcGxhY2UobmV3IFJlZ0V4cCh0aGlzLm1pbnV0ZVR5cGUsICdnJyksIHRoaXMubWludXRlKQogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmICh0aGlzLnNlY29uZCAmJiB0aGlzLnNlY29uZFR5cGUpIHsKICAgICAgICAgICAgICAgIGZvcm1hdFN0cmluZyA9IGZvcm1hdFN0cmluZy5yZXBsYWNlKG5ldyBSZWdFeHAodGhpcy5zZWNvbmRUeXBlLCAnZycpLCB0aGlzLnNlY29uZCkKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAodGhpcy5hcG0gJiYgdGhpcy5hcG1UeXBlKSB7CiAgICAgICAgICAgICAgICBmb3JtYXRTdHJpbmcgPSBmb3JtYXRTdHJpbmcucmVwbGFjZShuZXcgUmVnRXhwKHRoaXMuYXBtVHlwZSwgJ2cnKSwgdGhpcy5hcG0pCiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIGZvcm1hdFN0cmluZwogICAgICAgIH0sCgogICAgICAgIGN1c3RvbURpc3BsYXlUaW1lKCkgewogICAgICAgICAgICBpZiAoIXRoaXMuYW1UZXh0ICYmICF0aGlzLnBtVGV4dCkgewogICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGlzcGxheVRpbWUKICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gdGhpcy5kaXNwbGF5VGltZS5yZXBsYWNlKG5ldyBSZWdFeHAodGhpcy5hcG0sICdnJyksIHRoaXMuYXBtRGlzcGxheVRleHQodGhpcy5hcG0pKQogICAgICAgIH0sCgogICAgICAgIGlucHV0SXNFbXB0eSgpIHsKICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0U3RyaW5nID09PSB0aGlzLmRpc3BsYXlUaW1lCiAgICAgICAgfSwKCiAgICAgICAgYWxsVmFsdWVTZWxlY3RlZCgpIHsKICAgICAgICAgICAgaWYgKAogICAgICAgICAgICAgICAgKHRoaXMuaW5Vc2UuaG91ciAmJiAhdGhpcy5ob3VyKSB8fAogICAgICAgICAgICAgICAgKHRoaXMuaW5Vc2UubWludXRlICYmICF0aGlzLm1pbnV0ZSkgfHwKICAgICAgICAgICAgICAgICh0aGlzLmluVXNlLnNlY29uZCAmJiAhdGhpcy5zZWNvbmQpIHx8CiAgICAgICAgICAgICAgICAodGhpcy5pblVzZS5hcG0gJiYgIXRoaXMuYXBtKQogICAgICAgICAgICApIHsKICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZQogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiB0cnVlCiAgICAgICAgfSwKCiAgICAgICAgY29sdW1uc1NlcXVlbmNlKCkgewogICAgICAgICAgICByZXR1cm4gdGhpcy5pblVzZS50eXBlcy5tYXAodHlwZSA9PiB0eXBlKSB8fCBbXQogICAgICAgIH0sCgogICAgICAgIHNob3dDbGVhckJ0bigpIHsKICAgICAgICAgICAgaWYgKHRoaXMuaGlkZUNsZWFyQnV0dG9uIHx8IHRoaXMuZGlzYWJsZWQpIHsKICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZQogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiAhdGhpcy5pbnB1dElzRW1wdHkKICAgICAgICB9LAoKICAgICAgICBzaG93RHJvcGRvd25CdG4oKSB7CiAgICAgICAgICAgIGlmICh0aGlzLmZpeGVkRHJvcGRvd25CdXR0b24pIHsgcmV0dXJuIHRydWUgfQogICAgICAgICAgICBpZiAodGhpcy5vcHRzLmhpZGVEcm9wZG93biAmJiB0aGlzLmlzQWN0aXZlICYmICF0aGlzLnNob3dEcm9wZG93bikgewogICAgICAgICAgICAgICAgcmV0dXJuIHRydWUKICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gZmFsc2UKICAgICAgICB9LAoKICAgICAgICBiYXNlT24xMkhvdXJzKCkgewogICAgICAgICAgICByZXR1cm4gdGhpcy5ob3VyVHlwZSA9PT0gJ2gnIHx8IHRoaXMuaG91clR5cGUgPT09ICdoaCcKICAgICAgICB9LAoKICAgICAgICBob3VyUmFuZ2VJbjI0SHJGb3JtYXQoKSB7CiAgICAgICAgICAgIGlmICghdGhpcy5ob3VyVHlwZSB8fCAhdGhpcy5vcHRzLmhvdXJSYW5nZSkgeyByZXR1cm4gZmFsc2UgfQogICAgICAgICAgICBpZiAoIXRoaXMub3B0cy5ob3VyUmFuZ2UubGVuZ3RoKSB7IHJldHVybiBbXSB9CgogICAgICAgICAgICBjb25zdCByYW5nZSA9IFtdCiAgICAgICAgICAgIHRoaXMub3B0cy5ob3VyUmFuZ2UuZm9yRWFjaCh2YWx1ZSA9PiB7CiAgICAgICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBBcnJheSkgewogICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPiAyICYmIHRoaXMuZGVidWdNb2RlKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVidWdMb2coYE5lc3RlZCBhcnJheSB3aXRoaW4gImhvdXItcmFuZ2UiIG11c3QgY29udGFpbiBubyBtb3JlIHRoYW4gdHdvIGl0ZW1zLiBPbmx5IHRoZSBmaXJzdCB0d28gaXRlbXMgb2YgJHtKU09OLnN0cmluZ2lmeSh2YWx1ZSl9IHdpbGwgYmUgdGFrZW4gaW50byBhY2NvdW50LmApCiAgICAgICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgICAgICBsZXQgc3RhcnQgPSB2YWx1ZVswXQogICAgICAgICAgICAgICAgICAgIGxldCBlbmQgPSB2YWx1ZVsxXSB8fCB2YWx1ZVswXQoKICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pczEyaFJhbmdlKHN0YXJ0KSkgewogICAgICAgICAgICAgICAgICAgICAgICBzdGFydCA9IHRoaXMudHJhbnNsYXRlMTJoUmFuZ2Uoc3RhcnQpCiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzMTJoUmFuZ2UoZW5kKSkgewogICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSB0aGlzLnRyYW5zbGF0ZTEyaFJhbmdlKGVuZCkKICAgICAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSArc3RhcnQ7IGkgPD0gK2VuZDsgaSsrKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpIDwgMCB8fCBpID4gMjQpIHsgY29udGludWUgfQogICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJhbmdlLmluY2x1ZGVzKGkpKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICByYW5nZS5wdXNoKGkpCiAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzMTJoUmFuZ2UodmFsdWUpKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy50cmFuc2xhdGUxMmhSYW5nZSh2YWx1ZSkKICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9ICt2YWx1ZQogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPCAwIHx8IHZhbHVlID4gMjQpIHsgcmV0dXJuIH0KICAgICAgICAgICAgICAgICAgICBpZiAoIXJhbmdlLmluY2x1ZGVzKHZhbHVlKSkgewogICAgICAgICAgICAgICAgICAgICAgICByYW5nZS5wdXNoKHZhbHVlKQogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSkKICAgICAgICAgICAgcmFuZ2Uuc29ydCgobCwgcikgPT4geyByZXR1cm4gbCAtIHIgfSkKICAgICAgICAgICAgcmV0dXJuIHJhbmdlCiAgICAgICAgfSwKCiAgICAgICAgcmVzdHJpY3RlZEhvdXJSYW5nZSgpIHsKICAgICAgICAgICAgLy8gTm8gcmVzdHJpY3Rpb24KICAgICAgICAgICAgaWYgKCF0aGlzLmhvdXJSYW5nZUluMjRIckZvcm1hdCkgeyByZXR1cm4gZmFsc2UgfQogICAgICAgICAgICAvLyAxMi1Ib3VyCiAgICAgICAgICAgIGlmICh0aGlzLmJhc2VPbjEySG91cnMpIHsKICAgICAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gdGhpcy5ob3VyUmFuZ2VJbjI0SHJGb3JtYXQubWFwKCh2YWx1ZSkgPT4gewogICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gMTIpIHsKICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICcxMnAnCiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gMjQgfHwgdmFsdWUgPT09IDApIHsKICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICcxMmEnCiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSA+IDEyID8gYCR7dmFsdWUgJSAxMn1wYCA6IGAke3ZhbHVlfWFgCiAgICAgICAgICAgICAgICB9KQogICAgICAgICAgICAgICAgcmV0dXJuIHJhbmdlCiAgICAgICAgICAgIH0KICAgICAgICAgICAgLy8gMjQtSG91cgogICAgICAgICAgICByZXR1cm4gdGhpcy5ob3VyUmFuZ2VJbjI0SHJGb3JtYXQKICAgICAgICB9LAoKICAgICAgICB2YWxpZEhvdXJzTGlzdCgpIHsKICAgICAgICAgICAgaWYgKCF0aGlzLm1hbnVhbElucHV0KSB7IHJldHVybiBmYWxzZSB9CiAgICAgICAgICAgIGlmICh0aGlzLnJlc3RyaWN0ZWRIb3VyUmFuZ2UpIHsKICAgICAgICAgICAgICAgIGxldCBsaXN0ID0gW10KICAgICAgICAgICAgICAgIGlmICh0aGlzLmJhc2VPbjEySG91cnMpIHsKICAgICAgICAgICAgICAgICAgICBsaXN0ID0gdGhpcy5yZXN0cmljdGVkSG91clJhbmdlLm1hcChociA9PiB7CiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGwgPSBoci5zdWJzdHIoMCwgaHIubGVuZ3RoIC0gMSkKICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgciA9IGhyLnN1YnN0cigtMSkKICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGAke3RoaXMuZm9ybWF0VmFsdWUodGhpcy5ob3VyVHlwZSwgbCl9JHtyfWAKICAgICAgICAgICAgICAgICAgICB9KQogICAgICAgICAgICAgICAgICAgIGNvbnN0IGFtMTJJbmRleCA9IGxpc3QuaW5kZXhPZignMTJhJykKICAgICAgICAgICAgICAgICAgICBpZiAoYW0xMkluZGV4ID4gMCkgewogICAgICAgICAgICAgICAgICAgICAgICAvLyBNYWtlICcxMmEnIHRoZSBmaXJzdCBpdGVtIGluIGgvaGgKICAgICAgICAgICAgICAgICAgICAgICAgbGlzdC51bnNoaWZ0KGxpc3Quc3BsaWNlKGFtMTJJbmRleCwgMSlbMF0pCiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIHJldHVybiBsaXN0CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBsaXN0ID0gdGhpcy5yZXN0cmljdGVkSG91clJhbmdlLm1hcChociA9PiB7CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0VmFsdWUodGhpcy5ob3VyVHlwZSwgaHIpCiAgICAgICAgICAgICAgICB9KQogICAgICAgICAgICAgICAgaWYgKGxpc3QubGVuZ3RoID4gMSAmJiBsaXN0WzBdICYmIGxpc3RbMF0gPT09ICcyNCcpIHsKICAgICAgICAgICAgICAgICAgICAvLyBNYWtlICcyNCcgdGhlIGxhc3QgaXRlbSBpbiBrL2trCiAgICAgICAgICAgICAgICAgICAgbGlzdC5wdXNoKGxpc3Quc2hpZnQoKSkKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHJldHVybiBsaXN0CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKHRoaXMuYmFzZU9uMTJIb3VycykgewogICAgICAgICAgICAgICAgcmV0dXJuIFtdLmNvbmNhdChbXSwgdGhpcy5ob3Vycy5tYXAoaHIgPT4gYCR7aHJ9YWApLCB0aGlzLmhvdXJzLm1hcChociA9PiBgJHtocn1wYCkpCiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIHRoaXMuaG91cnMKICAgICAgICB9LAoKICAgICAgICBoYXMoKSB7CiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHsKICAgICAgICAgICAgICAgIGN1c3RvbUFwbVRleHQ6IGZhbHNlCiAgICAgICAgICAgIH0KICAgICAgICAgICAgY29uc3QgYXBtRW5hYmxlZCA9ICEhdGhpcy5hcG1UeXBlCgogICAgICAgICAgICBpZiAoYXBtRW5hYmxlZCAmJiB0aGlzLmhvdXJSYW5nZUluMjRIckZvcm1hdCAmJiB0aGlzLmhvdXJSYW5nZUluMjRIckZvcm1hdC5sZW5ndGgpIHsKICAgICAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gW10uY29uY2F0KFtdLCB0aGlzLmhvdXJSYW5nZUluMjRIckZvcm1hdCkKICAgICAgICAgICAgICAgIHJlc3VsdC5hbSA9IHJhbmdlLnNvbWUodmFsdWUgPT4gdmFsdWUgPCAxMiB8fCB2YWx1ZSA9PT0gMjQpCiAgICAgICAgICAgICAgICByZXN1bHQucG0gPSByYW5nZS5zb21lKHZhbHVlID0+IHZhbHVlID49IDEyICYmIHZhbHVlIDwgMjQpCiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICByZXN1bHQuYW0gPSBhcG1FbmFibGVkCiAgICAgICAgICAgICAgICByZXN1bHQucG0gPSBhcG1FbmFibGVkCiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKCh0aGlzLmFtVGV4dCAmJiB0aGlzLmFtVGV4dC5sZW5ndGgpIHx8ICh0aGlzLnBtVGV4dCAmJiB0aGlzLnBtVGV4dC5sZW5ndGgpKSB7CiAgICAgICAgICAgICAgICByZXN1bHQuY3VzdG9tQXBtVGV4dCA9IHRydWUKICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gcmVzdWx0CiAgICAgICAgfSwKCiAgICAgICAgbWludXRlUmFuZ2VMaXN0KCkgewogICAgICAgICAgICBpZiAoIXRoaXMubWludXRlVHlwZSB8fCAhdGhpcy5vcHRzLm1pbnV0ZVJhbmdlKSB7IHJldHVybiBmYWxzZSB9CiAgICAgICAgICAgIGlmICghdGhpcy5vcHRzLm1pbnV0ZVJhbmdlLmxlbmd0aCkgeyByZXR1cm4gW10gfQogICAgICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJSYW5nZUxpc3QodGhpcy5vcHRzLm1pbnV0ZVJhbmdlLCAnbWludXRlJykKICAgICAgICB9LAoKICAgICAgICBzZWNvbmRSYW5nZUxpc3QoKSB7CiAgICAgICAgICAgIGlmICghdGhpcy5zZWNvbmRUeXBlIHx8ICF0aGlzLm9wdHMuc2Vjb25kUmFuZ2UpIHsgcmV0dXJuIGZhbHNlIH0KICAgICAgICAgICAgaWYgKCF0aGlzLm9wdHMuc2Vjb25kUmFuZ2UubGVuZ3RoKSB7IHJldHVybiBbXSB9CiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbmRlclJhbmdlTGlzdCh0aGlzLm9wdHMuc2Vjb25kUmFuZ2UsICdzZWNvbmQnKQogICAgICAgIH0sCgogICAgICAgIGhvdXJMYWJlbFRleHQoKSB7CiAgICAgICAgICAgIHJldHVybiB0aGlzLmhvdXJMYWJlbCB8fCB0aGlzLmhvdXJUeXBlCiAgICAgICAgfSwKICAgICAgICBtaW51dGVMYWJlbFRleHQoKSB7CiAgICAgICAgICAgIHJldHVybiB0aGlzLm1pbnV0ZUxhYmVsIHx8IHRoaXMubWludXRlVHlwZQogICAgICAgIH0sCiAgICAgICAgc2Vjb25kTGFiZWxUZXh0KCkgewogICAgICAgICAgICByZXR1cm4gdGhpcy5zZWNvbmRMYWJlbCB8fCB0aGlzLnNlY29uZFR5cGUKICAgICAgICB9LAogICAgICAgIGFwbUxhYmVsVGV4dCgpIHsKICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXBtTGFiZWwgfHwgdGhpcy5hcG1UeXBlCiAgICAgICAgfSwKCiAgICAgICAgaW5wdXRXaWR0aFN0eWxlKCkgewogICAgICAgICAgICBpZiAoIXRoaXMuaW5wdXRXaWR0aCB8fCAhdGhpcy5pbnB1dFdpZHRoLmxlbmd0aCkgeyByZXR1cm4gfQogICAgICAgICAgICByZXR1cm4gewogICAgICAgICAgICAgICAgd2lkdGg6IHRoaXMuaW5wdXRXaWR0aAogICAgICAgICAgICB9CiAgICAgICAgfSwKCiAgICAgICAgdG9rZW5SZWdleEJhc2UoKSB7CiAgICAgICAgICAgIHJldHVybiB0aGlzLmluVXNlLnRva2Vucy5qb2luKCd8JykKICAgICAgICB9LAoKICAgICAgICB0b2tlbkNodW5rcygpIHsKICAgICAgICAgICAgaWYgKCF0aGlzLm1hbnVhbElucHV0ICYmICF0aGlzLnVzZVN0cmluZ1ZhbHVlKSB7IHJldHVybiBmYWxzZSB9CgogICAgICAgICAgICBjb25zdCBmb3JtYXRTdHJpbmcgPSBTdHJpbmcodGhpcy5mb3JtYXRTdHJpbmcpCiAgICAgICAgICAgIGNvbnN0IHRva2Vuc1JlZ3hTdHIgPSBgKCR7dGhpcy50b2tlblJlZ2V4QmFzZX0pKz9gCiAgICAgICAgICAgIGNvbnN0IHRva2Vuc01hdGNoQWxsID0gdGhpcy5nZXRNYXRjaEFsbEJ5UmVnZXgoZm9ybWF0U3RyaW5nLCB0b2tlbnNSZWd4U3RyKQoKICAgICAgICAgICAgY29uc3QgdG9rZW5DaHVua3MgPSBbXQogICAgICAgICAgICBmb3IgKGxldCB0a01hdGNoIG9mIHRva2Vuc01hdGNoQWxsKSB7CiAgICAgICAgICAgICAgICBjb25zdCByYXdUb2tlbiA9IHRrTWF0Y2hbMF0KICAgICAgICAgICAgICAgIGNvbnN0IHRva2VuTWF0Y2hJdGVtID0gewogICAgICAgICAgICAgICAgICAgIGluZGV4OiB0a01hdGNoLmluZGV4LAogICAgICAgICAgICAgICAgICAgIHRva2VuOiByYXdUb2tlbiwKICAgICAgICAgICAgICAgICAgICB0eXBlOiB0aGlzLmdldFRva2VuVHlwZShyYXdUb2tlbiksCiAgICAgICAgICAgICAgICAgICAgbmVlZHNDYWxpYnJhdGU6IHJhd1Rva2VuLmxlbmd0aCA8IDIsCiAgICAgICAgICAgICAgICAgICAgbGVuOiAocmF3VG9rZW4gfHwgJycpLmxlbmd0aAogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgdG9rZW5DaHVua3MucHVzaCh0b2tlbk1hdGNoSXRlbSkKICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gdG9rZW5DaHVua3MKICAgICAgICB9LAoKICAgICAgICBuZWVkc1Bvc0NhbGlicmF0ZSgpIHsKICAgICAgICAgICAgaWYgKCF0aGlzLm1hbnVhbElucHV0KSB7IHJldHVybiBmYWxzZSB9CiAgICAgICAgICAgIHJldHVybiB0aGlzLnRva2VuQ2h1bmtzLnNvbWUoY2hrID0+IGNoay5uZWVkc0NhbGlicmF0ZSkKICAgICAgICB9LAoKICAgICAgICB0b2tlbkNodW5rc1BvcygpIHsKICAgICAgICAgICAgaWYgKCF0aGlzLm1hbnVhbElucHV0KSB7IHJldHVybiBmYWxzZSB9CiAgICAgICAgICAgIGlmICghdGhpcy5uZWVkc1Bvc0NhbGlicmF0ZSkgewogICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9rZW5DaHVua3MubWFwKGNoayA9PiB7CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsKICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW46IGNoay50b2tlbiwKICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogY2hrLnR5cGUsCiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBjaGsuaW5kZXgsCiAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogY2hrLmluZGV4ICsgY2hrLmxlbgogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0pCiAgICAgICAgICAgIH0KICAgICAgICAgICAgY29uc3QgbGlzdCA9IFtdCiAgICAgICAgICAgIGxldCBjYWxpYnJhdGVMZW4gPSAwCiAgICAgICAgICAgIHRoaXMudG9rZW5DaHVua3MuZm9yRWFjaChjaGsgPT4gewogICAgICAgICAgICAgICAgbGV0IGNodW5rQ3VycmVudExlbgogICAgICAgICAgICAgICAgLy8gQWRqdXN0IGZvciBjdXN0b21pemVkIEFNL1BNIHRleHQKICAgICAgICAgICAgICAgIGlmIChjaGsudHlwZSA9PT0gJ2FwbScgJiYgdGhpcy5oYXMuY3VzdG9tQXBtVGV4dCkgewogICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmFwbSAmJiB0aGlzLmFwbS5sZW5ndGgpIHsKICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VzdG9tQXBtVGV4dCA9IHRoaXMuYXBtLnRvTG93ZXJDYXNlKCkgPT09ICdhbScgPyB0aGlzLmFtVGV4dCA6IHRoaXMucG1UZXh0CiAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rQ3VycmVudExlbiA9IChjdXN0b21BcG1UZXh0ICYmIGN1c3RvbUFwbVRleHQubGVuZ3RoKSA/IGN1c3RvbUFwbVRleHQubGVuZ3RoIDogY2hrLmxlbgogICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rQ3VycmVudExlbiA9IGNoay5sZW4KICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXJzCiAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgIGNodW5rQ3VycmVudExlbiA9IHRoaXNbY2hrLnR5cGVdICYmIHRoaXNbY2hrLnR5cGVdLmxlbmd0aCA/IHRoaXNbY2hrLnR5cGVdLmxlbmd0aCA6IGNoay5sZW4KICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGxpc3QucHVzaCh7CiAgICAgICAgICAgICAgICAgICAgdG9rZW46IGNoay50b2tlbiwKICAgICAgICAgICAgICAgICAgICB0eXBlOiBjaGsudHlwZSwKICAgICAgICAgICAgICAgICAgICBzdGFydDogY2hrLmluZGV4ICsgY2FsaWJyYXRlTGVuLAogICAgICAgICAgICAgICAgICAgIGVuZDogY2hrLmluZGV4ICsgY2FsaWJyYXRlTGVuICsgY2h1bmtDdXJyZW50TGVuCiAgICAgICAgICAgICAgICB9KQogICAgICAgICAgICAgICAgaWYgKGNoay5uZWVkc0NhbGlicmF0ZSAmJiBjaHVua0N1cnJlbnRMZW4gPiBjaGsubGVuKSB7CiAgICAgICAgICAgICAgICAgICAgY2FsaWJyYXRlTGVuICs9IChjaHVua0N1cnJlbnRMZW4gLSBjaGsubGVuKQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9KQogICAgICAgICAgICByZXR1cm4gbGlzdAogICAgICAgIH0sCgogICAgICAgIGludmFsaWRWYWx1ZXMoKSB7CiAgICAgICAgICAgIGlmICh0aGlzLmlucHV0SXNFbXB0eSkgeyByZXR1cm4gW10gfQogICAgICAgICAgICBpZiAoIXRoaXMucmVzdHJpY3RlZEhvdXJSYW5nZSAmJiAhdGhpcy5taW51dGVSYW5nZUxpc3QgJiYgIXRoaXMuc2Vjb25kUmFuZ2VMaXN0ICYmIHRoaXMub3B0cy5taW51dGVJbnRlcnZhbCA9PT0gMSAmJiB0aGlzLm9wdHMuc2Vjb25kSW50ZXJ2YWwgPT09IDEpIHsgcmV0dXJuIFtdIH0KCiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdCiAgICAgICAgICAgIGlmICh0aGlzLmluVXNlLmhvdXIgJiYgIXRoaXMuaXNFbXB0eVZhbHVlKHRoaXMuaG91clR5cGUsIHRoaXMuaG91cikgJiYgKCF0aGlzLmlzVmFsaWRWYWx1ZSh0aGlzLmhvdXJUeXBlLCB0aGlzLmhvdXIpIHx8IHRoaXMuaXNEaXNhYmxlZCgnaG91cicsIHRoaXMuaG91cikpKSB7CiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnaG91cicpCiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKHRoaXMuaW5Vc2UubWludXRlICYmICF0aGlzLmlzRW1wdHlWYWx1ZSh0aGlzLm1pbnV0ZVR5cGUsIHRoaXMubWludXRlKSAmJiAoIXRoaXMuaXNWYWxpZFZhbHVlKHRoaXMubWludXRlVHlwZSwgdGhpcy5taW51dGUpIHx8IHRoaXMuaXNEaXNhYmxlZCgnbWludXRlJywgdGhpcy5taW51dGUpIHx8IHRoaXMubm90SW5JbnRlcnZhbCgnbWludXRlJywgdGhpcy5taW51dGUpKSkgewogICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goJ21pbnV0ZScpCiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKHRoaXMuaW5Vc2Uuc2Vjb25kICYmICF0aGlzLmlzRW1wdHlWYWx1ZSh0aGlzLnNlY29uZFR5cGUsIHRoaXMuc2Vjb25kKSAmJiAoIXRoaXMuaXNWYWxpZFZhbHVlKHRoaXMuc2Vjb25kVHlwZSwgdGhpcy5zZWNvbmQpIHx8IHRoaXMuaXNEaXNhYmxlZCgnc2Vjb25kJywgdGhpcy5zZWNvbmQpIHx8IHRoaXMubm90SW5JbnRlcnZhbCgnc2Vjb25kJywgdGhpcy5zZWNvbmQpKSkgewogICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goJ3NlY29uZCcpCiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKHRoaXMuaW5Vc2UuYXBtICYmICF0aGlzLmlzRW1wdHlWYWx1ZSh0aGlzLmFwbVR5cGUsIHRoaXMuYXBtKSAmJiAoIXRoaXMuaXNWYWxpZFZhbHVlKHRoaXMuYXBtVHlwZSwgdGhpcy5hcG0pIHx8IHRoaXMuaXNEaXNhYmxlZCgnYXBtJywgdGhpcy5hcG0pKSkgewogICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goJ2FwbScpCiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGgpIHsKICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQKICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gW10KICAgICAgICB9LAoKICAgICAgICBoYXNJbnZhbGlkSW5wdXQoKSB7CiAgICAgICAgICAgIHJldHVybiBCb29sZWFuKHRoaXMuaW52YWxpZFZhbHVlcyAmJiB0aGlzLmludmFsaWRWYWx1ZXMubGVuZ3RoKQogICAgICAgIH0sCgogICAgICAgIGF1dG9EaXJlY3Rpb25FbmFibGVkKCkgewogICAgICAgICAgICByZXR1cm4gdGhpcy5kcm9wRGlyZWN0aW9uID09PSAnYXV0bycKICAgICAgICB9LAoKICAgICAgICBkcm9wZG93bkRpckNsYXNzKCkgewogICAgICAgICAgICBpZiAodGhpcy5hdXRvRGlyZWN0aW9uRW5hYmxlZCkgewogICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm9yY2VEcm9wT25Ub3AgPyAnZHJvcC11cCcgOiAnZHJvcC1kb3duJwogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiB0aGlzLmRyb3BEaXJlY3Rpb24gPT09ICd1cCcgPyAnZHJvcC11cCcgOiAnZHJvcC1kb3duJwogICAgICAgIH0KICAgIH0sCgogICAgd2F0Y2g6IHsKICAgICAgICAnb3B0cy5mb3JtYXQnKG5ld1ZhbHVlKSB7CiAgICAgICAgICAgIHRoaXMucmVuZGVyRm9ybWF0KG5ld1ZhbHVlKQogICAgICAgIH0sCiAgICAgICAgJ29wdHMubWludXRlSW50ZXJ2YWwnKG5ld0ludGV2YWwpIHsKICAgICAgICAgICAgdGhpcy5yZW5kZXJMaXN0KCdtaW51dGUnLCBuZXdJbnRldmFsKQogICAgICAgIH0sCiAgICAgICAgJ29wdHMuc2Vjb25kSW50ZXJ2YWwnKG5ld0ludGV2YWwpIHsKICAgICAgICAgICAgdGhpcy5yZW5kZXJMaXN0KCdzZWNvbmQnLCBuZXdJbnRldmFsKQogICAgICAgIH0sCiAgICAgICAgdmFsdWU6IHsKICAgICAgICAgICAgZGVlcDogdHJ1ZSwKICAgICAgICAgICAgaGFuZGxlcigpIHsKICAgICAgICAgICAgICAgIHRoaXMucmVhZFZhbHVlcygpCiAgICAgICAgICAgIH0KICAgICAgICB9LAogICAgICAgIGRpc3BsYXlUaW1lKCkgewogICAgICAgICAgICB0aGlzLmZpbGxWYWx1ZXMoKQogICAgICAgIH0sCiAgICAgICAgZGlzYWJsZWQodG9EaXNhYmxlZCkgewogICAgICAgICAgICBpZiAodG9EaXNhYmxlZCkgewogICAgICAgICAgICAgICAgLy8gRm9yY2UgY2xvc2UgZHJvcGRvd24gYW5kIHJlc2V0IHN0YXR1cyB3aGVuIGRpc2FibGVkCiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0FjdGl2ZSkgewogICAgICAgICAgICAgICAgICAgIHRoaXMuaXNBY3RpdmUgPSBmYWxzZQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKHRoaXMuc2hvd0Ryb3Bkb3duKSB7CiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaG93RHJvcGRvd24gPSBmYWxzZQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgfSwKICAgICAgICAnaW52YWxpZFZhbHVlcy5sZW5ndGgnKG5ld0xlbmd0aCwgb2xkTGVuZ3RoKSB7CiAgICAgICAgICAgIGlmIChuZXdMZW5ndGggJiYgbmV3TGVuZ3RoID49IDEpIHsKICAgICAgICAgICAgICAgIHRoaXMuJGVtaXQoJ2Vycm9yJywgdGhpcy5pbnZhbGlkVmFsdWVzKQogICAgICAgICAgICB9IGVsc2UgaWYgKG9sZExlbmd0aCAmJiBvbGRMZW5ndGggPj0gMSkgewogICAgICAgICAgICAgICAgdGhpcy4kZW1pdCgnZXJyb3InLCBbXSkKICAgICAgICAgICAgfQogICAgICAgIH0KICAgIH0sCgogICAgbWV0aG9kczogewogICAgICAgIGZvcm1hdFZhbHVlKHRva2VuLCBpKSB7CiAgICAgICAgICAgIGlmICghdGhpcy5pc051bWJlcihpKSkgeyByZXR1cm4gJycgfQogICAgICAgICAgICBpID0gK2kKICAgICAgICAgICAgc3dpdGNoICh0b2tlbikgewogICAgICAgICAgICAgICAgY2FzZSAnSCc6CiAgICAgICAgICAgICAgICBjYXNlICdoJzoKICAgICAgICAgICAgICAgIGNhc2UgJ2snOgogICAgICAgICAgICAgICAgY2FzZSAnbSc6CiAgICAgICAgICAgICAgICBjYXNlICdzJzoKICAgICAgICAgICAgICAgICAgICBpZiAoWydoJywgJ2snXS5pbmNsdWRlcyh0b2tlbikgJiYgaSA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW4gPT09ICdrJyA/ICcyNCcgOiAnMTInCiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIHJldHVybiBTdHJpbmcoaSkKICAgICAgICAgICAgICAgIGNhc2UgJ0hIJzoKICAgICAgICAgICAgICAgIGNhc2UgJ21tJzoKICAgICAgICAgICAgICAgIGNhc2UgJ3NzJzoKICAgICAgICAgICAgICAgIGNhc2UgJ2hoJzoKICAgICAgICAgICAgICAgIGNhc2UgJ2trJzoKICAgICAgICAgICAgICAgICAgICBpZiAoWydoaCcsICdrayddLmluY2x1ZGVzKHRva2VuKSAmJiBpID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbiA9PT0gJ2trJyA/ICcyNCcgOiAnMTInCiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIHJldHVybiBpIDwgMTAgPyBgMCR7aX1gIDogU3RyaW5nKGkpCiAgICAgICAgICAgICAgICBkZWZhdWx0OgogICAgICAgICAgICAgICAgICAgIHJldHVybiAnJwogICAgICAgICAgICB9CiAgICAgICAgfSwKCiAgICAgICAgY2hlY2tBY2NlcHRpbmdUeXBlKHZhbGlkVmFsdWVzLCBmb3JtYXRTdHJpbmcpIHsKICAgICAgICAgICAgaWYgKCF2YWxpZFZhbHVlcyB8fCAhZm9ybWF0U3RyaW5nIHx8ICFmb3JtYXRTdHJpbmcubGVuZ3RoKSB7IHJldHVybiAnJyB9CiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsaWRWYWx1ZXMubGVuZ3RoOyBpKyspIHsKICAgICAgICAgICAgICAgIGlmIChmb3JtYXRTdHJpbmcuaW5kZXhPZih2YWxpZFZhbHVlc1tpXSkgPiAtMSkgewogICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWxpZFZhbHVlc1tpXQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiAnJwogICAgICAgIH0sCgogICAgICAgIHJlbmRlckZvcm1hdChuZXdGb3JtYXQpIHsKICAgICAgICAgICAgbmV3Rm9ybWF0ID0gbmV3Rm9ybWF0IHx8IHRoaXMub3B0cy5mb3JtYXQgfHwgREVGQVVMVF9PUFRJT05TLmZvcm1hdAoKICAgICAgICAgICAgbGV0IGhvdXJUeXBlID0gdGhpcy5jaGVja0FjY2VwdGluZ1R5cGUoQ09ORklHLkhPVVJfVE9LRU5TLCBuZXdGb3JtYXQpCiAgICAgICAgICAgIGxldCBtaW51dGVUeXBlID0gdGhpcy5jaGVja0FjY2VwdGluZ1R5cGUoQ09ORklHLk1JTlVURV9UT0tFTlMsIG5ld0Zvcm1hdCkKICAgICAgICAgICAgdGhpcy5zZWNvbmRUeXBlID0gdGhpcy5jaGVja0FjY2VwdGluZ1R5cGUoQ09ORklHLlNFQ09ORF9UT0tFTlMsIG5ld0Zvcm1hdCkKICAgICAgICAgICAgdGhpcy5hcG1UeXBlID0gdGhpcy5jaGVja0FjY2VwdGluZ1R5cGUoQ09ORklHLkFQTV9UT0tFTlMsIG5ld0Zvcm1hdCkKCiAgICAgICAgICAgIC8vIEZhaWxzYWZlIGNoZWNraW5nCiAgICAgICAgICAgIGlmICghaG91clR5cGUgJiYgIW1pbnV0ZVR5cGUgJiYgIXRoaXMuc2Vjb25kVHlwZSAmJiAhdGhpcy5hcG1UeXBlKSB7CiAgICAgICAgICAgICAgICBpZiAodGhpcy5kZWJ1Z01vZGUgJiYgdGhpcy5mb3JtYXQpIHsKICAgICAgICAgICAgICAgICAgICB0aGlzLmRlYnVnTG9nKGBObyB2YWxpZCB0b2tlbnMgZm91bmQgaW4geW91ciBkZWZpbmVkICJmb3JtYXQiIHN0cmluZyAiJHt0aGlzLmZvcm1hdH0iLiBGYWxsYmFjayB0byB0aGUgZGVmYXVsdCAiSEg6bW0iIGZvcm1hdC5gKQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaG91clR5cGUgPSAnSEgnCiAgICAgICAgICAgICAgICBtaW51dGVUeXBlID0gJ21tJwogICAgICAgICAgICB9CiAgICAgICAgICAgIHRoaXMuaG91clR5cGUgPSBob3VyVHlwZQogICAgICAgICAgICB0aGlzLm1pbnV0ZVR5cGUgPSBtaW51dGVUeXBlCgogICAgICAgICAgICB0aGlzLmhvdXJUeXBlID8gdGhpcy5yZW5kZXJIb3Vyc0xpc3QoKSA6IHRoaXMuaG91cnMgPSBbXQogICAgICAgICAgICB0aGlzLm1pbnV0ZVR5cGUgPyB0aGlzLnJlbmRlckxpc3QoJ21pbnV0ZScpIDogdGhpcy5taW51dGVzID0gW10KICAgICAgICAgICAgdGhpcy5zZWNvbmRUeXBlID8gdGhpcy5yZW5kZXJMaXN0KCdzZWNvbmQnKSA6IHRoaXMuc2Vjb25kcyA9IFtdCiAgICAgICAgICAgIHRoaXMuYXBtVHlwZSA/IHRoaXMucmVuZGVyQXBtTGlzdCgpIDogdGhpcy5hcG1zID0gW10KCiAgICAgICAgICAgIHRoaXMuJG5leHRUaWNrKCgpID0+IHsKICAgICAgICAgICAgICAgIHRoaXMucmVhZFZhbHVlcygpCiAgICAgICAgICAgIH0pCiAgICAgICAgfSwKCiAgICAgICAgcmVuZGVySG91cnNMaXN0KCkgewogICAgICAgICAgICBjb25zdCBob3Vyc0NvdW50ID0gdGhpcy5iYXNlT24xMkhvdXJzID8gMTIgOiAyNAogICAgICAgICAgICBjb25zdCBob3VycyA9IFtdCiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaG91cnNDb3VudDsgaSsrKSB7CiAgICAgICAgICAgICAgICBpZiAodGhpcy5ob3VyVHlwZSA9PT0gJ2snIHx8IHRoaXMuaG91clR5cGUgPT09ICdraycpIHsKICAgICAgICAgICAgICAgICAgICBob3Vycy5wdXNoKHRoaXMuZm9ybWF0VmFsdWUodGhpcy5ob3VyVHlwZSwgaSArIDEpKQogICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICBob3Vycy5wdXNoKHRoaXMuZm9ybWF0VmFsdWUodGhpcy5ob3VyVHlwZSwgaSkpCiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgICAgdGhpcy5ob3VycyA9IGhvdXJzCiAgICAgICAgfSwKCiAgICAgICAgcmVuZGVyTGlzdChsaXN0VHlwZSwgaW50ZXJ2YWwpIHsKICAgICAgICAgICAgaWYgKCF0aGlzLmlzTWludXRlT3JTZWNvbmQobGlzdFR5cGUpKSB7IHJldHVybiB9CgogICAgICAgICAgICBjb25zdCBpc01pbnV0ZSA9IGxpc3RUeXBlID09PSAnbWludXRlJwogICAgICAgICAgICBpbnRlcnZhbCA9IGludGVydmFsIHx8IChpc01pbnV0ZSA/ICh0aGlzLm9wdHMubWludXRlSW50ZXJ2YWwgfHwgREVGQVVMVF9PUFRJT05TLm1pbnV0ZUludGVydmFsKSA6ICh0aGlzLm9wdHMuc2Vjb25kSW50ZXJ2YWwgfHwgREVGQVVMVF9PUFRJT05TLnNlY29uZEludGVydmFsKSkKCiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdCiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjA7IGkgKz0gaW50ZXJ2YWwpIHsKICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMuZm9ybWF0VmFsdWUoaXNNaW51dGUgPyB0aGlzLm1pbnV0ZVR5cGUgOiB0aGlzLnNlY29uZFR5cGUsIGkpKQogICAgICAgICAgICB9CiAgICAgICAgICAgIGlzTWludXRlID8gdGhpcy5taW51dGVzID0gcmVzdWx0IDogdGhpcy5zZWNvbmRzID0gcmVzdWx0CiAgICAgICAgfSwKCiAgICAgICAgcmVuZGVyQXBtTGlzdCgpIHsKICAgICAgICAgICAgdGhpcy5hcG1zID0gdGhpcy5hcG1UeXBlID09PSAnQScgPyBbJ0FNJywgJ1BNJ10gOiBbJ2FtJywgJ3BtJ10KICAgICAgICB9LAoKICAgICAgICByZWFkVmFsdWVzKCkgewogICAgICAgICAgICBpZiAodGhpcy51c2VTdHJpbmdWYWx1ZSkgewogICAgICAgICAgICAgICAgaWYgKHRoaXMuZGVidWdNb2RlKSB7CiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWJ1Z0xvZyhgUmVjZWl2ZWQgYSBzdHJpbmcgdmFsdWU6ICIke3RoaXMudmFsdWV9ImApCiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB0aGlzLnJlYWRTdHJpbmdWYWx1ZXModGhpcy52YWx1ZSkKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIGlmICh0aGlzLmRlYnVnTW9kZSkgewogICAgICAgICAgICAgICAgICAgIHRoaXMuZGVidWdMb2coYFJlY2VpdmVkIGFuIG9iamVjdCB2YWx1ZTogIiR7SlNPTi5zdHJpbmdpZnkodGhpcy52YWx1ZSB8fCB7fSl9ImApCiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB0aGlzLnJlYWRPYmplY3RWYWx1ZXModGhpcy52YWx1ZSkKICAgICAgICAgICAgfQogICAgICAgIH0sCgogICAgICAgIHJlYWRPYmplY3RWYWx1ZXMob2JqVmFsdWUpIHsKICAgICAgICAgICAgY29uc3QgdGltZVZhbHVlID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvYmpWYWx1ZSB8fCB7fSkpCiAgICAgICAgICAgIGNvbnN0IHZhbHVlcyA9IE9iamVjdC5rZXlzKHRpbWVWYWx1ZSkKCiAgICAgICAgICAgIC8vIEZhaWxzYWZlIGZvciBlbXB0eSBgdi1tb2RlbGAgb2JqZWN0CiAgICAgICAgICAgIGlmICh2YWx1ZXMubGVuZ3RoID09PSAwKSB7CiAgICAgICAgICAgICAgICB0aGlzLmFkZEZhbGxiYWNrVmFsdWVzKCkKICAgICAgICAgICAgICAgIHJldHVybgogICAgICAgICAgICB9CgogICAgICAgICAgICBDT05GSUcuQkFTSUNfVFlQRVMuZm9yRWFjaCh0eXBlID0+IHsKICAgICAgICAgICAgICAgIGNvbnN0IHRva2VuID0gdGhpcy5nZXRUb2tlbkJ5VHlwZSh0eXBlKQogICAgICAgICAgICAgICAgaWYgKHZhbHVlcy5pbmRleE9mKHRva2VuKSA+IC0xKSB7CiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2FuaXRpemVkVmFsdWUgPSB0aGlzLnNhbml0aXplZFZhbHVlKHRva2VuLCB0aW1lVmFsdWVbdG9rZW5dKQogICAgICAgICAgICAgICAgICAgIHRoaXNbdHlwZV0gPSBzYW5pdGl6ZWRWYWx1ZQogICAgICAgICAgICAgICAgICAgIHRpbWVWYWx1ZVt0b2tlbl0gPSBzYW5pdGl6ZWRWYWx1ZQogICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICB0aGlzW3R5cGVdID0gJycKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSkKICAgICAgICAgICAgdGhpcy50aW1lVmFsdWUgPSB0aW1lVmFsdWUKICAgICAgICB9LAoKICAgICAgICBnZXRNYXRjaEFsbEJ5UmVnZXgodGVzdFN0cmluZywgcmVnZXhTdHJpbmcpIHsKICAgICAgICAgICAgY29uc3Qgc3RyID0gJ3BvbHlmaWxsVGVzdCcKICAgICAgICAgICAgY29uc3QgbmVlZHNQb2x5ZmlsbCA9IEJvb2xlYW4oIXN0ci5tYXRjaEFsbCB8fCB0eXBlb2Ygc3RyLm1hdGNoQWxsICE9PSAnZnVuY3Rpb24nKQogICAgICAgICAgICByZXR1cm4gbmVlZHNQb2x5ZmlsbCA/IHRoaXMucG9seWZpbGxNYXRjaEFsbCh0ZXN0U3RyaW5nLCByZWdleFN0cmluZykgOiB0ZXN0U3RyaW5nLm1hdGNoQWxsKG5ldyBSZWdFeHAocmVnZXhTdHJpbmcsICdnJykpCiAgICAgICAgfSwKCiAgICAgICAgcmVhZFN0cmluZ1ZhbHVlcyhzdHJpbmdWYWx1ZSkgewogICAgICAgICAgICAvLyBGYWlsc2FmZSBmb3IgZW1wdHkgYHYtbW9kZWxgIHN0cmluZwogICAgICAgICAgICBpZiAoIXN0cmluZ1ZhbHVlIHx8ICFzdHJpbmdWYWx1ZS5sZW5ndGgpIHsKICAgICAgICAgICAgICAgIHRoaXMuYWRkRmFsbGJhY2tWYWx1ZXMoKQogICAgICAgICAgICAgICAgcmV0dXJuCiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIGNvbnN0IGZvcm1hdFN0cmluZyA9IFN0cmluZyh0aGlzLmZvcm1hdFN0cmluZykKICAgICAgICAgICAgY29uc3QgdG9rZW5zUmVneFN0ciA9IGAoJHt0aGlzLnRva2VuUmVnZXhCYXNlfSkrP2AKICAgICAgICAgICAgY29uc3Qgb3RoZXJzUmVneFN0ciA9IGBbXigke3RoaXMudG9rZW5SZWdleEJhc2V9KV0rYAoKICAgICAgICAgICAgY29uc3QgdG9rZW5zTWF0Y2hBbGwgPSB0aGlzLmdldE1hdGNoQWxsQnlSZWdleChmb3JtYXRTdHJpbmcsIHRva2Vuc1JlZ3hTdHIpCiAgICAgICAgICAgIGNvbnN0IG90aGVyc01hdGNoQWxsID0gdGhpcy5nZXRNYXRjaEFsbEJ5UmVnZXgoZm9ybWF0U3RyaW5nLCBvdGhlcnNSZWd4U3RyKQoKICAgICAgICAgICAgY29uc3QgY2h1bmtzID0gW10KICAgICAgICAgICAgY29uc3QgdG9rZW5DaHVua3MgPSBbXQoKICAgICAgICAgICAgZm9yIChsZXQgdGtNYXRjaCBvZiB0b2tlbnNNYXRjaEFsbCkgewogICAgICAgICAgICAgICAgY29uc3QgdG9rZW5NYXRjaEl0ZW0gPSB7CiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IHRrTWF0Y2guaW5kZXgsCiAgICAgICAgICAgICAgICAgICAgdG9rZW46IHRrTWF0Y2hbMF0sCiAgICAgICAgICAgICAgICAgICAgaXNWYWx1ZVRva2VuOiB0cnVlCiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBjaHVua3MucHVzaCh0b2tlbk1hdGNoSXRlbSkKICAgICAgICAgICAgICAgIHRva2VuQ2h1bmtzLnB1c2godG9rZW5NYXRjaEl0ZW0pCiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIGZvciAobGV0IG90TWF0Y2ggb2Ygb3RoZXJzTWF0Y2hBbGwpIHsKICAgICAgICAgICAgICAgIGNodW5rcy5wdXNoKHsKICAgICAgICAgICAgICAgICAgICBpbmRleDogb3RNYXRjaC5pbmRleCwKICAgICAgICAgICAgICAgICAgICB0b2tlbjogb3RNYXRjaFswXQogICAgICAgICAgICAgICAgfSkKICAgICAgICAgICAgfQoKICAgICAgICAgICAgY2h1bmtzLnNvcnQoKGwsIHIpID0+IGwuaW5kZXggPCByLmluZGV4ID8gLTEgOiAxKQoKICAgICAgICAgICAgbGV0IHJlZ2V4Q29tYm8gPSAnJwogICAgICAgICAgICBjaHVua3MuZm9yRWFjaChjaHVuayA9PiB7CiAgICAgICAgICAgICAgICBpZiAoY2h1bmsuaXNWYWx1ZVRva2VuKSB7CiAgICAgICAgICAgICAgICAgICAgY29uc3QgdG9rZW5SZWdleCA9IHRoaXMuZ2V0VG9rZW5SZWdleChjaHVuay50b2tlbikgfHwgJycKICAgICAgICAgICAgICAgICAgICByZWdleENvbWJvICs9IHRva2VuUmVnZXgKICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2FmZUNoYXJzID0gY2h1bmsudG9rZW4ucmVwbGFjZSgvXFx7MH0oXCp8XD98XC58XCspL2csICdcXCQxJykKICAgICAgICAgICAgICAgICAgICByZWdleENvbWJvICs9IGAoPzoke3NhZmVDaGFyc30pYAogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9KQoKICAgICAgICAgICAgY29uc3QgY29tYm9SZWcgPSBuZXcgUmVnRXhwKHJlZ2V4Q29tYm8pCgogICAgICAgICAgICAvLyBEbyB0ZXN0IGJlZm9yZSBtYXRjaAogICAgICAgICAgICBpZiAoY29tYm9SZWcudGVzdChzdHJpbmdWYWx1ZSkpIHsKICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoUmVzdWx0cyA9IHN0cmluZ1ZhbHVlLm1hdGNoKG5ldyBSZWdFeHAocmVnZXhDb21ibykpCiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZVJlc3VsdHMgPSBtYXRjaFJlc3VsdHMuc2xpY2UoMSwgdG9rZW5DaHVua3MubGVuZ3RoICsgMSkKICAgICAgICAgICAgICAgIGNvbnN0IHRpbWVWYWx1ZSA9IHt9CiAgICAgICAgICAgICAgICB2YWx1ZVJlc3VsdHMuZm9yRWFjaCgodmFsdWUsIHZySW5kZXgpID0+IHsKICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW5DaHVua3NbdnJJbmRleF0pIHsKICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0VG9rZW4gPSB0b2tlbkNodW5rc1t2ckluZGV4XS50b2tlbgogICAgICAgICAgICAgICAgICAgICAgICB0aW1lVmFsdWVbdGFyZ2V0VG9rZW5dID0gdGhpcy5zZXRWYWx1ZUZyb21TdHJpbmcodmFsdWUsIHRhcmdldFRva2VuKQogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0pCiAgICAgICAgICAgICAgICB0aGlzLnRpbWVWYWx1ZSA9IHRpbWVWYWx1ZQoKICAgICAgICAgICAgICAgIGlmICh0aGlzLmRlYnVnTW9kZSkgewogICAgICAgICAgICAgICAgICAgIGNvbnN0IHRva2VuQ2h1bmtzRm9yTG9nID0gdG9rZW5DaHVua3MubWFwKHRDaHVuayA9PiB0Q2h1bmsgJiYgdENodW5rLnRva2VuKQogICAgICAgICAgICAgICAgICAgIHRoaXMuZGVidWdMb2coYFN1Y2Nlc3NmdWxseSBwYXJzZWQgdmFsdWVzICR7SlNPTi5zdHJpbmdpZnkodmFsdWVSZXN1bHRzKX1cbmZvciAke0pTT04uc3RyaW5naWZ5KHRva2VuQ2h1bmtzRm9yTG9nKX1cbmluIGZvcm1hdCBwYXR0ZXJuICcke3RoaXMuZm9ybWF0U3RyaW5nfSdgKQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgaWYgKHRoaXMuZGVidWdNb2RlKSB7CiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWJ1Z0xvZyhgVGhlIGlucHV0IHN0cmluZyBpbiAidi1tb2RlbCIgZG9lcyBOT1QgbWF0Y2ggdGhlICJmb3JtYXQiIHBhdHRlcm5cbmZvcm1hdDogJHt0aGlzLmZvcm1hdFN0cmluZ31cbnYtbW9kZWw6ICR7c3RyaW5nVmFsdWV9YCkKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgIH0sCgogICAgICAgIHBvbHlmaWxsTWF0Y2hBbGwodGFyZ2V0U3RyaW5nLCByZWd4U3RyKSB7CiAgICAgICAgICAgIGNvbnN0IG1hdGNoZXNMaXN0ID0gdGFyZ2V0U3RyaW5nLm1hdGNoKG5ldyBSZWdFeHAocmVneFN0ciwgJ2cnKSkKICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gW10KICAgICAgICAgICAgY29uc3QgaW5kaWNlc1JlZyA9IFtdCiAgICAgICAgICAgIGlmIChtYXRjaGVzTGlzdCAmJiBtYXRjaGVzTGlzdC5sZW5ndGgpIHsKICAgICAgICAgICAgICAgIG1hdGNoZXNMaXN0LmZvckVhY2gobWF0Y2hlZEl0ZW0gPT4gewogICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4aXN0SW5kZXggPSBpbmRpY2VzUmVnLmZpbmRJbmRleChpZHhJdGVtID0+IGlkeEl0ZW0uc3RyID09PSBtYXRjaGVkSXRlbSkKICAgICAgICAgICAgICAgICAgICBsZXQgaW5kZXgKICAgICAgICAgICAgICAgICAgICBpZiAoZXhpc3RJbmRleCA+PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRpY2VzUmVnW2V4aXN0SW5kZXhdICYmIGluZGljZXNSZWdbZXhpc3RJbmRleF0ucmVnZXgpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gaW5kaWNlc1JlZ1tleGlzdEluZGV4XS5yZWdleC5leGVjKHRhcmdldFN0cmluZykuaW5kZXgKICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW1JbmRpY2VzUmVnZXggPSBuZXcgUmVnRXhwKG1hdGNoZWRJdGVtLCAnZycpCiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gaXRlbUluZGljZXNSZWdleC5leGVjKHRhcmdldFN0cmluZykuaW5kZXgKICAgICAgICAgICAgICAgICAgICAgICAgaW5kaWNlc1JlZy5wdXNoKHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cjogU3RyaW5nKG1hdGNoZWRJdGVtKSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2V4OiBpdGVtSW5kaWNlc1JlZ2V4CiAgICAgICAgICAgICAgICAgICAgICAgIH0pCiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHsKICAgICAgICAgICAgICAgICAgICAgICAgMDogU3RyaW5nKG1hdGNoZWRJdGVtKSwKICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGluZGV4CiAgICAgICAgICAgICAgICAgICAgfSkKICAgICAgICAgICAgICAgIH0pCiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIHJlc3VsdAogICAgICAgIH0sCgogICAgICAgIGFkZEZhbGxiYWNrVmFsdWVzKCkgewogICAgICAgICAgICBjb25zdCB0aW1lVmFsdWUgPSB7fQogICAgICAgICAgICB0aGlzLmluVXNlLnR5cGVzLmZvckVhY2godHlwZSA9PiB7CiAgICAgICAgICAgICAgICB0aW1lVmFsdWVbdGhpcy5nZXRUb2tlbkJ5VHlwZSh0eXBlKV0gPSAnJwogICAgICAgICAgICB9KQogICAgICAgICAgICB0aGlzLnRpbWVWYWx1ZSA9IHRpbWVWYWx1ZQogICAgICAgIH0sCgogICAgICAgIHNldFZhbHVlRnJvbVN0cmluZyhwYXJzZWRWYWx1ZSwgdG9rZW4pIHsKICAgICAgICAgICAgaWYgKCF0b2tlbiB8fCAhcGFyc2VkVmFsdWUpIHsgcmV0dXJuICcnIH0KICAgICAgICAgICAgY29uc3QgdG9rZW5UeXBlID0gdGhpcy5nZXRUb2tlblR5cGUodG9rZW4pCiAgICAgICAgICAgIGlmICghdG9rZW5UeXBlIHx8ICF0b2tlblR5cGUubGVuZ3RoKSB7IHJldHVybiAnJyB9CiAgICAgICAgICAgIGNvbnN0IHN0ZFZhbHVlID0gKHBhcnNlZFZhbHVlICE9PSB0aGlzLmdldFRva2VuQnlUeXBlKHRva2VuVHlwZSkpID8gcGFyc2VkVmFsdWUgOiAnJwogICAgICAgICAgICB0aGlzW3Rva2VuVHlwZV0gPSBzdGRWYWx1ZQogICAgICAgICAgICByZXR1cm4gc3RkVmFsdWUKICAgICAgICB9LAoKICAgICAgICBmaWxsVmFsdWVzKGZvcmNlRW1pdCkgewogICAgICAgICAgICBjb25zdCBmdWxsVmFsdWVzID0ge30KCiAgICAgICAgICAgIGNvbnN0IGJhc2VIb3VyID0gdGhpcy5ob3VyCiAgICAgICAgICAgIGNvbnN0IGJhc2VIb3VyVHlwZSA9IHRoaXMuaG91clR5cGUKCiAgICAgICAgICAgIGxldCBhcG1WYWx1ZQoKICAgICAgICAgICAgLy8gSG91ciB0eXBlIG9yIGhvdXIgdmFsdWUgaXMgTk9UIHNldCBpbiB0aGUgImZvcm1hdCIgc3RyaW5nCiAgICAgICAgICAgIGlmICghYmFzZUhvdXJUeXBlIHx8ICF0aGlzLmlzTnVtYmVyKGJhc2VIb3VyKSkgewogICAgICAgICAgICAgICAgQ09ORklHLkhPVVJfVE9LRU5TLmZvckVhY2godG9rZW4gPT4gZnVsbFZhbHVlc1t0b2tlbl0gPSAnJykKICAgICAgICAgICAgICAgIGFwbVZhbHVlID0gdGhpcy5sb3dlckNhc2VkQXBtKHRoaXMuYXBtIHx8ICcnKQogICAgICAgICAgICAgICAgZnVsbFZhbHVlcy5hID0gYXBtVmFsdWUKICAgICAgICAgICAgICAgIGZ1bGxWYWx1ZXMuQSA9IGFwbVZhbHVlLnRvVXBwZXJDYXNlKCkKCiAgICAgICAgICAgICAgICAvLyBCb3RoIEhvdXIgdHlwZSBhbmQgdmFsdWUgYXJlIHNldAogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgY29uc3QgaG91clZhbHVlID0gK2Jhc2VIb3VyCiAgICAgICAgICAgICAgICBjb25zdCBhcG1WYWx1ZSA9ICh0aGlzLmJhc2VPbjEySG91cnMgJiYgdGhpcy5hcG0pID8gdGhpcy5sb3dlckNhc2VkQXBtKHRoaXMuYXBtKSA6IGZhbHNlCgogICAgICAgICAgICAgICAgQ09ORklHLkhPVVJfVE9LRU5TLmZvckVhY2goKHRva2VuKSA9PiB7CiAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuID09PSBiYXNlSG91clR5cGUpIHsKICAgICAgICAgICAgICAgICAgICAgICAgZnVsbFZhbHVlc1t0b2tlbl0gPSBiYXNlSG91cgogICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4KICAgICAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgICAgIGxldCB2YWx1ZQogICAgICAgICAgICAgICAgICAgIGxldCBhcG0KICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHRva2VuKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ0gnOgogICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdISCc6CiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2snOgogICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdrayc6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5iYXNlT24xMkhvdXJzKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFwbVZhbHVlID09PSAncG0nKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gaG91clZhbHVlIDwgMTIgPyBob3VyVmFsdWUgKyAxMiA6IGhvdXJWYWx1ZQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoWydrJywgJ2trJ10uaW5jbHVkZXModG9rZW4pKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gaG91clZhbHVlID09PSAxMiA/IDI0IDogaG91clZhbHVlCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBob3VyVmFsdWUgJSAxMgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFsnaycsICdrayddLmluY2x1ZGVzKHRva2VuKSkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGhvdXJWYWx1ZSA9PT0gMCA/IDI0IDogaG91clZhbHVlCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBob3VyVmFsdWUgJSAyNAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bGxWYWx1ZXNbdG9rZW5dID0gdGhpcy5mb3JtYXRWYWx1ZSh0b2tlbiwgdmFsdWUpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhawogICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdoJzoKICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnaGgnOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaCA8LT4gaGgKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmJhc2VPbjEySG91cnMpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGhvdXJWYWx1ZQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwbSA9IGFwbVZhbHVlIHx8ICcnCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVhZCBmcm9tIG90aGVyIGhvdXIgZm9ybWF0cwogICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaG91clZhbHVlID4gMTEgJiYgaG91clZhbHVlIDwgMjQpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBtID0gJ3BtJwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGhvdXJWYWx1ZSA9PT0gMTIgPyAxMiA6IGhvdXJWYWx1ZSAlIDEyCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBtID0gJ2FtJwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGhvdXJWYWx1ZSAlIDEyID09PSAwID8gMTIgOiBob3VyVmFsdWUKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdWxsVmFsdWVzW3Rva2VuXSA9IHRoaXMuZm9ybWF0VmFsdWUodG9rZW4sIHZhbHVlKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVsbFZhbHVlcy5hID0gYXBtCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdWxsVmFsdWVzLkEgPSBhcG0udG9VcHBlckNhc2UoKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9KQogICAgICAgICAgICB9CgogICAgICAgICAgICBmdWxsVmFsdWVzLm0gPSB0aGlzLmZvcm1hdFZhbHVlKCdtJywgdGhpcy5taW51dGUpCiAgICAgICAgICAgIGZ1bGxWYWx1ZXMubW0gPSB0aGlzLmZvcm1hdFZhbHVlKCdtbScsIHRoaXMubWludXRlKQogICAgICAgICAgICBmdWxsVmFsdWVzLnMgPSB0aGlzLmZvcm1hdFZhbHVlKCdzJywgdGhpcy5zZWNvbmQpCiAgICAgICAgICAgIGZ1bGxWYWx1ZXMuc3MgPSB0aGlzLmZvcm1hdFZhbHVlKCdzcycsIHRoaXMuc2Vjb25kKQoKICAgICAgICAgICAgdGhpcy5mdWxsVmFsdWVzID0gZnVsbFZhbHVlcwoKICAgICAgICAgICAgLy8gT24gbGF6eSBtb2RlLCBlbWl0IGBpbnB1dGAgYW5kIGBjaGFuZ2VgIGV2ZW50cyBvbmx5IHdoZW46CiAgICAgICAgICAgIC8vIC0gVGhlIHVzZXIgcGljayBhIG5ldyB2YWx1ZSBhbmQgdGhlbiBjbG9zZSB0aGUgZHJvcGRvd24KICAgICAgICAgICAgLy8gLSBUaGUgdXNlciBjbGljayB0aGUgKCJ4IikgY2xlYXIgYnV0dG9uCiAgICAgICAgICAgIGlmICghdGhpcy5sYXp5IHx8IGZvcmNlRW1pdCkgewogICAgICAgICAgICAgICAgdGhpcy5lbWl0VGltZVZhbHVlKCkKICAgICAgICAgICAgfQoKICAgICAgICAgICAgaWYgKHRoaXMuY2xvc2VPbkNvbXBsZXRlICYmIHRoaXMuYWxsVmFsdWVTZWxlY3RlZCAmJiB0aGlzLnNob3dEcm9wZG93bikgewogICAgICAgICAgICAgICAgdGhpcy50b2dnbGVBY3RpdmUoKQogICAgICAgICAgICB9CiAgICAgICAgfSwKCiAgICAgICAgZ2V0RnVsbERhdGEoKSB7CiAgICAgICAgICAgIGlmICghdGhpcy5mdWxsVmFsdWVzKSB7CiAgICAgICAgICAgICAgICB0aGlzLmZpbGxWYWx1ZXMoKQogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiB7CiAgICAgICAgICAgICAgICBkYXRhOiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHRoaXMuZnVsbFZhbHVlcykpLAogICAgICAgICAgICAgICAgZGlzcGxheVRpbWU6IHRoaXMuaW5wdXRJc0VtcHR5ID8gJycgOiBTdHJpbmcodGhpcy5kaXNwbGF5VGltZSkKICAgICAgICAgICAgfQogICAgICAgIH0sCgogICAgICAgIGVtaXRUaW1lVmFsdWUoKSB7CiAgICAgICAgICAgIGlmICh0aGlzLmxhenkgJiYgdGhpcy5iYWtEaXNwbGF5VGltZSA9PT0gdGhpcy5kaXNwbGF5VGltZSkgewogICAgICAgICAgICAgICAgaWYgKHRoaXMuZGVidWdNb2RlKSB7CiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWJ1Z0xvZygnVGhlIHZhbHVlIGRvZXMgbm90IGNoYW5nZSBvbiBgbGF6eWAgbW9kZS4gU2tpcCB0aGUgZW1pdHRpbmcgYGlucHV0YCBhbmQgYGNoYW5nZWAgZXZlbnQuJykKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHJldHVybgogICAgICAgICAgICB9CgogICAgICAgICAgICBjb25zdCBmdWxsRGF0YSA9IHRoaXMuZ2V0RnVsbERhdGEoKQoKICAgICAgICAgICAgaWYgKHRoaXMudXNlU3RyaW5nVmFsdWUpIHsKICAgICAgICAgICAgICAgIHRoaXMuJGVtaXQoJ2lucHV0JywgZnVsbERhdGEuZGlzcGxheVRpbWUpCiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICBjb25zdCBmdWxsVmFsdWVzID0gZnVsbERhdGEuZGF0YQogICAgICAgICAgICAgICAgY29uc3QgdG9rZW5zSW5Vc2UgPSB0aGlzLmluVXNlLnRva2VucyB8fCBbXQogICAgICAgICAgICAgICAgY29uc3QgdGltZVZhbHVlID0ge30KICAgICAgICAgICAgICAgIHRva2Vuc0luVXNlLmZvckVhY2goKHRva2VuKSA9PiB7CiAgICAgICAgICAgICAgICAgICAgdGltZVZhbHVlW3Rva2VuXSA9IGZ1bGxWYWx1ZXNbdG9rZW5dIHx8ICcnCiAgICAgICAgICAgICAgICB9KQogICAgICAgICAgICAgICAgdGhpcy4kZW1pdCgnaW5wdXQnLCBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHRpbWVWYWx1ZSkpKQogICAgICAgICAgICB9CgogICAgICAgICAgICB0aGlzLiRlbWl0KCdjaGFuZ2UnLCBmdWxsRGF0YSkKICAgICAgICB9LAoKICAgICAgICB0cmFuc2xhdGUxMmhSYW5nZSh2YWx1ZSkgewogICAgICAgICAgICBjb25zdCB2YWx1ZVQgPSB0aGlzLm1hdGNoMTJoUmFuZ2UodmFsdWUpCiAgICAgICAgICAgIGlmICgrdmFsdWVUWzFdID09PSAxMikgewogICAgICAgICAgICAgICAgcmV0dXJuICt2YWx1ZVRbMV0gKyAodmFsdWVUWzJdLnRvTG93ZXJDYXNlKCkgPT09ICdwJyA/IDAgOiAxMikKICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gK3ZhbHVlVFsxXSArICh2YWx1ZVRbMl0udG9Mb3dlckNhc2UoKSA9PT0gJ3AnID8gMTIgOiAwKQogICAgICAgIH0sCgogICAgICAgIGlzRGlzYWJsZWQodHlwZSwgdmFsdWUpIHsKICAgICAgICAgICAgaWYgKCF0aGlzLmlzQmFzaWNUeXBlKHR5cGUpIHx8ICF0aGlzLmluVXNlW3R5cGVdKSB7IHJldHVybiB0cnVlIH0KICAgICAgICAgICAgc3dpdGNoICh0eXBlKSB7CiAgICAgICAgICAgICAgICBjYXNlICdob3VyJzoKICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pc0Rpc2FibGVkSG91cih2YWx1ZSkKICAgICAgICAgICAgICAgIGNhc2UgJ21pbnV0ZSc6CiAgICAgICAgICAgICAgICBjYXNlICdzZWNvbmQnOgogICAgICAgICAgICAgICAgICAgIGlmICghdGhpc1tgJHt0eXBlfVJhbmdlTGlzdGBdKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZQogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICByZXR1cm4gIXRoaXNbYCR7dHlwZX1SYW5nZUxpc3RgXS5pbmNsdWRlcyh2YWx1ZSkKICAgICAgICAgICAgICAgIGNhc2UgJ2FwbSc6CiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnJlc3RyaWN0ZWRIb3VyUmFuZ2UpIHsKICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlCiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIHJldHVybiAhdGhpcy5oYXNbdGhpcy5sb3dlckNhc2VkQXBtKHZhbHVlKV0KICAgICAgICAgICAgICAgIGRlZmF1bHQ6CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWUKICAgICAgICAgICAgfQogICAgICAgIH0sCgogICAgICAgIGlzRGlzYWJsZWRIb3VyKHZhbHVlKSB7CiAgICAgICAgICAgIGlmICghdGhpcy5yZXN0cmljdGVkSG91clJhbmdlKSB7IHJldHVybiBmYWxzZSB9CiAgICAgICAgICAgIGlmICh0aGlzLmJhc2VPbjEySG91cnMpIHsKICAgICAgICAgICAgICAgIGlmICghdGhpcy5hcG0gfHwgIXRoaXMuYXBtLmxlbmd0aCkgewogICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZQogICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICBjb25zdCB0b2tlbiA9IHRoaXMuYXBtLnRvTG93ZXJDYXNlKCkgPT09ICdhbScgPyAnYScgOiAncCcKICAgICAgICAgICAgICAgICAgICByZXR1cm4gIXRoaXMucmVzdHJpY3RlZEhvdXJSYW5nZS5pbmNsdWRlcyhgJHsrdmFsdWV9JHt0b2tlbn1gKQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICAgIC8vIEZhbGxiYWNrIGZvciAnSEgnIGFuZCAnSCBob3VyIGZvcm1hdCB3aXRoIGEgYGhvdXItcmFuZ2VgIGluIGEgMTItaG91ciBmb3JtCiAgICAgICAgICAgIGlmICgKICAgICAgICAgICAgICAgICh0aGlzLmhvdXJUeXBlID09PSAnSEgnIHx8IHRoaXMuaG91clR5cGUgPT09ICdIJykgJiYKICAgICAgICAgICAgICAgICt2YWx1ZSA9PT0gMCAmJiB0aGlzLnJlc3RyaWN0ZWRIb3VyUmFuZ2UuaW5jbHVkZXMoMjQpCiAgICAgICAgICAgICkgewogICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlCiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuICF0aGlzLnJlc3RyaWN0ZWRIb3VyUmFuZ2UuaW5jbHVkZXMoK3ZhbHVlKQogICAgICAgIH0sCgogICAgICAgIG5vdEluSW50ZXJ2YWwoc2VjdGlvbiwgdmFsdWUpIHsKICAgICAgICAgICAgaWYgKCFzZWN0aW9uIHx8ICF0aGlzLmlzTWludXRlT3JTZWNvbmQoc2VjdGlvbikpIHsgcmV0dXJuIH0KICAgICAgICAgICAgaWYgKHRoaXMub3B0c1tgJHtzZWN0aW9ufUludGVydmFsYF0gPT09IDEpIHsgcmV0dXJuIGZhbHNlIH0KICAgICAgICAgICAgcmV0dXJuICt2YWx1ZSAlIHRoaXMub3B0c1tgJHtzZWN0aW9ufUludGVydmFsYF0gIT09IDAKICAgICAgICB9LAoKICAgICAgICByZW5kZXJSYW5nZUxpc3QocmF3UmFuZ2UsIHNlY3Rpb24pIHsKICAgICAgICAgICAgaWYgKCFyYXdSYW5nZSB8fCAhc2VjdGlvbiB8fCAhdGhpcy5pc01pbnV0ZU9yU2Vjb25kKHNlY3Rpb24pKSB7IHJldHVybiBbXSB9CiAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gW10KICAgICAgICAgICAgbGV0IGZvcm1hdGVkVmFsdWUKICAgICAgICAgICAgcmF3UmFuZ2UuZm9yRWFjaCh2YWx1ZSA9PiB7CiAgICAgICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBBcnJheSkgewogICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPiAyICYmIHRoaXMuZGVidWdNb2RlKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVidWdMb2coYE5lc3RlZCBhcnJheSB3aXRoaW4gIiR7c2VjdGlvbn0tcmFuZ2UiIG11c3QgY29udGFpbiBubyBtb3JlIHRoYW4gdHdvIGl0ZW1zLiBPbmx5IHRoZSBmaXJzdCB0d28gaXRlbXMgb2YgJHtKU09OLnN0cmluZ2lmeSh2YWx1ZSl9IHdpbGwgYmUgdGFrZW4gaW50byBhY2NvdW50LmApCiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gdmFsdWVbMF0KICAgICAgICAgICAgICAgICAgICBjb25zdCBlbmQgPSB2YWx1ZVsxXSB8fCB2YWx1ZVswXQogICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSArc3RhcnQ7IGkgPD0gK2VuZDsgaSsrKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpIDwgMCB8fCBpID4gNTkpIHsgY29udGludWUgfQogICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXRlZFZhbHVlID0gdGhpcy5mb3JtYXRWYWx1ZSh0aGlzLmdldFRva2VuQnlUeXBlKHNlY3Rpb24pLCBpKQogICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJhbmdlLmluY2x1ZGVzKGZvcm1hdGVkVmFsdWUpKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICByYW5nZS5wdXNoKGZvcm1hdGVkVmFsdWUpCiAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgIGlmICgrdmFsdWUgPCAwIHx8ICt2YWx1ZSA+IDU5KSB7IHJldHVybiB9CiAgICAgICAgICAgICAgICAgICAgZm9ybWF0ZWRWYWx1ZSA9IHRoaXMuZm9ybWF0VmFsdWUodGhpcy5nZXRUb2tlbkJ5VHlwZShzZWN0aW9uKSwgdmFsdWUpCiAgICAgICAgICAgICAgICAgICAgaWYgKCFyYW5nZS5pbmNsdWRlcyhmb3JtYXRlZFZhbHVlKSkgewogICAgICAgICAgICAgICAgICAgICAgICByYW5nZS5wdXNoKGZvcm1hdGVkVmFsdWUpCiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9KQogICAgICAgICAgICByYW5nZS5zb3J0KChsLCByKSA9PiB7IHJldHVybiBsIC0gciB9KQogICAgICAgICAgICAvLyBEZWJ1ZyBNb2RlCiAgICAgICAgICAgIGlmICh0aGlzLmRlYnVnTW9kZSkgewogICAgICAgICAgICAgICAgY29uc3QgZnVsbExpc3QgPSAoc2VjdGlvbiA9PT0gJ21pbnV0ZScgPyB0aGlzLm1pbnV0ZXMgOiB0aGlzLnNlY29uZHMpIHx8IFtdCiAgICAgICAgICAgICAgICBjb25zdCB2YWxpZEl0ZW1zID0gZnVsbExpc3QuZmlsdGVyKGl0ZW0gPT4gcmFuZ2UuaW5jbHVkZXMoaXRlbSkpCiAgICAgICAgICAgICAgICBpZiAoIXZhbGlkSXRlbXMgfHwgIXZhbGlkSXRlbXMubGVuZ3RoKSB7CiAgICAgICAgICAgICAgICAgICAgaWYgKHNlY3Rpb24gPT09ICdtaW51dGUnKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVidWdMb2coYFRoZSBtaW51dGUgbGlzdCBpcyBlbXB0eSBkdWUgdG8gdGhlICJtaW51dGUtcmFuZ2UiIGNvbmZpZ1xubWludXRlLXJhbmdlOiAke0pTT04uc3RyaW5naWZ5KHRoaXMubWludXRlUmFuZ2UpfVxubWludXRlLWludGVydmFsOiAke3RoaXMub3B0cy5taW51dGVJbnRlcnZhbH1gKQogICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVidWdMb2coYFRoZSBzZWNvbmQgbGlzdCBpcyBlbXB0eSBkdWUgdG8gdGhlICJzZWNvbmQtcmFuZ2UiIGNvbmZpZ1xuc2Vjb25kLXJhbmdlOiAke0pTT04uc3RyaW5naWZ5KHRoaXMuc2Vjb25kUmFuZ2UpfVxuc2Vjb25kLWludGVydmFsOiAke3RoaXMub3B0cy5zZWNvbmRJbnRlcnZhbH1gKQogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gcmFuZ2UKICAgICAgICB9LAoKICAgICAgICBmb3JjZUFwbVNlbGVjdGlvbigpIHsKICAgICAgICAgICAgaWYgKHRoaXMubWFudWFsSW5wdXQpIHsKICAgICAgICAgICAgICAgIC8vIFNraXAgdGhpcyB0byBhbGxvdyB1c2VycyB0byBwYXN0ZSBhIHN0cmluZyB2YWx1ZSBmcm9tIHRoZSBjbGlwYm9hcmQgaW4gTWFudWFsIElucHV0IG1vZGUKICAgICAgICAgICAgICAgIHJldHVybgogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmICh0aGlzLmFwbVR5cGUgJiYgIXRoaXMuYXBtKSB7CiAgICAgICAgICAgICAgICBpZiAodGhpcy5oYXMuYW0gfHwgdGhpcy5oYXMucG0pIHsKICAgICAgICAgICAgICAgICAgICB0aGlzLmRvQ2xlYXJBcG1DaGVja2luZyA9IHRydWUKICAgICAgICAgICAgICAgICAgICBjb25zdCBhcG1WYWx1ZSA9IHRoaXMuaGFzLmFtID8gJ2FtJyA6ICdwbScKICAgICAgICAgICAgICAgICAgICB0aGlzLmFwbSA9IHRoaXMuYXBtVHlwZSA9PT0gJ0EnID8gYXBtVmFsdWUudG9VcHBlckNhc2UoKSA6IGFwbVZhbHVlCiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICB9LAoKICAgICAgICBlbXB0eUFwbVNlbGVjdGlvbigpIHsKICAgICAgICAgICAgaWYgKHRoaXMuZG9DbGVhckFwbUNoZWNraW5nICYmIHRoaXMuaG91ciA9PT0gJycgJiYgdGhpcy5taW51dGUgPT09ICcnICYmIHRoaXMuc2Vjb25kID09PSAnJykgewogICAgICAgICAgICAgICAgdGhpcy5hcG0gPSAnJwogICAgICAgICAgICB9CiAgICAgICAgICAgIHRoaXMuZG9DbGVhckFwbUNoZWNraW5nID0gZmFsc2UKICAgICAgICB9LAoKICAgICAgICBhcG1EaXNwbGF5VGV4dChhcG1WYWx1ZSkgewogICAgICAgICAgICBpZiAodGhpcy5hbVRleHQgJiYgdGhpcy5sb3dlckNhc2VkQXBtKGFwbVZhbHVlKSA9PT0gJ2FtJykgewogICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYW1UZXh0CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKHRoaXMucG1UZXh0ICYmIHRoaXMubG93ZXJDYXNlZEFwbShhcG1WYWx1ZSkgPT09ICdwbScpIHsKICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBtVGV4dAogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiBhcG1WYWx1ZQogICAgICAgIH0sCgogICAgICAgIHRvZ2dsZUFjdGl2ZSgpIHsKICAgICAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQpIHsgcmV0dXJuIH0KICAgICAgICAgICAgdGhpcy5pc0FjdGl2ZSA9ICF0aGlzLmlzQWN0aXZlCgogICAgICAgICAgICBpZiAodGhpcy5pc0FjdGl2ZSkgewogICAgICAgICAgICAgICAgdGhpcy5pc0ZvY3VzaW5nID0gdHJ1ZQogICAgICAgICAgICAgICAgaWYgKHRoaXMubWFudWFsSW5wdXQpIHsKICAgICAgICAgICAgICAgICAgICB0aGlzLiRlbWl0KCdmb2N1cycpCiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZiAoIXRoaXMub3B0cy5oaWRlRHJvcGRvd24pIHsKICAgICAgICAgICAgICAgICAgICB0aGlzLnNldERyb3Bkb3duU3RhdGUodHJ1ZSkKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIC8vIFJlY29yZCB0byBjaGVjayBpZiB2YWx1ZSBkaWQgY2hhbmdlIGluIHRoZSBsYXRlciBwaGFzZQogICAgICAgICAgICAgICAgaWYgKHRoaXMubGF6eSkgewogICAgICAgICAgICAgICAgICAgIHRoaXMuYmFrRGlzcGxheVRpbWUgPSBTdHJpbmcodGhpcy5kaXNwbGF5VGltZSB8fCAnJykKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGlmICh0aGlzLm1hbnVhbElucHV0ICYmICF0aGlzLmlucHV0SXNFbXB0eSkgewogICAgICAgICAgICAgICAgICAgIHRoaXMuJG5leHRUaWNrKCgpID0+IHsKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuJHJlZnMuaW5wdXQgJiYgdGhpcy4kcmVmcy5pbnB1dC5zZWxlY3Rpb25TdGFydCA9PT0gMCAmJiB0aGlzLiRyZWZzLmlucHV0LnNlbGVjdGlvbkVuZCA9PT0gdGhpcy5kaXNwbGF5VGltZS5sZW5ndGgpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNlbGVjdCB0aGUgZmlyc3Qgc2xvdCBpbnN0ZWFkIG9mIHRoZSB3aG9sZSB2YWx1ZSBzdHJpbmcgd2hlbiB0YWJiZWQgaW4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0Rmlyc3RTbG90KCkKICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIH0pCiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICBpZiAodGhpcy5zaG93RHJvcGRvd24pIHsKICAgICAgICAgICAgICAgICAgICB0aGlzLnNldERyb3Bkb3duU3RhdGUoZmFsc2UpCiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMubWFudWFsSW5wdXQpIHsKICAgICAgICAgICAgICAgICAgICB0aGlzLiRlbWl0KCdibHVyJywgdGhpcy5nZXRGdWxsRGF0YSgpKQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgdGhpcy5pc0ZvY3VzaW5nID0gZmFsc2UKICAgICAgICAgICAgICAgIGlmICh0aGlzLmxhenkpIHsKICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbGxWYWx1ZXModHJ1ZSkKICAgICAgICAgICAgICAgICAgICB0aGlzLmJha0Rpc3BsYXlUaW1lID0gdW5kZWZpbmVkCiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIGlmICh0aGlzLnJlc3RyaWN0ZWRIb3VyUmFuZ2UgJiYgdGhpcy5iYXNlT24xMkhvdXJzKSB7CiAgICAgICAgICAgICAgICB0aGlzLnNob3dEcm9wZG93biA/IHRoaXMuZm9yY2VBcG1TZWxlY3Rpb24oKSA6IHRoaXMuZW1wdHlBcG1TZWxlY3Rpb24oKQogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmICh0aGlzLnNob3dEcm9wZG93bikgewogICAgICAgICAgICAgICAgdGhpcy5jaGVja0ZvckF1dG9TY3JvbGwoKQogICAgICAgICAgICB9CiAgICAgICAgfSwKCiAgICAgICAgc2V0RHJvcGRvd25TdGF0ZSh0b1Nob3csIGZyb21Vc2VyQ2xpY2sgPSBmYWxzZSkgewogICAgICAgICAgICBpZiAodG9TaG93KSB7CiAgICAgICAgICAgICAgICBpZiAodGhpcy5hcHBlbmRUb0JvZHkpIHsKICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcGVuZERyb3Bkb3duVG9Cb2R5KCkKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHRoaXMua2VlcEZvY3VzaW5nKCkKICAgICAgICAgICAgICAgIGlmICh0aGlzLmF1dG9EaXJlY3Rpb25FbmFibGVkKSB7CiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGVja0Ryb3BEaXJlY3Rpb24oKQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgdGhpcy5zaG93RHJvcGRvd24gPSB0cnVlCiAgICAgICAgICAgICAgICB0aGlzLiRlbWl0KCdvcGVuJykKICAgICAgICAgICAgICAgIGlmIChmcm9tVXNlckNsaWNrKSB7CiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZml4ZWREcm9wZG93bkJ1dHRvbikgewogICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmlzQWN0aXZlID0gdHJ1ZQogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICB0aGlzLiRlbWl0KCdibHVyJywgdGhpcy5nZXRGdWxsRGF0YSgpKQogICAgICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tGb3JBdXRvU2Nyb2xsKCkKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIHRoaXMuc2hvd0Ryb3Bkb3duID0gZmFsc2UKICAgICAgICAgICAgICAgIHRoaXMuJGVtaXQoJ2Nsb3NlJywgdGhpcy5nZXRGdWxsRGF0YSgpKQogICAgICAgICAgICAgICAgaWYgKHRoaXMuYXBwZW5kVG9Cb2R5KSB7CiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVEcm9wZG93bkZyb21Cb2R5KCkKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgIH0sCgogICAgICAgIGFwcGVuZERyb3Bkb3duVG9Cb2R5KCkgewogICAgICAgICAgICBjb25zdCBkcm9wZG93biA9IHRoaXMuJHJlZnMgJiYgdGhpcy4kcmVmcy5kcm9wZG93bgogICAgICAgICAgICBjb25zdCBib2R5ID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2JvZHknKVswXQogICAgICAgICAgICBpZiAoYm9keSAmJiBkcm9wZG93bikgewogICAgICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMudXBkYXRlRHJvcGRvd25Qb3MpCiAgICAgICAgICAgICAgICBkcm9wZG93bi5jbGFzc0xpc3QuYWRkKCd2dWVfX3RpbWUtcGlja2VyLWRyb3Bkb3duJykKICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlRHJvcGRvd25Qb3MoKQogICAgICAgICAgICAgICAgYm9keS5hcHBlbmRDaGlsZChkcm9wZG93bikKICAgICAgICAgICAgfQogICAgICAgIH0sCgogICAgICAgIHVwZGF0ZURyb3Bkb3duUG9zKCkgewogICAgICAgICAgICBpZiAoIXRoaXMuYXBwZW5kVG9Cb2R5KSB7IHJldHVybiB9CiAgICAgICAgICAgIGNvbnN0IGRyb3Bkb3duID0gdGhpcy4kcmVmcyAmJiB0aGlzLiRyZWZzLmRyb3Bkb3duCiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnYm9keScpWzBdCiAgICAgICAgICAgIGlmIChib2R5ICYmIGRyb3Bkb3duKSB7CiAgICAgICAgICAgICAgICBjb25zdCBib3ggPSB0aGlzLiRlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKQogICAgICAgICAgICAgICAgaWYgKHRoaXMuZHJvcGRvd25EaXJDbGFzcyA9PT0gJ2Ryb3AtdXAnKSB7CiAgICAgICAgICAgICAgICAgICAgZHJvcGRvd24uc3R5bGUuYm90dG9tID0gYCR7d2luZG93LmlubmVySGVpZ2h0IC0gYm94Lnl9cHhgCiAgICAgICAgICAgICAgICAgICAgZHJvcGRvd24uc3R5bGUudG9wID0gJ2F1dG8nCiAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgIGRyb3Bkb3duLnN0eWxlLnRvcCA9IGAke2JveC55ICsgYm94LmhlaWdodH1weGAKICAgICAgICAgICAgICAgICAgICBkcm9wZG93bi5zdHlsZS5ib3R0b20gPSAnYXV0bycKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGRyb3Bkb3duLnN0eWxlLmxlZnQgPSBgJHtib3gueH1weGAKICAgICAgICAgICAgfQogICAgICAgIH0sCgogICAgICAgIHJlbW92ZURyb3Bkb3duRnJvbUJvZHkoKSB7CiAgICAgICAgICAgIGNvbnN0IGRyb3Bkb3duID0gdGhpcy4kcmVmcyAmJiB0aGlzLiRyZWZzLmRyb3Bkb3duCiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnYm9keScpWzBdCiAgICAgICAgICAgIGlmIChib2R5ICYmIGRyb3Bkb3duICYmIGJvZHkuY29udGFpbnMoZHJvcGRvd24pKSB7CiAgICAgICAgICAgICAgICBib2R5LnJlbW92ZUNoaWxkKGRyb3Bkb3duKQogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChkcm9wZG93bikgewogICAgICAgICAgICAgICAgZHJvcGRvd24uY2xhc3NMaXN0LnJlbW92ZSgndnVlX190aW1lLXBpY2tlci1kcm9wZG93bicpCiAgICAgICAgICAgICAgICBkcm9wZG93bi5zdHlsZS50b3AgPSAnJwogICAgICAgICAgICAgICAgZHJvcGRvd24uc3R5bGUuYm90dG9tID0gJycKICAgICAgICAgICAgICAgIGRyb3Bkb3duLnN0eWxlLmxlZnQgPSAnJwogICAgICAgICAgICAgICAgdGhpcy4kZWwuYXBwZW5kQ2hpbGQoZHJvcGRvd24pCiAgICAgICAgICAgIH0KICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMudXBkYXRlRHJvcGRvd25Qb3MpCiAgICAgICAgfSwKCiAgICAgICAgYmx1ckV2ZW50KCkgewogICAgICAgICAgICBpZiAodGhpcy5tYW51YWxJbnB1dCAmJiAhdGhpcy5vcHRzLmhpZGVEcm9wZG93bikgewogICAgICAgICAgICAgICAgLy8gaGlkZURyb3Bkb3duJ3MgYGJsdXJgIGV2ZW50IGlzIGhhbmRsZWQgc29tZXdoZXJlIGVsc2UKICAgICAgICAgICAgICAgIHRoaXMuJGVtaXQoJ2JsdXInLCB0aGlzLmdldEZ1bGxEYXRhKCkpCiAgICAgICAgICAgIH0KICAgICAgICB9LAoKICAgICAgICBzZWxlY3QodHlwZSwgdmFsdWUpIHsKICAgICAgICAgICAgaWYgKHRoaXMuaXNCYXNpY1R5cGUodHlwZSkgJiYgIXRoaXMuaXNEaXNhYmxlZCh0eXBlLCB2YWx1ZSkpIHsKICAgICAgICAgICAgICAgIHRoaXNbdHlwZV0gPSB2YWx1ZQogICAgICAgICAgICAgICAgaWYgKHRoaXMuZG9DbGVhckFwbUNoZWNraW5nKSB7CiAgICAgICAgICAgICAgICAgICAgdGhpcy5kb0NsZWFyQXBtQ2hlY2tpbmcgPSBmYWxzZQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgfSwKCiAgICAgICAgY2xlYXJUaW1lKCkgewogICAgICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCkgeyByZXR1cm4gfQogICAgICAgICAgICB0aGlzLmhvdXIgPSAnJwogICAgICAgICAgICB0aGlzLm1pbnV0ZSA9ICcnCiAgICAgICAgICAgIHRoaXMuc2Vjb25kID0gJycKICAgICAgICAgICAgdGhpcy5hcG0gPSAnJwoKICAgICAgICAgICAgaWYgKHRoaXMubWFudWFsSW5wdXQgJiYgdGhpcy4kcmVmcyAmJiB0aGlzLiRyZWZzLmlucHV0ICYmIHRoaXMuJHJlZnMuaW5wdXQudmFsdWUubGVuZ3RoKSB7CiAgICAgICAgICAgICAgICB0aGlzLiRyZWZzLmlucHV0LnZhbHVlID0gJycKICAgICAgICAgICAgfQoKICAgICAgICAgICAgaWYgKHRoaXMubGF6eSkgewogICAgICAgICAgICAgICAgdGhpcy5maWxsVmFsdWVzKHRydWUpCiAgICAgICAgICAgIH0KICAgICAgICB9LAoKICAgICAgICAvLwogICAgICAgIC8vIEF1dG8tU2Nyb2xsCiAgICAgICAgLy8KCiAgICAgICAgY2hlY2tGb3JBdXRvU2Nyb2xsKCkgewogICAgICAgICAgICBpZiAodGhpcy5pbnB1dElzRW1wdHkpIHsgcmV0dXJuIH0KICAgICAgICAgICAgaWYgKHRoaXMuYXV0b1Njcm9sbCkgewogICAgICAgICAgICAgICAgdGhpcy4kbmV4dFRpY2soKCkgPT4gewogICAgICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsVG9TZWxlY3RlZFZhbHVlcygpCiAgICAgICAgICAgICAgICB9KQogICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuYWR2YW5jZWRLZXlib2FyZCkgewogICAgICAgICAgICAgICAgLy8gQXV0by1mb2N1cyBvbiBzZWxlY3RlZCB2YWx1ZSBpbiB0aGUgZmlyc3QgY29sdW1uIGZvciBhZHZhbmNlZC1rZXlib2FyZAogICAgICAgICAgICAgICAgdGhpcy4kbmV4dFRpY2soKCkgPT4gewogICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0Q29sdW1uID0gdGhpcy5pblVzZS50eXBlc1swXQogICAgICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsVG9TZWxlY3RlZChmaXJzdENvbHVtbiwgdHJ1ZSkKICAgICAgICAgICAgICAgIH0pCiAgICAgICAgICAgIH0KICAgICAgICB9LAoKICAgICAgICBzY3JvbGxUb1NlbGVjdGVkKGNvbHVtbiwgYWxsb3dGYWxsYmFjayA9IGZhbHNlKSB7CiAgICAgICAgICAgIGlmICghdGhpcy50aW1lVmFsdWUgfHwgdGhpcy5pbnB1dElzRW1wdHkpIHsgcmV0dXJuIH0KICAgICAgICAgICAgbGV0IHRhcmdldExpc3QKICAgICAgICAgICAgaWYgKHRoaXMuYXBwZW5kVG9Cb2R5ICYmIHRoaXMuJHJlZnMgJiYgdGhpcy4kcmVmcy5kcm9wZG93bikgewogICAgICAgICAgICAgICAgdGFyZ2V0TGlzdCA9IHRoaXMuJHJlZnMuZHJvcGRvd24ucXVlcnlTZWxlY3RvckFsbChgdWwuJHtjb2x1bW59c2ApWzBdCiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICB0YXJnZXRMaXN0ID0gdGhpcy4kZWwucXVlcnlTZWxlY3RvckFsbChgdWwuJHtjb2x1bW59c2ApWzBdCiAgICAgICAgICAgIH0KICAgICAgICAgICAgbGV0IHRhcmdldFZhbHVlID0gdGhpcy5hY3RpdmVJdGVtSW5Db2woY29sdW1uKVswXQogICAgICAgICAgICBpZiAoIXRhcmdldFZhbHVlICYmIGFsbG93RmFsbGJhY2spIHsKICAgICAgICAgICAgICAgIC8vIE5vIHZhbHVlIHNlbGVjdGVkIGluIHRoZSB0YXJnZXQgY29sdW1uLCBmYWxsYmFjayB0byB0aGUgZmlyc3QgZm91bmQgdmFsaWQgaXRlbQogICAgICAgICAgICAgICAgdGFyZ2V0VmFsdWUgPSB0aGlzLnZhbGlkSXRlbXNJbkNvbChjb2x1bW4pWzBdCiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKHRhcmdldExpc3QgJiYgdGFyZ2V0VmFsdWUpIHsKICAgICAgICAgICAgICAgIHRhcmdldExpc3Quc2Nyb2xsVG9wID0gdGFyZ2V0VmFsdWUub2Zmc2V0VG9wIHx8IDAKICAgICAgICAgICAgICAgIGlmICh0aGlzLmFkdmFuY2VkS2V5Ym9hcmQpIHsKICAgICAgICAgICAgICAgICAgICB0YXJnZXRWYWx1ZS5mb2N1cygpCiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICB9LAoKICAgICAgICBzY3JvbGxUb1NlbGVjdGVkVmFsdWVzKCkgewogICAgICAgICAgICBpZiAoIXRoaXMudGltZVZhbHVlIHx8IHRoaXMuaW5wdXRJc0VtcHR5KSB7IHJldHVybiB9CiAgICAgICAgICAgIHRoaXMuaW5Vc2UudHlwZXMuZm9yRWFjaChzZWN0aW9uID0+IHsKICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsVG9TZWxlY3RlZChzZWN0aW9uKQogICAgICAgICAgICB9KQogICAgICAgIH0sCgogICAgICAgIC8vCiAgICAgICAgLy8gQWRkaXRpb25hbCBLZXlib2FyZCBOYXZpZ2F0aW9uCiAgICAgICAgLy8KCiAgICAgICAgb25Gb2N1cygpIHsKICAgICAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQpIHsgcmV0dXJuIH0KICAgICAgICAgICAgaWYgKCF0aGlzLmlzRm9jdXNpbmcpIHsKICAgICAgICAgICAgICAgIHRoaXMuaXNGb2N1c2luZyA9IHRydWUKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAoIXRoaXMuaXNBY3RpdmUpIHsKICAgICAgICAgICAgICAgIHRoaXMudG9nZ2xlQWN0aXZlKCkKICAgICAgICAgICAgfQogICAgICAgIH0sCgogICAgICAgIGVzY0JsdXIoKSB7CiAgICAgICAgICAgIGlmICh0aGlzLmRpc2FibGVkKSB7IHJldHVybiB9CiAgICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5kZWJvdW5jZVRpbWVyKQogICAgICAgICAgICB0aGlzLmlzRm9jdXNpbmcgPSBmYWxzZQogICAgICAgICAgICBjb25zdCBpbnB1dEJveCA9IHRoaXMuJGVsLnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0LmRpc3BsYXktdGltZScpWzBdCiAgICAgICAgICAgIGlmIChpbnB1dEJveCkgewogICAgICAgICAgICAgICAgaW5wdXRCb3guYmx1cigpCiAgICAgICAgICAgIH0KICAgICAgICB9LAoKICAgICAgICBkZWJvdW5jZUJsdXIoKSB7CiAgICAgICAgICAgIGlmICh0aGlzLmRpc2FibGVkKSB7IHJldHVybiB9CiAgICAgICAgICAgIHRoaXMuaXNGb2N1c2luZyA9IGZhbHNlCiAgICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5kZWJvdW5jZVRpbWVyKQogICAgICAgICAgICB0aGlzLmRlYm91bmNlVGltZXIgPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7CiAgICAgICAgICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMuZGVib3VuY2VUaW1lcikKICAgICAgICAgICAgICAgIHRoaXMub25CbHVyKCkKICAgICAgICAgICAgfSwgdGhpcy5vcHRzLmJsdXJEZWxheSkKICAgICAgICB9LAoKICAgICAgICBvbkJsdXIoKSB7CiAgICAgICAgICAgIGlmICghdGhpcy5kaXNhYmxlZCAmJiAhdGhpcy5pc0ZvY3VzaW5nICYmIHRoaXMuaXNBY3RpdmUpIHsKICAgICAgICAgICAgICAgIHRoaXMudG9nZ2xlQWN0aXZlKCkKICAgICAgICAgICAgfQogICAgICAgIH0sCgogICAgICAgIGtlZXBGb2N1c2luZygpIHsKICAgICAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQpIHsgcmV0dXJuIH0KICAgICAgICAgICAgd2luZG93LmNsZWFyVGltZW91dCh0aGlzLmRlYm91bmNlVGltZXIpCiAgICAgICAgICAgIGlmICghdGhpcy5pc0ZvY3VzaW5nKSB7CiAgICAgICAgICAgICAgICB0aGlzLmlzRm9jdXNpbmcgPSB0cnVlCiAgICAgICAgICAgIH0KICAgICAgICB9LAoKICAgICAgICBvblRhYihjb2x1bW4sIHZhbHVlLCBldnQpIHsKICAgICAgICAgICAgaWYgKHRoaXMuYXBwZW5kVG9Cb2R5ICYmIGV2dC5zaGlmdEtleSkgewogICAgICAgICAgICAgICAgY29uc3QgZmlyc3RDb2x1bW4gPSB0aGlzLmluVXNlLnR5cGVzWzBdCiAgICAgICAgICAgICAgICBpZiAoY29sdW1uICE9PSBmaXJzdENvbHVtbikgeyByZXR1cm4gfQogICAgICAgICAgICAgICAgY29uc3QgZmlyc3RWYWxpZFZhbHVlID0gdGhpcy52YWxpZEl0ZW1zSW5Db2woZmlyc3RDb2x1bW4pWzBdCiAgICAgICAgICAgICAgICAvLyBJcyB0aGUgZmlyc3QgdmFsaWQgaXRlbSBpbiB0aGUgZmlyc3QgY29sdW1uCiAgICAgICAgICAgICAgICBpZiAoZmlyc3RWYWxpZFZhbHVlICYmIGZpcnN0VmFsaWRWYWx1ZS5nZXRBdHRyaWJ1dGUoJ2RhdGEta2V5JykgPT09IFN0cmluZyh2YWx1ZSkpIHsKICAgICAgICAgICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKQogICAgICAgICAgICAgICAgICAgIC8vIEZvY3VzIGJhY2sgb24gPGlucHV0PgogICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLiRyZWZzICYmIHRoaXMuJHJlZnMuaW5wdXQpIHsKICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kcmVmcy5pbnB1dC5mb2N1cygpCiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgfSwKCiAgICAgICAgdmFsaWRJdGVtc0luQ29sKGNvbHVtbikgewogICAgICAgICAgICBjb25zdCBjb2x1bW5DbGFzcyA9IGAke2NvbHVtbn1zYAogICAgICAgICAgICBpZiAodGhpcy5hcHBlbmRUb0JvZHkgJiYgdGhpcy4kcmVmcyAmJiB0aGlzLiRyZWZzLmRyb3Bkb3duKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kcmVmcy5kcm9wZG93bi5xdWVyeVNlbGVjdG9yQWxsKGB1bC4ke2NvbHVtbkNsYXNzfSA+IGxpOm5vdCguaGludCk6bm90KFtkaXNhYmxlZF0pYCkKICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gdGhpcy4kZWwucXVlcnlTZWxlY3RvckFsbChgdWwuJHtjb2x1bW5DbGFzc30gPiBsaTpub3QoLmhpbnQpOm5vdChbZGlzYWJsZWRdKWApCiAgICAgICAgfSwKCiAgICAgICAgYWN0aXZlSXRlbUluQ29sKGNvbHVtbikgewogICAgICAgICAgICBjb25zdCBjb2x1bW5DbGFzcyA9IGAke2NvbHVtbn1zYAogICAgICAgICAgICBpZiAodGhpcy5hcHBlbmRUb0JvZHkgJiYgdGhpcy4kcmVmcyAmJiB0aGlzLiRyZWZzLmRyb3Bkb3duKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kcmVmcy5kcm9wZG93bi5xdWVyeVNlbGVjdG9yQWxsKGB1bC4ke2NvbHVtbkNsYXNzfSA+IGxpLmFjdGl2ZTpub3QoLmhpbnQpYCkKICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gdGhpcy4kZWwucXVlcnlTZWxlY3RvckFsbChgdWwuJHtjb2x1bW5DbGFzc30gPiBsaS5hY3RpdmU6bm90KC5oaW50KWApCiAgICAgICAgfSwKCiAgICAgICAgZ2V0Q2xvc2VzdFNpYmxpbmcoY29sdW1uLCBkYXRhS2V5LCBnZXRQcmV2aW91cyA9IGZhbHNlKSB7CiAgICAgICAgICAgIGNvbnN0IHNpYmxpbmdzSW5Db2wgPSB0aGlzLnZhbGlkSXRlbXNJbkNvbChjb2x1bW4pCiAgICAgICAgICAgIGNvbnN0IHNlbGZJbmRleCA9IEFycmF5LnByb3RvdHlwZS5maW5kSW5kZXguY2FsbChzaWJsaW5nc0luQ29sLCAoc2JsKSA9PiB7CiAgICAgICAgICAgICAgICByZXR1cm4gc2JsLmdldEF0dHJpYnV0ZSgnZGF0YS1rZXknKSA9PT0gZGF0YUtleQogICAgICAgICAgICB9KQoKICAgICAgICAgICAgLy8gQWxyZWFkeSB0aGUgZmlyc3QgaXRlbQogICAgICAgICAgICBpZiAoZ2V0UHJldmlvdXMgJiYgc2VsZkluZGV4ID09PSAwKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gc2libGluZ3NJbkNvbFtzaWJsaW5nc0luQ29sLmxlbmd0aCAtIDFdCiAgICAgICAgICAgIH0KICAgICAgICAgICAgLy8gQWxyZWFkeSB0aGUgbGFzdCBpdGVtCiAgICAgICAgICAgIGlmICghZ2V0UHJldmlvdXMgJiYgc2VsZkluZGV4ID09PSBzaWJsaW5nc0luQ29sLmxlbmd0aCAtIDEpIHsKICAgICAgICAgICAgICAgIHJldHVybiBzaWJsaW5nc0luQ29sWzBdCiAgICAgICAgICAgIH0KICAgICAgICAgICAgLy8gU2VsZWN0ZWQgdmFsdWUgbm90IGluIHRoZSB2YWxpZCB2YWx1ZXMgbGlzdAogICAgICAgICAgICBpZiAoc2VsZkluZGV4IDwgMCkgewogICAgICAgICAgICAgICAgcmV0dXJuIHNpYmxpbmdzSW5Db2xbMF0KICAgICAgICAgICAgfQoKICAgICAgICAgICAgaWYgKGdldFByZXZpb3VzKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gc2libGluZ3NJbkNvbFtzZWxmSW5kZXggLSAxXQogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiBzaWJsaW5nc0luQ29sW3NlbGZJbmRleCArIDFdCiAgICAgICAgfSwKCiAgICAgICAgcHJldkl0ZW0oY29sdW1uLCBkYXRhS2V5LCBpc01hbnVhbElucHV0ID0gZmFsc2UpIHsKICAgICAgICAgICAgY29uc3QgdGFyZ2V0SXRlbSA9IHRoaXMuZ2V0Q2xvc2VzdFNpYmxpbmcoY29sdW1uLCBkYXRhS2V5LCB0cnVlKQogICAgICAgICAgICBpZiAodGFyZ2V0SXRlbSkgewogICAgICAgICAgICAgICAgcmV0dXJuIGlzTWFudWFsSW5wdXQgPyB0YXJnZXRJdGVtIDogdGFyZ2V0SXRlbS5mb2N1cygpCiAgICAgICAgICAgIH0KICAgICAgICB9LAoKICAgICAgICBuZXh0SXRlbShjb2x1bW4sIGRhdGFLZXksIGlzTWFudWFsSW5wdXQgPSBmYWxzZSkgewogICAgICAgICAgICBjb25zdCB0YXJnZXRJdGVtID0gdGhpcy5nZXRDbG9zZXN0U2libGluZyhjb2x1bW4sIGRhdGFLZXksIGZhbHNlKQogICAgICAgICAgICBpZiAodGFyZ2V0SXRlbSkgewogICAgICAgICAgICAgICAgcmV0dXJuIGlzTWFudWFsSW5wdXQgPyB0YXJnZXRJdGVtIDogdGFyZ2V0SXRlbS5mb2N1cygpCiAgICAgICAgICAgIH0KICAgICAgICB9LAoKICAgICAgICBnZXRTaWRlQ29sdW1uTmFtZShjdXJyZW50Q29sdW1uLCB0b0xlZnQgPSBmYWxzZSkgewogICAgICAgICAgICBjb25zdCBjdXJyZW50Q29sdW1uSW5kZXggPSB0aGlzLmluVXNlLnR5cGVzLmluZGV4T2YoY3VycmVudENvbHVtbikKICAgICAgICAgICAgaWYgKHRvTGVmdCAmJiBjdXJyZW50Q29sdW1uSW5kZXggPD0gMCkgewogICAgICAgICAgICAgICAgaWYgKHRoaXMuZGVidWdNb2RlKSB7CiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWJ1Z0xvZygnWW91XCdyZSBpbiB0aGUgbGVmdG1vc3QgbGlzdCBhbHJlYWR5JykKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHJldHVybgogICAgICAgICAgICB9IGVsc2UgaWYgKCF0b0xlZnQgJiYgY3VycmVudENvbHVtbkluZGV4ID09PSAodGhpcy5pblVzZS50eXBlcy5sZW5ndGggLSAxKSkgewogICAgICAgICAgICAgICAgaWYgKHRoaXMuZGVidWdNb2RlKSB7CiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWJ1Z0xvZygnWW91XCdyZSBpbiB0aGUgcmlnaHRtb3N0IGxpc3QgYWxyZWFkeScpCiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICByZXR1cm4KICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gdGhpcy5pblVzZS50eXBlc1t0b0xlZnQgPyBjdXJyZW50Q29sdW1uSW5kZXggLSAxIDogY3VycmVudENvbHVtbkluZGV4ICsgMV0KICAgICAgICB9LAoKICAgICAgICBnZXRGaXJzdEl0ZW1JblNpZGVDb2x1bW4oY3VycmVudENvbHVtbiwgdG9MZWZ0ID0gZmFsc2UpIHsKICAgICAgICAgICAgY29uc3QgdGFyZ2V0Q29sdW1uID0gdGhpcy5nZXRTaWRlQ29sdW1uTmFtZShjdXJyZW50Q29sdW1uLCB0b0xlZnQpCiAgICAgICAgICAgIGlmICghdGFyZ2V0Q29sdW1uKSB7IHJldHVybiB9CiAgICAgICAgICAgIGNvbnN0IGxpc3RJdGVtcyA9IHRoaXMudmFsaWRJdGVtc0luQ29sKHRhcmdldENvbHVtbikKICAgICAgICAgICAgaWYgKGxpc3RJdGVtcyAmJiBsaXN0SXRlbXNbMF0pIHsKICAgICAgICAgICAgICAgIHJldHVybiBsaXN0SXRlbXNbMF0KICAgICAgICAgICAgfQogICAgICAgIH0sCgogICAgICAgIGdldEFjdGl2ZUl0ZW1JblNpZGVDb2x1bW4oY3VycmVudENvbHVtbiwgdG9MZWZ0ID0gZmFsc2UpIHsKICAgICAgICAgICAgY29uc3QgdGFyZ2V0Q29sdW1uID0gdGhpcy5nZXRTaWRlQ29sdW1uTmFtZShjdXJyZW50Q29sdW1uLCB0b0xlZnQpCiAgICAgICAgICAgIGlmICghdGFyZ2V0Q29sdW1uKSB7IHJldHVybiB9CiAgICAgICAgICAgIGNvbnN0IGFjdGl2ZUl0ZW1zID0gdGhpcy5hY3RpdmVJdGVtSW5Db2wodGFyZ2V0Q29sdW1uKQogICAgICAgICAgICBpZiAoYWN0aXZlSXRlbXMgJiYgYWN0aXZlSXRlbXNbMF0pIHsKICAgICAgICAgICAgICAgIHJldHVybiBhY3RpdmVJdGVtc1swXQogICAgICAgICAgICB9CiAgICAgICAgfSwKCiAgICAgICAgdG9MZWZ0Q29sdW1uKGN1cnJlbnRDb2x1bW4pIHsKICAgICAgICAgICAgY29uc3QgdGFyZ2V0SXRlbSA9IHRoaXMuZ2V0QWN0aXZlSXRlbUluU2lkZUNvbHVtbihjdXJyZW50Q29sdW1uLCB0cnVlKSB8fCB0aGlzLmdldEZpcnN0SXRlbUluU2lkZUNvbHVtbihjdXJyZW50Q29sdW1uLCB0cnVlKQogICAgICAgICAgICBpZiAodGFyZ2V0SXRlbSkgewogICAgICAgICAgICAgICAgdGFyZ2V0SXRlbS5mb2N1cygpCiAgICAgICAgICAgIH0KICAgICAgICB9LAoKICAgICAgICB0b1JpZ2h0Q29sdW1uKGN1cnJlbnRDb2x1bW4pIHsKICAgICAgICAgICAgY29uc3QgdGFyZ2V0SXRlbSA9IHRoaXMuZ2V0QWN0aXZlSXRlbUluU2lkZUNvbHVtbihjdXJyZW50Q29sdW1uLCBmYWxzZSkgfHwgdGhpcy5nZXRGaXJzdEl0ZW1JblNpZGVDb2x1bW4oY3VycmVudENvbHVtbiwgZmFsc2UpCiAgICAgICAgICAgIGlmICh0YXJnZXRJdGVtKSB7CiAgICAgICAgICAgICAgICB0YXJnZXRJdGVtLmZvY3VzKCkKICAgICAgICAgICAgfQogICAgICAgIH0sCgogICAgICAgIC8vCiAgICAgICAgLy8gTWFudWFsIElucHV0CiAgICAgICAgLy8KCiAgICAgICAgb25Nb3VzZURvd24oKSB7CiAgICAgICAgICAgIGlmICghdGhpcy5tYW51YWxJbnB1dCkgeyByZXR1cm4gfQogICAgICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMuc2VsZWN0aW9uVGltZXIpCiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uVGltZXIgPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7CiAgICAgICAgICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMuc2VsZWN0aW9uVGltZXIpCiAgICAgICAgICAgICAgICBpZiAodGhpcy4kcmVmcyAmJiB0aGlzLiRyZWZzLmlucHV0KSB7CiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmVhcmVzdFNsb3QgPSB0aGlzLmdldE5lYXJlc3RDaHVua0J5UG9zKHRoaXMuJHJlZnMuaW5wdXQuc2VsZWN0aW9uU3RhcnQgfHwgMCkKICAgICAgICAgICAgICAgICAgICB0aGlzLmRlYm91bmNlU2V0SW5wdXRTZWxlY3Rpb24obmVhcmVzdFNsb3QpCiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0sIDUwKQogICAgICAgIH0sCgogICAgICAgIGtleURvd25IYW5kbGVyKGV2dCkgewogICAgICAgICAgICBpZiAoZXZ0LmlzQ29tcG9zaW5nIHx8IGV2dC5rZXlDb2RlID09PSAyMjkpIHsKICAgICAgICAgICAgICAgIC8vIFNraXAgSU1FIGlucHV0cwogICAgICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCkKICAgICAgICAgICAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKQogICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlCiAgICAgICAgICAgIH0KICAgICAgICAgICAgLy8gTnVtYmVycwogICAgICAgICAgICBpZiAoKGV2dC5rZXlDb2RlID49IDQ4ICYmIGV2dC5rZXlDb2RlIDw9IDU3KSB8fCAoZXZ0LmtleUNvZGUgPj0gOTYgJiYgZXZ0LmtleUNvZGUgPD0gMTA1KSkgewogICAgICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCkKICAgICAgICAgICAgICAgIHRoaXMua2V5Ym9hcmRJbnB1dChldnQua2V5KQogICAgICAgICAgICAgICAgLy8gQXxQfE0KICAgICAgICAgICAgfSBlbHNlIGlmIChbNjUsIDgwLCA3N10uaW5jbHVkZXMoZXZ0LmtleUNvZGUpKSB7CiAgICAgICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKQogICAgICAgICAgICAgICAgdGhpcy5rZXlib2FyZElucHV0KGV2dC5rZXksIHRydWUpCiAgICAgICAgICAgICAgICAvLyBBcnJvdyBrZXlzCiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXZ0LmtleUNvZGUgPj0gMzcgJiYgZXZ0LmtleUNvZGUgPD0gNDApIHsKICAgICAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpCiAgICAgICAgICAgICAgICB0aGlzLmNsZWFyS2JJbnB1dExvZygpCiAgICAgICAgICAgICAgICB0aGlzLmFycm93SGFuZGxlcihldnQpCiAgICAgICAgICAgICAgICAvLyBEZWxldGV8QmFja3NwYWNlCiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXZ0LmtleUNvZGUgPT09IDggfHwgZXZ0LmtleUNvZGUgPT09IDQ2KSB7CiAgICAgICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKQogICAgICAgICAgICAgICAgdGhpcy5jbGVhcktiSW5wdXRMb2coKQogICAgICAgICAgICAgICAgdGhpcy5jbGVhclRpbWUoKQogICAgICAgICAgICAgICAgLy8gVGFiCiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXZ0LmtleUNvZGUgPT09IDkpIHsKICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJLYklucHV0TG9nKCkKICAgICAgICAgICAgICAgIHRoaXMudGFiSGFuZGxlcihldnQpCiAgICAgICAgICAgICAgICAvLyBDb2xvbnxTcGFjZQogICAgICAgICAgICB9IGVsc2UgaWYgKGV2dC5rZXlDb2RlID09PSAxODYgfHwgZXZ0LmtleUNvZGUgPT09IDMyKSB7CiAgICAgICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKQogICAgICAgICAgICAgICAgdGhpcy5jbGVhcktiSW5wdXRMb2coKQogICAgICAgICAgICAgICAgdGhpcy50b05leHRTbG90KCkKICAgICAgICAgICAgICAgIC8vIFByZXZlbnQgYW55IE5vbi1FU0MgYW5kIG5vbi1wYXN0aW5nIGlucHV0cwogICAgICAgICAgICB9IGVsc2UgaWYgKGV2dC5rZXlDb2RlICE9PSAyNyAmJiAhKGV2dC5tZXRhS2V5IHx8IGV2dC5jdHJsS2V5KSkgewogICAgICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCkKICAgICAgICAgICAgfQogICAgICAgIH0sCgogICAgICAgIG9uQ29tcG9zdGlvblN0YXJ0KGV2dCkgewogICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKQogICAgICAgICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCkKICAgICAgICAgICAgdGhpcy5iYWtDdXJyZW50UG9zID0gdGhpcy5nZXRDdXJyZW50VG9rZW5DaHVuaygpCiAgICAgICAgICAgIHJldHVybiBmYWxzZQogICAgICAgIH0sCgogICAgICAgIG9uQ29tcG9zdGlvbkVuZChldnQpIHsKICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCkKICAgICAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpCgogICAgICAgICAgICBjb25zdCBjcHNEYXRhID0gZXZ0LmRhdGEKICAgICAgICAgICAgbGV0IGlucHV0SXNDdXN0b21BcG1UZXh0ID0gZmFsc2UKICAgICAgICAgICAgaWYgKHRoaXMuaGFzLmN1c3RvbUFwbVRleHQpIHsKICAgICAgICAgICAgICAgIGlucHV0SXNDdXN0b21BcG1UZXh0ID0gdGhpcy5pc0N1c3RvbUFwbVRleHQoY3BzRGF0YSkKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAoaW5wdXRJc0N1c3RvbUFwbVRleHQpIHsKICAgICAgICAgICAgICAgIHRoaXMuc2V0U2FuaXRpemVkVmFsdWVUb1NlY3Rpb24oJ2FwbScsIGlucHV0SXNDdXN0b21BcG1UZXh0KQogICAgICAgICAgICB9CgogICAgICAgICAgICB0aGlzLiRyZWZzLmlucHV0LnZhbHVlID0gdGhpcy5oYXMuY3VzdG9tQXBtVGV4dCA/IHRoaXMuY3VzdG9tRGlzcGxheVRpbWUgOiB0aGlzLmRpc3BsYXlUaW1lCgogICAgICAgICAgICB0aGlzLiRuZXh0VGljaygoKSA9PiB7CiAgICAgICAgICAgICAgICBpZiAodGhpcy5iYWtDdXJyZW50UG9zKSB7CiAgICAgICAgICAgICAgICAgICAgY29uc3QgYmFrUG9zID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0aGlzLmJha0N1cnJlbnRQb3MpKQogICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dElzQ3VzdG9tQXBtVGV4dCkgewogICAgICAgICAgICAgICAgICAgICAgICBiYWtQb3MuZW5kID0gKGJha1Bvcy5zdGFydCArIGNwc0RhdGEubGVuZ3RoKQogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICB0aGlzLmRlYm91bmNlU2V0SW5wdXRTZWxlY3Rpb24oYmFrUG9zKQogICAgICAgICAgICAgICAgICAgIHRoaXMuYmFrQ3VycmVudFBvcyA9IG51bGwKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSkKICAgICAgICAgICAgcmV0dXJuIGZhbHNlCiAgICAgICAgfSwKCiAgICAgICAgcGFzdGVIYW5kbGVyKGV2dCkgewogICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKQogICAgICAgICAgICBsZXQgcGFzdGluZ1RleHQgPSAoZXZ0LmNsaXBib2FyZERhdGEgfHwgd2luZG93LmNsaXBib2FyZERhdGEpLmdldERhdGEoJ3RleHQnKQogICAgICAgICAgICBpZiAodGhpcy5kZWJ1Z01vZGUpIHsKICAgICAgICAgICAgICAgIHRoaXMuZGVidWdMb2coYFBhc3RpbmcgdmFsdWUgIiR7cGFzdGluZ1RleHR9IiBmcm9tIGNsaXBib2FyZGApCiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKCFwYXN0aW5nVGV4dCB8fCAhcGFzdGluZ1RleHQubGVuZ3RoKSB7IHJldHVybiB9CgogICAgICAgICAgICAvLyBSZXBsYWNlIGN1c3RvbSBBTS9QTSB0ZXh0IChpZiBhbnkpCiAgICAgICAgICAgIGlmICh0aGlzLmhhcy5jdXN0b21BcG1UZXh0KSB7CiAgICAgICAgICAgICAgICBwYXN0aW5nVGV4dCA9IHRoaXMucmVwbGFjZUN1c3RvbUFwbVRleHQocGFzdGluZ1RleHQpCiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIGlmICh0aGlzLmlucHV0SXNFbXB0eSkgewogICAgICAgICAgICAgICAgdGhpcy5yZWFkU3RyaW5nVmFsdWVzKHBhc3RpbmdUZXh0KQogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgdGhpcy5rYklucHV0TG9nID0gcGFzdGluZ1RleHQuc3Vic3RyKC0yLCAyKQogICAgICAgICAgICAgICAgdGhpcy5zZXRLYklucHV0KCkKICAgICAgICAgICAgICAgIHRoaXMuZGVib3VuY2VDbGVhcktiTG9nKCkKICAgICAgICAgICAgfQogICAgICAgIH0sCgogICAgICAgIGFycm93SGFuZGxlcihldnQpIHsKICAgICAgICAgICAgY29uc3QgZGlyZWN0aW9uID0geyAzNzogJ0wnLCAzODogJ1UnLCAzOTogJ1InLCA0MDogJ0QnIH1bZXZ0LmtleUNvZGVdCiAgICAgICAgICAgIGlmIChkaXJlY3Rpb24gPT09ICdVJyB8fCBkaXJlY3Rpb24gPT09ICdEJykgewogICAgICAgICAgICAgICAgaWYgKHRoaXMuaW5wdXRJc0VtcHR5KSB7CiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RGaXJzdFZhbGlkVmFsdWUoKQogICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50Q2h1bmsgPSB0aGlzLmdldEN1cnJlbnRUb2tlbkNodW5rKCkKICAgICAgICAgICAgICAgICAgICBpZiAoIWN1cnJlbnRDaHVuaykgewogICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdEZpcnN0VmFsaWRWYWx1ZSgpCiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybgogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBjb25zdCB0b2tlblR5cGUgPSBjdXJyZW50Q2h1bmsudHlwZQogICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0Q2xvc2VzdFZhbGlkSXRlbUluQ29sKHRva2VuVHlwZSwgdGhpc1t0b2tlblR5cGVdLCBkaXJlY3Rpb24pCiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3Q2h1bmtQb3MgPSB0aGlzLmdldEN1cnJlbnRUb2tlbkNodW5rKCkKICAgICAgICAgICAgICAgICAgICB0aGlzLmRlYm91bmNlU2V0SW5wdXRTZWxlY3Rpb24obmV3Q2h1bmtQb3MpCiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSAnUicpIHsKICAgICAgICAgICAgICAgIHRoaXMudG9MYXRlcmFsVG9rZW4oZmFsc2UpCiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSAnTCcpIHsKICAgICAgICAgICAgICAgIHRoaXMudG9MYXRlcmFsVG9rZW4odHJ1ZSkKICAgICAgICAgICAgfQogICAgICAgIH0sCgogICAgICAgIHRhYkhhbmRsZXIoZXZ0KSB7CiAgICAgICAgICAgIGlmICghdGhpcy5pbnB1dElzRW1wdHkgJiYgdGhpcy50b2tlbkNodW5rc1BvcyAmJiB0aGlzLnRva2VuQ2h1bmtzUG9zLmxlbmd0aCkgewogICAgICAgICAgICAgICAgY29uc3QgY3VycmVudENodW5rID0gdGhpcy5nZXRDdXJyZW50VG9rZW5DaHVuaygpCiAgICAgICAgICAgICAgICBpZiAoIWN1cnJlbnRDaHVuaykgeyByZXR1cm4gfQogICAgICAgICAgICAgICAgY29uc3QgZmlyc3RDaHVuayA9IHRoaXMudG9rZW5DaHVua3NQb3NbMF0KICAgICAgICAgICAgICAgIGNvbnN0IGxhc3RDaHVuayA9IHRoaXMudG9rZW5DaHVua3NQb3NbdGhpcy50b2tlbkNodW5rc1Bvcy5sZW5ndGggLSAxXQogICAgICAgICAgICAgICAgaWYgKChldnQuc2hpZnRLZXkgJiYgY3VycmVudENodW5rLnRva2VuICE9PSBmaXJzdENodW5rLnRva2VuKSB8fCAoIWV2dC5zaGlmdEtleSAmJiBjdXJyZW50Q2h1bmsudG9rZW4gIT09IGxhc3RDaHVuay50b2tlbikpIHsKICAgICAgICAgICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKQogICAgICAgICAgICAgICAgICAgIHRoaXMudG9MYXRlcmFsVG9rZW4oZXZ0LnNoaWZ0S2V5KQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuYXBwZW5kVG9Cb2R5ICYmIHRoaXMuYWR2YW5jZWRLZXlib2FyZCkgewogICAgICAgICAgICAgICAgaWYgKGV2dC5zaGlmdEtleSkgeyByZXR1cm4gfQogICAgICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCkKICAgICAgICAgICAgICAgIGlmICh0aGlzLmlucHV0SXNFbXB0eSkgewogICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0Q29sdW1uID0gdGhpcy5pblVzZS50eXBlc1swXQogICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldFZhbHVlID0gdGhpcy52YWxpZEl0ZW1zSW5Db2woZmlyc3RDb2x1bW4pWzBdCiAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldFZhbHVlKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFZhbHVlLmZvY3VzKCkKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICB9LAoKICAgICAgICBrZXlib2FyZElucHV0KG5ld0NoYXIsIGlzQXBtID0gZmFsc2UpIHsKICAgICAgICAgICAgY29uc3QgY3VycmVudENodW5rID0gdGhpcy5nZXRDdXJyZW50VG9rZW5DaHVuaygpCiAgICAgICAgICAgIGlmICghY3VycmVudENodW5rIHx8IChjdXJyZW50Q2h1bmsudHlwZSAhPT0gJ2FwbScgJiYgaXNBcG0pIHx8IChjdXJyZW50Q2h1bmsudHlwZSA9PT0gJ2FwbScgJiYgIWlzQXBtKSkgeyByZXR1cm4gfQogICAgICAgICAgICB0aGlzLmtiSW5wdXRMb2cgPSBgJHt0aGlzLmtiSW5wdXRMb2cuc3Vic3RyKC0xKX0ke25ld0NoYXJ9YAogICAgICAgICAgICB0aGlzLnNldEtiSW5wdXQoKQogICAgICAgICAgICB0aGlzLmRlYm91bmNlQ2xlYXJLYkxvZygpCiAgICAgICAgfSwKCiAgICAgICAgY2xlYXJLYklucHV0TG9nKCkgewogICAgICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMua2JJbnB1dFRpbWVyKQogICAgICAgICAgICB0aGlzLmtiSW5wdXRMb2cgPSAnJwogICAgICAgIH0sCgogICAgICAgIGRlYm91bmNlQ2xlYXJLYkxvZygpIHsKICAgICAgICAgICAgd2luZG93LmNsZWFyVGltZW91dCh0aGlzLmtiSW5wdXRUaW1lcikKICAgICAgICAgICAgdGhpcy5rYklucHV0VGltZXIgPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7CiAgICAgICAgICAgICAgICB0aGlzLmNsZWFyS2JJbnB1dExvZygpCiAgICAgICAgICAgIH0sIHRoaXMub3B0cy5tYW51YWxJbnB1dFRpbWVvdXQpCiAgICAgICAgfSwKCiAgICAgICAgc2V0S2JJbnB1dCh2YWx1ZSkgewogICAgICAgICAgICB2YWx1ZSA9IHZhbHVlIHx8IHRoaXMua2JJbnB1dExvZwogICAgICAgICAgICBjb25zdCBjdXJyZW50Q2h1bmsgPSB0aGlzLmdldEN1cnJlbnRUb2tlbkNodW5rKCkKICAgICAgICAgICAgaWYgKCFjdXJyZW50Q2h1bmsgfHwgIXZhbHVlIHx8ICF2YWx1ZS5sZW5ndGgpIHsgcmV0dXJuIH0KICAgICAgICAgICAgY29uc3QgY2h1bmtUeXBlID0gY3VycmVudENodW5rLnR5cGUKICAgICAgICAgICAgY29uc3QgY2h1bmtUb2tlbiA9IGN1cnJlbnRDaHVuay50b2tlbgoKICAgICAgICAgICAgbGV0IHZhbGlkVmFsdWUKICAgICAgICAgICAgaWYgKGNodW5rVHlwZSA9PT0gJ2FwbScpIHsKICAgICAgICAgICAgICAgIGlmICh0aGlzLmxvd2VyQ2FzZWRBcG0odmFsdWUpLmluY2x1ZGVzKCdhJykpIHsKICAgICAgICAgICAgICAgICAgICB2YWxpZFZhbHVlID0gJ2FtJwogICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmxvd2VyQ2FzZWRBcG0odmFsdWUpLmluY2x1ZGVzKCdwJykpIHsKICAgICAgICAgICAgICAgICAgICB2YWxpZFZhbHVlID0gJ3BtJwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKHZhbGlkVmFsdWUpIHsKICAgICAgICAgICAgICAgICAgICB2YWxpZFZhbHVlID0gY2h1bmtUb2tlbiA9PT0gJ0EnID8gdmFsaWRWYWx1ZS50b1VwcGVyQ2FzZSgpIDogdmFsaWRWYWx1ZQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNWYWxpZFZhbHVlKGNodW5rVG9rZW4sIHZhbHVlKSkgewogICAgICAgICAgICAgICAgICAgIHZhbGlkVmFsdWUgPSB2YWx1ZQogICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICBjb25zdCBsYXN0SW5wdXRWYWx1ZSA9IHRoaXMuZm9ybWF0VmFsdWUoY2h1bmtUb2tlbiwgdmFsdWUuc3Vic3RyKC0xKSkKICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pc1ZhbGlkVmFsdWUoY2h1bmtUb2tlbiwgbGFzdElucHV0VmFsdWUpKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkVmFsdWUgPSBsYXN0SW5wdXRWYWx1ZQogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQoKICAgICAgICAgICAgaWYgKHZhbGlkVmFsdWUpIHsKICAgICAgICAgICAgICAgIHRoaXMuc2V0U2FuaXRpemVkVmFsdWVUb1NlY3Rpb24oY2h1bmtUeXBlLCB2YWxpZFZhbHVlKQogICAgICAgICAgICAgICAgY29uc3QgbmV3Q2h1bmtQb3MgPSB0aGlzLmdldEN1cnJlbnRUb2tlbkNodW5rKCkKICAgICAgICAgICAgICAgIHRoaXMuZGVib3VuY2VTZXRJbnB1dFNlbGVjdGlvbihuZXdDaHVua1BvcykKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAodGhpcy5kZWJ1Z01vZGUpIHsKICAgICAgICAgICAgICAgIGlmICh2YWxpZFZhbHVlKSB7CiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWJ1Z0xvZyhgU3VjY2Vzc2Z1bGx5IHNldCB2YWx1ZSAiJHt2YWxpZFZhbHVlfSIgZnJvbSBsYXRlc3QgaW5wdXQgIiR7dmFsdWV9IiBmb3IgdGhlICIke2NodW5rVHlwZX0iIHNsb3RgKQogICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICB0aGlzLmRlYnVnTG9nKGBWYWx1ZSAiJHt2YWx1ZX0iIGlzIGludmFsaWQgaW4gdGhlICIke2NodW5rVHlwZX0iIHNsb3RgKQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgfSwKCiAgICAgICAgLy8gRm9ybSBBdXRvZmlsbAogICAgICAgIG9uQ2hhbmdlKCkgewogICAgICAgICAgICBpZiAoIXRoaXMubWFudWFsSW5wdXQgfHwgIXRoaXMuJHJlZnMgfHwgIXRoaXMuJHJlZnMuaW5wdXQpIHsgcmV0dXJuIH0KICAgICAgICAgICAgY29uc3QgYXV0b0ZpbGxWYWx1ZSA9IHRoaXMuJHJlZnMuaW5wdXQudmFsdWUgfHwgJycKICAgICAgICAgICAgaWYgKGF1dG9GaWxsVmFsdWUgJiYgYXV0b0ZpbGxWYWx1ZS5sZW5ndGgpIHsKICAgICAgICAgICAgICAgIHRoaXMucmVhZFN0cmluZ1ZhbHVlcyhhdXRvRmlsbFZhbHVlKQogICAgICAgICAgICB9CiAgICAgICAgfSwKCiAgICAgICAgZ2V0TmVhcmVzdENodW5rQnlQb3Moc3RhcnRQb3MpIHsKICAgICAgICAgICAgaWYgKCF0aGlzLnRva2VuQ2h1bmtzUG9zIHx8ICF0aGlzLnRva2VuQ2h1bmtzUG9zLmxlbmd0aCkgeyByZXR1cm4gfQogICAgICAgICAgICBsZXQgbmVhcmVzdAogICAgICAgICAgICBsZXQgbmVhcmVzdERlbHRhID0gLTEKICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnRva2VuQ2h1bmtzUG9zLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgICAgICAgICBjb25zdCBjaHVuayA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodGhpcy50b2tlbkNodW5rc1Bvc1tpXSkpCiAgICAgICAgICAgICAgICBpZiAoY2h1bmsuc3RhcnQgPT09IHN0YXJ0UG9zKSB7CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNodW5rCiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBjb25zdCBkZWx0YSA9IE1hdGguYWJzKGNodW5rLnN0YXJ0IC0gc3RhcnRQb3MpCiAgICAgICAgICAgICAgICBpZiAobmVhcmVzdERlbHRhIDwgMCkgewogICAgICAgICAgICAgICAgICAgIG5lYXJlc3QgPSBjaHVuawogICAgICAgICAgICAgICAgICAgIG5lYXJlc3REZWx0YSA9IGRlbHRhCiAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgIGlmIChuZWFyZXN0RGVsdGEgPD0gZGVsdGEpIHsKICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5lYXJlc3QKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgbmVhcmVzdERlbHRhID0gZGVsdGEKICAgICAgICAgICAgICAgICAgICBuZWFyZXN0ID0gY2h1bmsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gbmVhcmVzdAogICAgICAgIH0sCgogICAgICAgIHNlbGVjdEZpcnN0VmFsaWRWYWx1ZSgpIHsKICAgICAgICAgICAgaWYgKCF0aGlzLnRva2VuQ2h1bmtzUG9zIHx8ICF0aGlzLnRva2VuQ2h1bmtzUG9zLmxlbmd0aCkgeyByZXR1cm4gfQogICAgICAgICAgICBjb25zdCBmaXJzdFNsb3RUeXBlID0gdGhpcy50b2tlbkNodW5rc1Bvc1swXS50eXBlCiAgICAgICAgICAgIGlmIChmaXJzdFNsb3RUeXBlID09PSAnaG91cicpIHsKICAgICAgICAgICAgICAgIHRoaXMuZ2V0Q2xvc2VzdEhvdXJJdGVtKCkKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIHRoaXMuZ2V0Q2xvc2VzdFZhbGlkSXRlbUluQ29sKGZpcnN0U2xvdFR5cGUsIHRoaXNbZmlyc3RTbG90VHlwZV0pCiAgICAgICAgICAgIH0KICAgICAgICAgICAgdGhpcy5zZWxlY3RGaXJzdFNsb3QoKQogICAgICAgIH0sCgogICAgICAgIGdldENsb3Nlc3RIb3VySXRlbShjdXJyZW50VmFsdWUsIGRpcmVjdGlvbiA9ICdVJykgewogICAgICAgICAgICBpZiAoIXRoaXMudmFsaWRIb3Vyc0xpc3QgfHwgIXRoaXMudmFsaWRIb3Vyc0xpc3QubGVuZ3RoKSB7CiAgICAgICAgICAgICAgICBpZiAodGhpcy5kZWJ1Z01vZGUpIHsKICAgICAgICAgICAgICAgICAgICB0aGlzLmRlYnVnTG9nKGBObyB2YWxpZCBob3VyIHZhbHVlcyBmb3VuZCwgcGxlYXNlIGNoZWNrIHlvdXIgImhvdXItcmFuZ2UiIGNvbmZpZ1xuaG91ci1yYW5nZTogJHtKU09OLnN0cmluZ2lmeSh0aGlzLmhvdXJSYW5nZSl9YCkKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHJldHVybgogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmICghY3VycmVudFZhbHVlKSB7CiAgICAgICAgICAgICAgICB0aGlzLnNldE1hbnVhbEhvdXIodGhpcy52YWxpZEhvdXJzTGlzdFswXSkKICAgICAgICAgICAgICAgIHJldHVybgogICAgICAgICAgICB9CiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRJbmRleCA9IHRoaXMudmFsaWRIb3Vyc0xpc3QuZmluZEluZGV4KGl0ZW0gPT4gewogICAgICAgICAgICAgICAgaWYgKCF0aGlzLmJhc2VPbjEySG91cnMpIHsKICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlbSA9PT0gY3VycmVudFZhbHVlCiAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlS2V5ID0gYCR7Y3VycmVudFZhbHVlfSR7dGhpcy5sb3dlckNhc2VkQXBtKHRoaXMuYXBtKSA9PT0gJ3BtJyA/ICdwJyA6ICdhJ31gCiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW0gPT09IHZhbHVlS2V5CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0pCiAgICAgICAgICAgIGxldCBuZXh0SW5kZXgKICAgICAgICAgICAgaWYgKGN1cnJlbnRJbmRleCA9PT0gLTEpIHsKICAgICAgICAgICAgICAgIG5leHRJbmRleCA9IDAKICAgICAgICAgICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPT09ICdEJykgewogICAgICAgICAgICAgICAgbmV4dEluZGV4ID0gY3VycmVudEluZGV4ID09PSAwID8gdGhpcy52YWxpZEhvdXJzTGlzdC5sZW5ndGggLSAxIDogY3VycmVudEluZGV4IC0gMQogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgbmV4dEluZGV4ID0gKGN1cnJlbnRJbmRleCArIDEpICUgdGhpcy52YWxpZEhvdXJzTGlzdC5sZW5ndGgKICAgICAgICAgICAgfQogICAgICAgICAgICBjb25zdCBuZXh0SXRlbSA9IHRoaXMudmFsaWRIb3Vyc0xpc3RbbmV4dEluZGV4XQogICAgICAgICAgICB0aGlzLnNldE1hbnVhbEhvdXIobmV4dEl0ZW0pCiAgICAgICAgfSwKCiAgICAgICAgZ2V0Q2xvc2VzdFZhbGlkSXRlbUluQ29sKGNvbHVtbiwgY3VycmVudFZhbHVlLCBkaXJlY3Rpb24gPSAnVScpIHsKICAgICAgICAgICAgaWYgKGNvbHVtbiA9PT0gJ2hvdXInKSB7CiAgICAgICAgICAgICAgICB0aGlzLmdldENsb3Nlc3RIb3VySXRlbShjdXJyZW50VmFsdWUsIGRpcmVjdGlvbikKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIGNvbnN0IG5leHRJdGVtID0gZGlyZWN0aW9uID09PSAnRCcgPyB0aGlzLnByZXZJdGVtKGNvbHVtbiwgdGhpc1tjb2x1bW5dLCB0cnVlKSA6IHRoaXMubmV4dEl0ZW0oY29sdW1uLCB0aGlzW2NvbHVtbl0sIHRydWUpCiAgICAgICAgICAgICAgICBpZiAobmV4dEl0ZW0pIHsKICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdChjb2x1bW4sIG5leHRJdGVtLmdldEF0dHJpYnV0ZSgnZGF0YS1rZXknKSkKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgIH0sCgogICAgICAgIHNldFNhbml0aXplZFZhbHVlVG9TZWN0aW9uKHNlY3Rpb24sIGlucHV0VmFsdWUpIHsKICAgICAgICAgICAgaWYgKCFzZWN0aW9uIHx8ICF0aGlzLmdldFRva2VuQnlUeXBlKHNlY3Rpb24pKSB7IHJldHVybiB9CiAgICAgICAgICAgIC8vIE5PVEU6IERpc2FibGVkIHZhbHVlcyBhcmUgYWxsb3dlZCBoZXJlLCBmb2xsb3dlZCBieSBhbiAnZXJyb3InIGV2ZW50LCB0aG91Z2gKICAgICAgICAgICAgY29uc3Qgc2FuaXRpemVkVmFsdWUgPSB0aGlzLnNhbml0aXplZFZhbHVlKHRoaXMuZ2V0VG9rZW5CeVR5cGUoc2VjdGlvbiksIGlucHV0VmFsdWUpCiAgICAgICAgICAgIHRoaXNbc2VjdGlvbl0gPSBzYW5pdGl6ZWRWYWx1ZQogICAgICAgIH0sCgogICAgICAgIHNldE1hbnVhbEhvdXIobmV4dEl0ZW0pIHsKICAgICAgICAgICAgaWYgKHRoaXMuaXMxMmhSYW5nZShuZXh0SXRlbSkpIHsKICAgICAgICAgICAgICAgIGNvbnN0IGhvdXJUID0gdGhpcy5tYXRjaDEyaFJhbmdlKG5leHRJdGVtKQogICAgICAgICAgICAgICAgY29uc3QgYXBtVmFsdWUgPSBob3VyVFsyXSA9PT0gJ2EnID8gJ0FNJyA6ICdQTScKICAgICAgICAgICAgICAgIHRoaXMuc2V0U2FuaXRpemVkVmFsdWVUb1NlY3Rpb24oJ2FwbScsIHRoaXMuYXBtVHlwZSA9PT0gJ2EnID8gYXBtVmFsdWUudG9Mb3dlckNhc2UoKSA6IGFwbVZhbHVlKQogICAgICAgICAgICAgICAgdGhpcy5zZXRTYW5pdGl6ZWRWYWx1ZVRvU2VjdGlvbignaG91cicsIGhvdXJUWzFdKQogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgdGhpcy5zZXRTYW5pdGl6ZWRWYWx1ZVRvU2VjdGlvbignaG91cicsIG5leHRJdGVtKQogICAgICAgICAgICB9CiAgICAgICAgfSwKCiAgICAgICAgZGVib3VuY2VTZXRJbnB1dFNlbGVjdGlvbih7IHN0YXJ0ID0gMCwgZW5kID0gMCB9KSB7CiAgICAgICAgICAgIHRoaXMuJG5leHRUaWNrKCgpID0+IHsKICAgICAgICAgICAgICAgIHRoaXMuc2V0SW5wdXRTZWxlY3Rpb25SYW5nZShzdGFydCwgZW5kKQogICAgICAgICAgICB9KQogICAgICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMuc2VsZWN0aW9uVGltZXIpCiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uVGltZXIgPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7CiAgICAgICAgICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMuc2VsZWN0aW9uVGltZXIpCiAgICAgICAgICAgICAgICAvLyBEb3VibGUtY2hlY2sgc2VsZWN0aW9uIGZvciAxMmhyIGZvcm1hdAogICAgICAgICAgICAgICAgaWYgKHRoaXMuJHJlZnMuaW5wdXQgJiYgKHRoaXMuJHJlZnMuaW5wdXQuc2VsZWN0aW9uU3RhcnQgIT09IHN0YXJ0IHx8IHRoaXMuJHJlZnMuaW5wdXQuc2VsZWN0aW9uRW5kICE9PSBlbmQpKSB7CiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRJbnB1dFNlbGVjdGlvblJhbmdlKHN0YXJ0LCBlbmQpCiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0sIDMwKQogICAgICAgIH0sCgogICAgICAgIHNldElucHV0U2VsZWN0aW9uUmFuZ2Uoc3RhcnQsIGVuZCkgewogICAgICAgICAgICBpZiAodGhpcy4kcmVmcyAmJiB0aGlzLiRyZWZzLmlucHV0KSB7CiAgICAgICAgICAgICAgICB0aGlzLiRyZWZzLmlucHV0LnNldFNlbGVjdGlvblJhbmdlKHN0YXJ0LCBlbmQpCiAgICAgICAgICAgIH0KICAgICAgICB9LAoKICAgICAgICBnZXRDdXJyZW50VG9rZW5DaHVuaygpIHsKICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TmVhcmVzdENodW5rQnlQb3MoKHRoaXMuJHJlZnMuaW5wdXQgJiYgdGhpcy4kcmVmcy5pbnB1dC5zZWxlY3Rpb25TdGFydCkgfHwgMCkKICAgICAgICB9LAoKICAgICAgICBzZWxlY3RGaXJzdFNsb3QoKSB7CiAgICAgICAgICAgIGNvbnN0IGZpcnN0Q2h1bmtQb3MgPSB0aGlzLmdldE5lYXJlc3RDaHVua0J5UG9zKDApCiAgICAgICAgICAgIHRoaXMuZGVib3VuY2VTZXRJbnB1dFNlbGVjdGlvbihmaXJzdENodW5rUG9zKQogICAgICAgIH0sCgogICAgICAgIHRvTmV4dFNsb3QoKSB7CiAgICAgICAgICAgIGlmICghdGhpcy5pbnB1dElzRW1wdHkgJiYgdGhpcy50b2tlbkNodW5rc1BvcyAmJiB0aGlzLnRva2VuQ2h1bmtzUG9zLmxlbmd0aCkgewogICAgICAgICAgICAgICAgY29uc3QgY3VycmVudENodW5rID0gdGhpcy5nZXRDdXJyZW50VG9rZW5DaHVuaygpCiAgICAgICAgICAgICAgICBpZiAoIWN1cnJlbnRDaHVuaykgeyByZXR1cm4gfQogICAgICAgICAgICAgICAgY29uc3QgbGFzdENodW5rID0gdGhpcy50b2tlbkNodW5rc1Bvc1t0aGlzLnRva2VuQ2h1bmtzUG9zLmxlbmd0aCAtIDFdCiAgICAgICAgICAgICAgICBpZiAoY3VycmVudENodW5rLnRva2VuICE9PSBsYXN0Q2h1bmsudG9rZW4pIHsKICAgICAgICAgICAgICAgICAgICB0aGlzLnRvTGF0ZXJhbFRva2VuKGZhbHNlKQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgfSwKCiAgICAgICAgdG9MYXRlcmFsVG9rZW4odG9MZWZ0KSB7CiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRDaHVuayA9IHRoaXMuZ2V0Q3VycmVudFRva2VuQ2h1bmsoKQogICAgICAgICAgICBpZiAoIWN1cnJlbnRDaHVuaykgewogICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RGaXJzdFZhbGlkVmFsdWUoKQogICAgICAgICAgICAgICAgcmV0dXJuCiAgICAgICAgICAgIH0KICAgICAgICAgICAgY29uc3QgY3VycmVudENodW5rSW5kZXggPSB0aGlzLnRva2VuQ2h1bmtzUG9zLmZpbmRJbmRleChjaGsgPT4gY2hrLnRva2VuID09PSBjdXJyZW50Q2h1bmsudG9rZW4pCiAgICAgICAgICAgIGlmICgoIXRvTGVmdCAmJiBjdXJyZW50Q2h1bmtJbmRleCA+PSB0aGlzLnRva2VuQ2h1bmtzUG9zLmxlbmd0aCAtIDEpIHx8ICh0b0xlZnQgJiYgY3VycmVudENodW5rSW5kZXggPT09IDApKSB7CiAgICAgICAgICAgICAgICBpZiAodGhpcy5kZWJ1Z01vZGUpIHsKICAgICAgICAgICAgICAgICAgICBpZiAodG9MZWZ0KSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVidWdMb2coJ1lvdVwncmUgaW4gdGhlIGxlZnRtb3N0IHNsb3QgYWxyZWFkeScpCiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWJ1Z0xvZygnWW91XCdyZSBpbiB0aGUgcmlnaHRtb3N0IHNsb3QgYWxyZWFkeScpCiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgcmV0dXJuCiAgICAgICAgICAgIH0KICAgICAgICAgICAgY29uc3QgdGFyZ2V0U2xvdFBvcyA9IHRvTGVmdCA/IHRoaXMudG9rZW5DaHVua3NQb3NbY3VycmVudENodW5rSW5kZXggLSAxXSA6IHRoaXMudG9rZW5DaHVua3NQb3NbY3VycmVudENodW5rSW5kZXggKyAxXQogICAgICAgICAgICB0aGlzLmRlYm91bmNlU2V0SW5wdXRTZWxlY3Rpb24odGFyZ2V0U2xvdFBvcykKICAgICAgICB9LAoKICAgICAgICBpc0N1c3RvbUFwbVRleHQoaW5wdXREYXRhKSB7CiAgICAgICAgICAgIGlmICghaW5wdXREYXRhIHx8ICFpbnB1dERhdGEubGVuZ3RoKSB7IHJldHVybiBmYWxzZSB9CiAgICAgICAgICAgIGlmICh0aGlzLmFtVGV4dCAmJiB0aGlzLmFtVGV4dCA9PT0gaW5wdXREYXRhKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hcG1UeXBlID09PSAnQScgPyAnQU0nIDogJ2FtJwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmICh0aGlzLnBtVGV4dCAmJiB0aGlzLnBtVGV4dCA9PT0gaW5wdXREYXRhKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hcG1UeXBlID09PSAnQScgPyAnUE0nIDogJ3BtJwogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiBmYWxzZQogICAgICAgIH0sCgogICAgICAgIHJlcGxhY2VDdXN0b21BcG1UZXh0KGlucHV0U3RyaW5nKSB7CiAgICAgICAgICAgIGlmICh0aGlzLmFtVGV4dCAmJiB0aGlzLmFtVGV4dC5sZW5ndGggJiYgaW5wdXRTdHJpbmcuaW5jbHVkZXModGhpcy5hbVRleHQpKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gaW5wdXRTdHJpbmcucmVwbGFjZShuZXcgUmVnRXhwKHRoaXMuYW1UZXh0LCAnZycpLCB0aGlzLmFwbVR5cGUgPT09ICdBJyA/ICdBTScgOiAnYW0nKQogICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucG1UZXh0ICYmIHRoaXMucG1UZXh0Lmxlbmd0aCAmJiBpbnB1dFN0cmluZy5pbmNsdWRlcyh0aGlzLnBtVGV4dCkpIHsKICAgICAgICAgICAgICAgIHJldHVybiBpbnB1dFN0cmluZy5yZXBsYWNlKG5ldyBSZWdFeHAodGhpcy5wbVRleHQsICdnJyksIHRoaXMuYXBtVHlwZSA9PT0gJ0EnID8gJ1BNJyA6ICdwbScpCiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIGlucHV0U3RyaW5nCiAgICAgICAgfSwKCiAgICAgICAgY2hlY2tEcm9wRGlyZWN0aW9uKCkgewogICAgICAgICAgICBpZiAoIXRoaXMuJGVsKSB7IHJldHVybiB9CiAgICAgICAgICAgIGxldCBjb250YWluZXIKICAgICAgICAgICAgaWYgKHRoaXMuY29udGFpbmVySWQgJiYgdGhpcy5jb250YWluZXJJZC5sZW5ndGgpIHsKICAgICAgICAgICAgICAgIGNvbnRhaW5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuY29udGFpbmVySWQpCiAgICAgICAgICAgICAgICBpZiAoIWNvbnRhaW5lciAmJiB0aGlzLmRlYnVnTW9kZSkgewogICAgICAgICAgICAgICAgICAgIHRoaXMuZGVidWdMb2coYENvbnRhaW5lciB3aXRoIGlkICIke3RoaXMuY29udGFpbmVySWR9IiBub3QgZm91bmQuIEZhbGxiYWNrIHRvIGRvY3VtZW50IGJvZHkuYCkKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgICBjb25zdCBlbCA9IHRoaXMuJGVsCiAgICAgICAgICAgIGxldCBzcGFjZURvd24KICAgICAgICAgICAgaWYgKGNvbnRhaW5lciAmJiBjb250YWluZXIub2Zmc2V0SGVpZ2h0KSB7CiAgICAgICAgICAgICAgICAvLyBWYWxpZCBjb250YWluZXIgZm91bmQKICAgICAgICAgICAgICAgIHNwYWNlRG93biA9IChjb250YWluZXIub2Zmc2V0VG9wICsgY29udGFpbmVyLm9mZnNldEhlaWdodCkgLSAoZWwub2Zmc2V0VG9wICsgZWwub2Zmc2V0SGVpZ2h0KQogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgLy8gRmFsbGJhY2sgdG8gZG9jdW1lbnQgYm9keQogICAgICAgICAgICAgICAgY29uc3QgZG9jSGVpZ2h0ID0gTWF0aC5tYXgoZG9jdW1lbnQuYm9keS5zY3JvbGxIZWlnaHQsIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxIZWlnaHQsIGRvY3VtZW50LmJvZHkub2Zmc2V0SGVpZ2h0LCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQub2Zmc2V0SGVpZ2h0LCBkb2N1bWVudC5ib2R5LmNsaWVudEhlaWdodCwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCkKICAgICAgICAgICAgICAgIHNwYWNlRG93biA9IGRvY0hlaWdodCAtIChlbC5vZmZzZXRUb3AgKyBlbC5vZmZzZXRIZWlnaHQpCiAgICAgICAgICAgIH0KICAgICAgICAgICAgdGhpcy5mb3JjZURyb3BPblRvcCA9IHRoaXMub3B0cy5kcm9wT2Zmc2V0SGVpZ2h0ID4gc3BhY2VEb3duCiAgICAgICAgfSwKCiAgICAgICAgLy8KICAgICAgICAvLyBIZWxwZXJzCiAgICAgICAgLy8KCiAgICAgICAgaXMxMmhSYW5nZSh2YWx1ZSkgewogICAgICAgICAgICByZXR1cm4gL15cZHsxLDJ9KGF8cHxBfFApJC8udGVzdCh2YWx1ZSkKICAgICAgICB9LAoKICAgICAgICBtYXRjaDEyaFJhbmdlKHZhbHVlKSB7CiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5tYXRjaCgvXihcZHsxLDJ9KShhfHB8QXxQKSQvKQogICAgICAgIH0sCgogICAgICAgIGlzTnVtYmVyKHZhbHVlKSB7CiAgICAgICAgICAgIHJldHVybiAhaXNOYU4ocGFyc2VGbG9hdCh2YWx1ZSkpICYmIGlzRmluaXRlKHZhbHVlKQogICAgICAgIH0sCgogICAgICAgIGlzQmFzaWNUeXBlKHR5cGUpIHsKICAgICAgICAgICAgcmV0dXJuIENPTkZJRy5CQVNJQ19UWVBFUy5pbmNsdWRlcyh0eXBlKQogICAgICAgIH0sCgogICAgICAgIGxvd2VyQ2FzZWRBcG0oYXBtVmFsdWUpIHsKICAgICAgICAgICAgcmV0dXJuIChhcG1WYWx1ZSB8fCAnJykudG9Mb3dlckNhc2UoKQogICAgICAgIH0sCgogICAgICAgIGdldFRva2VuUmVnZXgodG9rZW4pIHsKICAgICAgICAgICAgc3dpdGNoICh0b2tlbikgewogICAgICAgICAgICAgICAgY2FzZSAnSEgnOgogICAgICAgICAgICAgICAgICAgIHJldHVybiAnKFswMV1bMC05XXwyWzAtM118SHsyfSknCiAgICAgICAgICAgICAgICBjYXNlICdIJzoKICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyhbMC05XXsxfXwxWzAtOV18MlswLTNdfEh7MX0pJwogICAgICAgICAgICAgICAgY2FzZSAnaGgnOgogICAgICAgICAgICAgICAgICAgIHJldHVybiAnKDBbMS05XXwxWzAtMl18aHsyfSknCiAgICAgICAgICAgICAgICBjYXNlICdoJzoKICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyhbMS05XXsxfXwxWzAtMl18aHsxfSknCiAgICAgICAgICAgICAgICBjYXNlICdrayc6CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICcoMFsxLTldfDFbMC05XXwyWzAtNF18a3syfSknCiAgICAgICAgICAgICAgICBjYXNlICdrJzoKICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyhbMS05XXsxfXwxWzAtOV18MlswLTRdfGt7MX0pJwogICAgICAgICAgICAgICAgY2FzZSAnbW0nOgogICAgICAgICAgICAgICAgICAgIHJldHVybiAnKFswLTVdWzAtOV18bXsyfSknCiAgICAgICAgICAgICAgICBjYXNlICdzcyc6CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICcoWzAtNV1bMC05XXxzezJ9KScKICAgICAgICAgICAgICAgIGNhc2UgJ20nOgogICAgICAgICAgICAgICAgICAgIHJldHVybiAnKFswLTldezF9fFsxLTVdWzAtOV18bXsxfSknCiAgICAgICAgICAgICAgICBjYXNlICdzJzoKICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyhbMC05XXsxfXxbMS01XVswLTldfHN7MX0pJwogICAgICAgICAgICAgICAgY2FzZSAnQSc6CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICcoQU18UE18QXsxfSknCiAgICAgICAgICAgICAgICBjYXNlICdhJzoKICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyhhbXxwbXxhezF9KScKICAgICAgICAgICAgICAgIGRlZmF1bHQ6CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICcnCiAgICAgICAgICAgIH0KICAgICAgICB9LAoKICAgICAgICBpc0VtcHR5VmFsdWUodGFyZ2V0VG9rZW4sIHRlc3RWYWx1ZSkgewogICAgICAgICAgICByZXR1cm4gKCF0ZXN0VmFsdWUgfHwgIXRlc3RWYWx1ZS5sZW5ndGgpIHx8ICh0ZXN0VmFsdWUgJiYgdGVzdFZhbHVlID09PSB0YXJnZXRUb2tlbikKICAgICAgICB9LAoKICAgICAgICBpc1ZhbGlkVmFsdWUodGFyZ2V0VG9rZW4sIHRlc3RWYWx1ZSkgewogICAgICAgICAgICBpZiAoIXRhcmdldFRva2VuIHx8IHRoaXMuaXNFbXB0eVZhbHVlKHRhcmdldFRva2VuLCB0ZXN0VmFsdWUpKSB7IHJldHVybiBmYWxzZSB9CiAgICAgICAgICAgIGNvbnN0IHRva2VuUmVnZXhTdHIgPSB0aGlzLmdldFRva2VuUmVnZXgodGFyZ2V0VG9rZW4pCiAgICAgICAgICAgIGlmICghdG9rZW5SZWdleFN0ciB8fCAhdG9rZW5SZWdleFN0ci5sZW5ndGgpIHsgcmV0dXJuIGZhbHNlIH0KICAgICAgICAgICAgcmV0dXJuIChuZXcgUmVnRXhwKGBeJHt0b2tlblJlZ2V4U3RyfSRgKSkudGVzdCh0ZXN0VmFsdWUpCiAgICAgICAgfSwKCiAgICAgICAgc2FuaXRpemVkVmFsdWUodGFyZ2V0VG9rZW4sIGlucHV0VmFsdWUpIHsKICAgICAgICAgICAgaWYgKHRoaXMuaXNWYWxpZFZhbHVlKHRhcmdldFRva2VuLCBpbnB1dFZhbHVlKSkgewogICAgICAgICAgICAgICAgcmV0dXJuIGlucHV0VmFsdWUKICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gJycKICAgICAgICB9LAoKICAgICAgICBnZXRUb2tlblR5cGUodG9rZW4pIHsKICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5Vc2UudHlwZXNbdGhpcy5pblVzZS50b2tlbnMuaW5kZXhPZih0b2tlbildIHx8ICcnCiAgICAgICAgfSwKCiAgICAgICAgZ2V0VG9rZW5CeVR5cGUodHlwZSkgewogICAgICAgICAgICByZXR1cm4gdGhpc1tgJHt0eXBlfVR5cGVgXSB8fCAnJwogICAgICAgIH0sCgogICAgICAgIGlzTWludXRlT3JTZWNvbmQodHlwZSkgewogICAgICAgICAgICByZXR1cm4gWydtaW51dGUnLCAnc2Vjb25kJ10uaW5jbHVkZXModHlwZSkKICAgICAgICB9LAoKICAgICAgICBkZWJ1Z0xvZyhsb2dUZXh0KSB7CiAgICAgICAgICAgIGlmICghbG9nVGV4dCB8fCAhbG9nVGV4dC5sZW5ndGgpIHsgcmV0dXJuIH0KICAgICAgICAgICAgbGV0IGlkZW50aWZpZXIgPSAnJwogICAgICAgICAgICBpZiAodGhpcy5pZCkgewogICAgICAgICAgICAgICAgaWRlbnRpZmllciArPSBgIyR7dGhpcy5pZH1gCiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKHRoaXMubmFtZSkgewogICAgICAgICAgICAgICAgaWRlbnRpZmllciArPSBgW25hbWU9JHt0aGlzLm5hbWV9XWAKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAodGhpcy5pbnB1dENsYXNzKSB7CiAgICAgICAgICAgICAgICBsZXQgaW5wdXRDbGFzc2VzID0gW10KICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5pbnB1dENsYXNzID09PSAnc3RyaW5nJykgewogICAgICAgICAgICAgICAgICAgIGlucHV0Q2xhc3NlcyA9IHRoaXMuaW5wdXRDbGFzcy5zcGxpdCgvXHMvZykKICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLmlucHV0Q2xhc3MpKSB7CiAgICAgICAgICAgICAgICAgICAgaW5wdXRDbGFzc2VzID0gW10uY29uY2F0KFtdLCB0aGlzLmlucHV0Q2xhc3MpCiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLmlucHV0Q2xhc3MgPT09ICdvYmplY3QnKSB7CiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXModGhpcy5pbnB1dENsYXNzKS5mb3JFYWNoKGNsc05hbWUgPT4gewogICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pbnB1dENsYXNzW2Nsc05hbWVdKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dENsYXNzZXMucHVzaChjbHNOYW1lKQogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgfSkKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGZvciAobGV0IGlucHV0Q2xhc3Mgb2YgaW5wdXRDbGFzc2VzKSB7CiAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0Q2xhc3MgJiYgaW5wdXRDbGFzcy50cmltKCkubGVuZ3RoKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGlkZW50aWZpZXIgKz0gYC4ke2lucHV0Q2xhc3MudHJpbSgpfWAKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgICAgY29uc3QgZmluYWxMb2dUZXh0ID0gYERFQlVHOiAke2xvZ1RleHR9JHtpZGVudGlmaWVyID8gYFxuXHQoJHtpZGVudGlmaWVyfSlgIDogJyd9YAogICAgICAgICAgICBpZiAod2luZG93LmNvbnNvbGUuZGVidWcgJiYgdHlwZW9mIHdpbmRvdy5jb25zb2xlLmRlYnVnID09PSAnZnVuY3Rpb24nKSB7CiAgICAgICAgICAgICAgICB3aW5kb3cuY29uc29sZS5kZWJ1ZyhmaW5hbExvZ1RleHQpCiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICB3aW5kb3cuY29uc29sZS5sb2coZmluYWxMb2dUZXh0KQogICAgICAgICAgICB9CiAgICAgICAgfQogICAgfSwKCiAgICBtb3VudGVkKCkgewogICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5kZWJvdW5jZVRpbWVyKQogICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5zZWxlY3Rpb25UaW1lcikKICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMua2JJbnB1dFRpbWVyKQogICAgICAgIHRoaXMucmVuZGVyRm9ybWF0KCkKICAgIH0sCgogICAgYmVmb3JlRGVzdHJveSgpIHsKICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMuZGVib3VuY2VUaW1lcikKICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMuc2VsZWN0aW9uVGltZXIpCiAgICAgICAgd2luZG93LmNsZWFyVGltZW91dCh0aGlzLmtiSW5wdXRUaW1lcikKICAgIH0KfQo="},{"version":3,"sources":["VueTimePicker.vue"],"names":[],"mappings":";AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA","file":"VueTimePicker.vue","sourceRoot":"src/uiComponents","sourcesContent":["<script>\nconst CONFIG = {\n    HOUR_TOKENS: ['HH', 'H', 'hh', 'h', 'kk', 'k'],\n    MINUTE_TOKENS: ['mm', 'm'],\n    SECOND_TOKENS: ['ss', 's'],\n    APM_TOKENS: ['A', 'a'],\n    BASIC_TYPES: ['hour', 'minute', 'second', 'apm']\n}\n\nconst DEFAULT_OPTIONS = {\n    format: 'HH:mm',\n    minuteInterval: 1,\n    secondInterval: 1,\n    hourRange: null,\n    minuteRange: null,\n    secondRange: null,\n    hideDisabledHours: false,\n    hideDisabledMinutes: false,\n    hideDisabledSeconds: false,\n    hideDisabledItems: false,\n    hideDropdown: false,\n    blurDelay: 300,\n    manualInputTimeout: 1000,\n    dropOffsetHeight: 160\n}\n\nexport default {\n    name: 'VueTimepicker',\n    props: {\n        value: { type: [Object, String] },\n        format: { type: String },\n        minuteInterval: { type: [Number, String] },\n        secondInterval: { type: [Number, String] },\n\n        hourRange: { type: Array },\n        minuteRange: { type: Array },\n        secondRange: { type: Array },\n\n        hideDisabledHours: { type: Boolean, default: false },\n        hideDisabledMinutes: { type: Boolean, default: false },\n        hideDisabledSeconds: { type: Boolean, default: false },\n        hideDisabledItems: { type: Boolean, default: false },\n\n        hideClearButton: { type: Boolean, default: false },\n        disabled: { type: Boolean, default: false },\n        closeOnComplete: { type: Boolean, default: false },\n\n        id: { type: String },\n        name: { type: String },\n        inputClass: { type: [String, Object, Array] },\n        placeholder: { type: String },\n        tabindex: { type: [Number, String], default: 0 },\n        inputWidth: { type: String },\n        autocomplete: { type: String, default: 'off' },\n\n        hourLabel: { type: String },\n        minuteLabel: { type: String },\n        secondLabel: { type: String },\n        apmLabel: { type: String },\n        amText: { type: String },\n        pmText: { type: String },\n\n        blurDelay: { type: [Number, String] },\n        advancedKeyboard: { type: Boolean, default: false },\n\n        lazy: { type: Boolean, default: false },\n        autoScroll: { type: Boolean, default: false },\n\n        dropDirection: { type: String, default: 'down' },\n        dropOffsetHeight: { type: [Number, String] },\n        containerId: { type: String },\n        appendToBody: { type: Boolean, default: false },\n\n        manualInput: { type: Boolean, default: false },\n        manualInputTimeout: { type: [Number, String] },\n        hideDropdown: { type: Boolean, default: false },\n        fixedDropdownButton: { type: Boolean, default: false },\n\n        debugMode: { type: Boolean, default: false }\n    },\n\n    data() {\n        return {\n            timeValue: {},\n\n            hours: [],\n            minutes: [],\n            seconds: [],\n            apms: [],\n\n            isActive: false,\n            showDropdown: false,\n            isFocusing: false,\n            debounceTimer: undefined,\n\n            hourType: 'HH',\n            minuteType: 'mm',\n            secondType: '',\n            apmType: '',\n            hour: '',\n            minute: '',\n            second: '',\n            apm: '',\n            fullValues: undefined,\n            bakDisplayTime: undefined,\n            doClearApmChecking: false,\n\n            selectionTimer: undefined,\n            kbInputTimer: undefined,\n            kbInputLog: '',\n            bakCurrentPos: undefined,\n            forceDropOnTop: false\n        }\n    },\n\n    computed: {\n        opts() {\n            const options = Object.assign({}, DEFAULT_OPTIONS)\n\n            if (this.format && this.format.length) {\n                options.format = String(this.format)\n            }\n\n            if (this.isNumber(this.minuteInterval)) {\n                options.minuteInterval = +this.minuteInterval\n            }\n            // minuteInterval failsafe\n            if (!options.minuteInterval || options.minuteInterval < 1 || options.minuteInterval > 60) {\n                if (this.debugMode) {\n                    if (options.minuteInterval > 60) {\n                        this.debugLog(`\"minute-interval\" should be less than 60. Current value is ${this.minuteInterval}`)\n                    } else if (options.minuteInterval === 0 || options.minuteInterval < 1) {\n                        this.debugLog(`\"minute-interval\" should be NO less than 1. Current value is ${this.minuteInterval}`)\n                    }\n                }\n                if (options.minuteInterval === 0) {\n                    options.minuteInterval = 60\n                } else {\n                    options.minuteInterval = 1\n                }\n            }\n\n            if (this.isNumber(this.secondInterval)) {\n                options.secondInterval = +this.secondInterval\n            }\n            // secondInterval failsafe\n            if (!options.secondInterval || options.secondInterval < 1 || options.secondInterval > 60) {\n                if (this.debugMode) {\n                    if (options.secondInterval > 60) {\n                        this.debugLog(`\"second-interval\" should be less than 60. Current value is ${this.secondInterval}`)\n                    } else if (options.secondInterval === 0 || options.secondInterval < 1) {\n                        this.debugLog(`\"second-interval\" should be NO less than 1. Current value is ${this.secondInterval}`)\n                    }\n                }\n                if (options.secondInterval === 0) {\n                    options.secondInterval = 60\n                } else {\n                    options.secondInterval = 1\n                }\n            }\n\n            if (this.hourRange && Array.isArray(this.hourRange)) {\n                options.hourRange = JSON.parse(JSON.stringify(this.hourRange))\n                if (!this.hourRange.length && this.debugMode) {\n                    this.debugLog('The \"hour-range\" array is empty (length === 0)')\n                }\n            }\n\n            if (this.minuteRange && Array.isArray(this.minuteRange)) {\n                options.minuteRange = JSON.parse(JSON.stringify(this.minuteRange))\n                if (!this.minuteRange.length && this.debugMode) {\n                    this.debugLog('The \"minute-range\" array is empty (length === 0)')\n                }\n            }\n\n            if (this.secondRange && Array.isArray(this.secondRange)) {\n                options.secondRange = JSON.parse(JSON.stringify(this.secondRange))\n                if (!this.secondRange.length && this.debugMode) {\n                    this.debugLog('The \"second-range\" array is empty (length === 0)')\n                }\n            }\n\n            if (this.hideDisabledItems) {\n                options.hideDisabledItems = true\n            }\n\n            if (this.hideDisabledHours || this.hideDisabledItems) {\n                options.hideDisabledHours = true\n            }\n            if (this.hideDisabledMinutes || this.hideDisabledItems) {\n                options.hideDisabledMinutes = true\n            }\n            if (this.hideDisabledSeconds || this.hideDisabledItems) {\n                options.hideDisabledSeconds = true\n            }\n\n            if (this.hideDropdown) {\n                if (this.manualInput) {\n                    options.hideDropdown = true\n                } else if (this.debugMode) {\n                    this.debugLog('\"hide-dropdown\" only works with \"manual-input\" mode')\n                }\n            }\n\n            if (this.blurDelay && +this.blurDelay > 0) {\n                options.blurDelay = +this.blurDelay\n            }\n\n            if (this.manualInputTimeout && +this.manualInputTimeout > 0) {\n                options.manualInputTimeout = +this.manualInputTimeout\n            }\n\n            if (this.dropOffsetHeight && +this.dropOffsetHeight > 0) {\n                options.dropOffsetHeight = +this.dropOffsetHeight\n            }\n\n            return options\n        },\n\n        useStringValue() {\n            return typeof this.value === 'string'\n        },\n\n        formatString() {\n            return this.opts.format || DEFAULT_OPTIONS.format\n        },\n\n        inUse() {\n            const typesInUse = CONFIG.BASIC_TYPES.filter(type => this.getTokenByType(type))\n            // Sort types and tokens by their sequence in the \"format\" string\n            typesInUse.sort((l, r) => {\n                return this.formatString.indexOf(this.getTokenByType(l) || null) - this.formatString.indexOf(this.getTokenByType(r) || null)\n            })\n            const tokensInUse = typesInUse.map(type => this.getTokenByType(type))\n            return {\n                hour: !!this.hourType,\n                minute: !!this.minuteType,\n                second: !!this.secondType,\n                apm: !!this.apmType,\n                types: typesInUse || [],\n                tokens: tokensInUse || []\n            }\n        },\n\n        displayTime() {\n            let formatString = String(this.formatString)\n            if (this.hour) {\n                formatString = formatString.replace(new RegExp(this.hourType, 'g'), this.hour)\n            }\n            if (this.minute) {\n                formatString = formatString.replace(new RegExp(this.minuteType, 'g'), this.minute)\n            }\n            if (this.second && this.secondType) {\n                formatString = formatString.replace(new RegExp(this.secondType, 'g'), this.second)\n            }\n            if (this.apm && this.apmType) {\n                formatString = formatString.replace(new RegExp(this.apmType, 'g'), this.apm)\n            }\n            return formatString\n        },\n\n        customDisplayTime() {\n            if (!this.amText && !this.pmText) {\n                return this.displayTime\n            }\n            return this.displayTime.replace(new RegExp(this.apm, 'g'), this.apmDisplayText(this.apm))\n        },\n\n        inputIsEmpty() {\n            return this.formatString === this.displayTime\n        },\n\n        allValueSelected() {\n            if (\n                (this.inUse.hour && !this.hour) ||\n                (this.inUse.minute && !this.minute) ||\n                (this.inUse.second && !this.second) ||\n                (this.inUse.apm && !this.apm)\n            ) {\n                return false\n            }\n            return true\n        },\n\n        columnsSequence() {\n            return this.inUse.types.map(type => type) || []\n        },\n\n        showClearBtn() {\n            if (this.hideClearButton || this.disabled) {\n                return false\n            }\n            return !this.inputIsEmpty\n        },\n\n        showDropdownBtn() {\n            if (this.fixedDropdownButton) { return true }\n            if (this.opts.hideDropdown && this.isActive && !this.showDropdown) {\n                return true\n            }\n            return false\n        },\n\n        baseOn12Hours() {\n            return this.hourType === 'h' || this.hourType === 'hh'\n        },\n\n        hourRangeIn24HrFormat() {\n            if (!this.hourType || !this.opts.hourRange) { return false }\n            if (!this.opts.hourRange.length) { return [] }\n\n            const range = []\n            this.opts.hourRange.forEach(value => {\n                if (value instanceof Array) {\n                    if (value.length > 2 && this.debugMode) {\n                        this.debugLog(`Nested array within \"hour-range\" must contain no more than two items. Only the first two items of ${JSON.stringify(value)} will be taken into account.`)\n                    }\n\n                    let start = value[0]\n                    let end = value[1] || value[0]\n\n                    if (this.is12hRange(start)) {\n                        start = this.translate12hRange(start)\n                    }\n                    if (this.is12hRange(end)) {\n                        end = this.translate12hRange(end)\n                    }\n\n                    for (let i = +start; i <= +end; i++) {\n                        if (i < 0 || i > 24) { continue }\n                        if (!range.includes(i)) {\n                            range.push(i)\n                        }\n                    }\n                } else {\n                    if (this.is12hRange(value)) {\n                        value = this.translate12hRange(value)\n                    } else {\n                        value = +value\n                    }\n                    if (value < 0 || value > 24) { return }\n                    if (!range.includes(value)) {\n                        range.push(value)\n                    }\n                }\n            })\n            range.sort((l, r) => { return l - r })\n            return range\n        },\n\n        restrictedHourRange() {\n            // No restriction\n            if (!this.hourRangeIn24HrFormat) { return false }\n            // 12-Hour\n            if (this.baseOn12Hours) {\n                const range = this.hourRangeIn24HrFormat.map((value) => {\n                    if (value === 12) {\n                        return '12p'\n                    } else if (value === 24 || value === 0) {\n                        return '12a'\n                    }\n                    return value > 12 ? `${value % 12}p` : `${value}a`\n                })\n                return range\n            }\n            // 24-Hour\n            return this.hourRangeIn24HrFormat\n        },\n\n        validHoursList() {\n            if (!this.manualInput) { return false }\n            if (this.restrictedHourRange) {\n                let list = []\n                if (this.baseOn12Hours) {\n                    list = this.restrictedHourRange.map(hr => {\n                        const l = hr.substr(0, hr.length - 1)\n                        const r = hr.substr(-1)\n                        return `${this.formatValue(this.hourType, l)}${r}`\n                    })\n                    const am12Index = list.indexOf('12a')\n                    if (am12Index > 0) {\n                        // Make '12a' the first item in h/hh\n                        list.unshift(list.splice(am12Index, 1)[0])\n                    }\n                    return list\n                }\n                list = this.restrictedHourRange.map(hr => {\n                    return this.formatValue(this.hourType, hr)\n                })\n                if (list.length > 1 && list[0] && list[0] === '24') {\n                    // Make '24' the last item in k/kk\n                    list.push(list.shift())\n                }\n                return list\n            }\n            if (this.baseOn12Hours) {\n                return [].concat([], this.hours.map(hr => `${hr}a`), this.hours.map(hr => `${hr}p`))\n            }\n            return this.hours\n        },\n\n        has() {\n            const result = {\n                customApmText: false\n            }\n            const apmEnabled = !!this.apmType\n\n            if (apmEnabled && this.hourRangeIn24HrFormat && this.hourRangeIn24HrFormat.length) {\n                const range = [].concat([], this.hourRangeIn24HrFormat)\n                result.am = range.some(value => value < 12 || value === 24)\n                result.pm = range.some(value => value >= 12 && value < 24)\n            } else {\n                result.am = apmEnabled\n                result.pm = apmEnabled\n            }\n            if ((this.amText && this.amText.length) || (this.pmText && this.pmText.length)) {\n                result.customApmText = true\n            }\n            return result\n        },\n\n        minuteRangeList() {\n            if (!this.minuteType || !this.opts.minuteRange) { return false }\n            if (!this.opts.minuteRange.length) { return [] }\n            return this.renderRangeList(this.opts.minuteRange, 'minute')\n        },\n\n        secondRangeList() {\n            if (!this.secondType || !this.opts.secondRange) { return false }\n            if (!this.opts.secondRange.length) { return [] }\n            return this.renderRangeList(this.opts.secondRange, 'second')\n        },\n\n        hourLabelText() {\n            return this.hourLabel || this.hourType\n        },\n        minuteLabelText() {\n            return this.minuteLabel || this.minuteType\n        },\n        secondLabelText() {\n            return this.secondLabel || this.secondType\n        },\n        apmLabelText() {\n            return this.apmLabel || this.apmType\n        },\n\n        inputWidthStyle() {\n            if (!this.inputWidth || !this.inputWidth.length) { return }\n            return {\n                width: this.inputWidth\n            }\n        },\n\n        tokenRegexBase() {\n            return this.inUse.tokens.join('|')\n        },\n\n        tokenChunks() {\n            if (!this.manualInput && !this.useStringValue) { return false }\n\n            const formatString = String(this.formatString)\n            const tokensRegxStr = `(${this.tokenRegexBase})+?`\n            const tokensMatchAll = this.getMatchAllByRegex(formatString, tokensRegxStr)\n\n            const tokenChunks = []\n            for (let tkMatch of tokensMatchAll) {\n                const rawToken = tkMatch[0]\n                const tokenMatchItem = {\n                    index: tkMatch.index,\n                    token: rawToken,\n                    type: this.getTokenType(rawToken),\n                    needsCalibrate: rawToken.length < 2,\n                    len: (rawToken || '').length\n                }\n                tokenChunks.push(tokenMatchItem)\n            }\n            return tokenChunks\n        },\n\n        needsPosCalibrate() {\n            if (!this.manualInput) { return false }\n            return this.tokenChunks.some(chk => chk.needsCalibrate)\n        },\n\n        tokenChunksPos() {\n            if (!this.manualInput) { return false }\n            if (!this.needsPosCalibrate) {\n                return this.tokenChunks.map(chk => {\n                    return {\n                        token: chk.token,\n                        type: chk.type,\n                        start: chk.index,\n                        end: chk.index + chk.len\n                    }\n                })\n            }\n            const list = []\n            let calibrateLen = 0\n            this.tokenChunks.forEach(chk => {\n                let chunkCurrentLen\n                // Adjust for customized AM/PM text\n                if (chk.type === 'apm' && this.has.customApmText) {\n                    if (this.apm && this.apm.length) {\n                        const customApmText = this.apm.toLowerCase() === 'am' ? this.amText : this.pmText\n                        chunkCurrentLen = (customApmText && customApmText.length) ? customApmText.length : chk.len\n                    } else {\n                        chunkCurrentLen = chk.len\n                    }\n                    // Others\n                } else {\n                    chunkCurrentLen = this[chk.type] && this[chk.type].length ? this[chk.type].length : chk.len\n                }\n                list.push({\n                    token: chk.token,\n                    type: chk.type,\n                    start: chk.index + calibrateLen,\n                    end: chk.index + calibrateLen + chunkCurrentLen\n                })\n                if (chk.needsCalibrate && chunkCurrentLen > chk.len) {\n                    calibrateLen += (chunkCurrentLen - chk.len)\n                }\n            })\n            return list\n        },\n\n        invalidValues() {\n            if (this.inputIsEmpty) { return [] }\n            if (!this.restrictedHourRange && !this.minuteRangeList && !this.secondRangeList && this.opts.minuteInterval === 1 && this.opts.secondInterval === 1) { return [] }\n\n            const result = []\n            if (this.inUse.hour && !this.isEmptyValue(this.hourType, this.hour) && (!this.isValidValue(this.hourType, this.hour) || this.isDisabled('hour', this.hour))) {\n                result.push('hour')\n            }\n            if (this.inUse.minute && !this.isEmptyValue(this.minuteType, this.minute) && (!this.isValidValue(this.minuteType, this.minute) || this.isDisabled('minute', this.minute) || this.notInInterval('minute', this.minute))) {\n                result.push('minute')\n            }\n            if (this.inUse.second && !this.isEmptyValue(this.secondType, this.second) && (!this.isValidValue(this.secondType, this.second) || this.isDisabled('second', this.second) || this.notInInterval('second', this.second))) {\n                result.push('second')\n            }\n            if (this.inUse.apm && !this.isEmptyValue(this.apmType, this.apm) && (!this.isValidValue(this.apmType, this.apm) || this.isDisabled('apm', this.apm))) {\n                result.push('apm')\n            }\n            if (result.length) {\n                return result\n            }\n            return []\n        },\n\n        hasInvalidInput() {\n            return Boolean(this.invalidValues && this.invalidValues.length)\n        },\n\n        autoDirectionEnabled() {\n            return this.dropDirection === 'auto'\n        },\n\n        dropdownDirClass() {\n            if (this.autoDirectionEnabled) {\n                return this.forceDropOnTop ? 'drop-up' : 'drop-down'\n            }\n            return this.dropDirection === 'up' ? 'drop-up' : 'drop-down'\n        }\n    },\n\n    watch: {\n        'opts.format'(newValue) {\n            this.renderFormat(newValue)\n        },\n        'opts.minuteInterval'(newInteval) {\n            this.renderList('minute', newInteval)\n        },\n        'opts.secondInterval'(newInteval) {\n            this.renderList('second', newInteval)\n        },\n        value: {\n            deep: true,\n            handler() {\n                this.readValues()\n            }\n        },\n        displayTime() {\n            this.fillValues()\n        },\n        disabled(toDisabled) {\n            if (toDisabled) {\n                // Force close dropdown and reset status when disabled\n                if (this.isActive) {\n                    this.isActive = false\n                }\n                if (this.showDropdown) {\n                    this.showDropdown = false\n                }\n            }\n        },\n        'invalidValues.length'(newLength, oldLength) {\n            if (newLength && newLength >= 1) {\n                this.$emit('error', this.invalidValues)\n            } else if (oldLength && oldLength >= 1) {\n                this.$emit('error', [])\n            }\n        }\n    },\n\n    methods: {\n        formatValue(token, i) {\n            if (!this.isNumber(i)) { return '' }\n            i = +i\n            switch (token) {\n                case 'H':\n                case 'h':\n                case 'k':\n                case 'm':\n                case 's':\n                    if (['h', 'k'].includes(token) && i === 0) {\n                        return token === 'k' ? '24' : '12'\n                    }\n                    return String(i)\n                case 'HH':\n                case 'mm':\n                case 'ss':\n                case 'hh':\n                case 'kk':\n                    if (['hh', 'kk'].includes(token) && i === 0) {\n                        return token === 'kk' ? '24' : '12'\n                    }\n                    return i < 10 ? `0${i}` : String(i)\n                default:\n                    return ''\n            }\n        },\n\n        checkAcceptingType(validValues, formatString) {\n            if (!validValues || !formatString || !formatString.length) { return '' }\n            for (let i = 0; i < validValues.length; i++) {\n                if (formatString.indexOf(validValues[i]) > -1) {\n                    return validValues[i]\n                }\n            }\n            return ''\n        },\n\n        renderFormat(newFormat) {\n            newFormat = newFormat || this.opts.format || DEFAULT_OPTIONS.format\n\n            let hourType = this.checkAcceptingType(CONFIG.HOUR_TOKENS, newFormat)\n            let minuteType = this.checkAcceptingType(CONFIG.MINUTE_TOKENS, newFormat)\n            this.secondType = this.checkAcceptingType(CONFIG.SECOND_TOKENS, newFormat)\n            this.apmType = this.checkAcceptingType(CONFIG.APM_TOKENS, newFormat)\n\n            // Failsafe checking\n            if (!hourType && !minuteType && !this.secondType && !this.apmType) {\n                if (this.debugMode && this.format) {\n                    this.debugLog(`No valid tokens found in your defined \"format\" string \"${this.format}\". Fallback to the default \"HH:mm\" format.`)\n                }\n                hourType = 'HH'\n                minuteType = 'mm'\n            }\n            this.hourType = hourType\n            this.minuteType = minuteType\n\n            this.hourType ? this.renderHoursList() : this.hours = []\n            this.minuteType ? this.renderList('minute') : this.minutes = []\n            this.secondType ? this.renderList('second') : this.seconds = []\n            this.apmType ? this.renderApmList() : this.apms = []\n\n            this.$nextTick(() => {\n                this.readValues()\n            })\n        },\n\n        renderHoursList() {\n            const hoursCount = this.baseOn12Hours ? 12 : 24\n            const hours = []\n            for (let i = 0; i < hoursCount; i++) {\n                if (this.hourType === 'k' || this.hourType === 'kk') {\n                    hours.push(this.formatValue(this.hourType, i + 1))\n                } else {\n                    hours.push(this.formatValue(this.hourType, i))\n                }\n            }\n            this.hours = hours\n        },\n\n        renderList(listType, interval) {\n            if (!this.isMinuteOrSecond(listType)) { return }\n\n            const isMinute = listType === 'minute'\n            interval = interval || (isMinute ? (this.opts.minuteInterval || DEFAULT_OPTIONS.minuteInterval) : (this.opts.secondInterval || DEFAULT_OPTIONS.secondInterval))\n\n            const result = []\n            for (let i = 0; i < 60; i += interval) {\n                result.push(this.formatValue(isMinute ? this.minuteType : this.secondType, i))\n            }\n            isMinute ? this.minutes = result : this.seconds = result\n        },\n\n        renderApmList() {\n            this.apms = this.apmType === 'A' ? ['AM', 'PM'] : ['am', 'pm']\n        },\n\n        readValues() {\n            if (this.useStringValue) {\n                if (this.debugMode) {\n                    this.debugLog(`Received a string value: \"${this.value}\"`)\n                }\n                this.readStringValues(this.value)\n            } else {\n                if (this.debugMode) {\n                    this.debugLog(`Received an object value: \"${JSON.stringify(this.value || {})}\"`)\n                }\n                this.readObjectValues(this.value)\n            }\n        },\n\n        readObjectValues(objValue) {\n            const timeValue = JSON.parse(JSON.stringify(objValue || {}))\n            const values = Object.keys(timeValue)\n\n            // Failsafe for empty `v-model` object\n            if (values.length === 0) {\n                this.addFallbackValues()\n                return\n            }\n\n            CONFIG.BASIC_TYPES.forEach(type => {\n                const token = this.getTokenByType(type)\n                if (values.indexOf(token) > -1) {\n                    const sanitizedValue = this.sanitizedValue(token, timeValue[token])\n                    this[type] = sanitizedValue\n                    timeValue[token] = sanitizedValue\n                } else {\n                    this[type] = ''\n                }\n            })\n            this.timeValue = timeValue\n        },\n\n        getMatchAllByRegex(testString, regexString) {\n            const str = 'polyfillTest'\n            const needsPolyfill = Boolean(!str.matchAll || typeof str.matchAll !== 'function')\n            return needsPolyfill ? this.polyfillMatchAll(testString, regexString) : testString.matchAll(new RegExp(regexString, 'g'))\n        },\n\n        readStringValues(stringValue) {\n            // Failsafe for empty `v-model` string\n            if (!stringValue || !stringValue.length) {\n                this.addFallbackValues()\n                return\n            }\n\n            const formatString = String(this.formatString)\n            const tokensRegxStr = `(${this.tokenRegexBase})+?`\n            const othersRegxStr = `[^(${this.tokenRegexBase})]+`\n\n            const tokensMatchAll = this.getMatchAllByRegex(formatString, tokensRegxStr)\n            const othersMatchAll = this.getMatchAllByRegex(formatString, othersRegxStr)\n\n            const chunks = []\n            const tokenChunks = []\n\n            for (let tkMatch of tokensMatchAll) {\n                const tokenMatchItem = {\n                    index: tkMatch.index,\n                    token: tkMatch[0],\n                    isValueToken: true\n                }\n                chunks.push(tokenMatchItem)\n                tokenChunks.push(tokenMatchItem)\n            }\n\n            for (let otMatch of othersMatchAll) {\n                chunks.push({\n                    index: otMatch.index,\n                    token: otMatch[0]\n                })\n            }\n\n            chunks.sort((l, r) => l.index < r.index ? -1 : 1)\n\n            let regexCombo = ''\n            chunks.forEach(chunk => {\n                if (chunk.isValueToken) {\n                    const tokenRegex = this.getTokenRegex(chunk.token) || ''\n                    regexCombo += tokenRegex\n                } else {\n                    const safeChars = chunk.token.replace(/\\\\{0}(\\*|\\?|\\.|\\+)/g, '\\\\$1')\n                    regexCombo += `(?:${safeChars})`\n                }\n            })\n\n            const comboReg = new RegExp(regexCombo)\n\n            // Do test before match\n            if (comboReg.test(stringValue)) {\n                const matchResults = stringValue.match(new RegExp(regexCombo))\n                const valueResults = matchResults.slice(1, tokenChunks.length + 1)\n                const timeValue = {}\n                valueResults.forEach((value, vrIndex) => {\n                    if (tokenChunks[vrIndex]) {\n                        const targetToken = tokenChunks[vrIndex].token\n                        timeValue[targetToken] = this.setValueFromString(value, targetToken)\n                    }\n                })\n                this.timeValue = timeValue\n\n                if (this.debugMode) {\n                    const tokenChunksForLog = tokenChunks.map(tChunk => tChunk && tChunk.token)\n                    this.debugLog(`Successfully parsed values ${JSON.stringify(valueResults)}\\nfor ${JSON.stringify(tokenChunksForLog)}\\nin format pattern '${this.formatString}'`)\n                }\n            } else {\n                if (this.debugMode) {\n                    this.debugLog(`The input string in \"v-model\" does NOT match the \"format\" pattern\\nformat: ${this.formatString}\\nv-model: ${stringValue}`)\n                }\n            }\n        },\n\n        polyfillMatchAll(targetString, regxStr) {\n            const matchesList = targetString.match(new RegExp(regxStr, 'g'))\n            const result = []\n            const indicesReg = []\n            if (matchesList && matchesList.length) {\n                matchesList.forEach(matchedItem => {\n                    const existIndex = indicesReg.findIndex(idxItem => idxItem.str === matchedItem)\n                    let index\n                    if (existIndex >= 0) {\n                        if (indicesReg[existIndex] && indicesReg[existIndex].regex) {\n                            index = indicesReg[existIndex].regex.exec(targetString).index\n                        }\n                    } else {\n                        const itemIndicesRegex = new RegExp(matchedItem, 'g')\n                        index = itemIndicesRegex.exec(targetString).index\n                        indicesReg.push({\n                            str: String(matchedItem),\n                            regex: itemIndicesRegex\n                        })\n                    }\n                    result.push({\n                        0: String(matchedItem),\n                        index: index\n                    })\n                })\n            }\n            return result\n        },\n\n        addFallbackValues() {\n            const timeValue = {}\n            this.inUse.types.forEach(type => {\n                timeValue[this.getTokenByType(type)] = ''\n            })\n            this.timeValue = timeValue\n        },\n\n        setValueFromString(parsedValue, token) {\n            if (!token || !parsedValue) { return '' }\n            const tokenType = this.getTokenType(token)\n            if (!tokenType || !tokenType.length) { return '' }\n            const stdValue = (parsedValue !== this.getTokenByType(tokenType)) ? parsedValue : ''\n            this[tokenType] = stdValue\n            return stdValue\n        },\n\n        fillValues(forceEmit) {\n            const fullValues = {}\n\n            const baseHour = this.hour\n            const baseHourType = this.hourType\n\n            let apmValue\n\n            // Hour type or hour value is NOT set in the \"format\" string\n            if (!baseHourType || !this.isNumber(baseHour)) {\n                CONFIG.HOUR_TOKENS.forEach(token => fullValues[token] = '')\n                apmValue = this.lowerCasedApm(this.apm || '')\n                fullValues.a = apmValue\n                fullValues.A = apmValue.toUpperCase()\n\n                // Both Hour type and value are set\n            } else {\n                const hourValue = +baseHour\n                const apmValue = (this.baseOn12Hours && this.apm) ? this.lowerCasedApm(this.apm) : false\n\n                CONFIG.HOUR_TOKENS.forEach((token) => {\n                    if (token === baseHourType) {\n                        fullValues[token] = baseHour\n                        return\n                    }\n\n                    let value\n                    let apm\n                    switch (token) {\n                        case 'H':\n                        case 'HH':\n                        case 'k':\n                        case 'kk':\n                            if (this.baseOn12Hours) {\n                                if (apmValue === 'pm') {\n                                    value = hourValue < 12 ? hourValue + 12 : hourValue\n                                } else if (['k', 'kk'].includes(token)) {\n                                    value = hourValue === 12 ? 24 : hourValue\n                                } else {\n                                    value = hourValue % 12\n                                }\n                            } else {\n                                if (['k', 'kk'].includes(token)) {\n                                    value = hourValue === 0 ? 24 : hourValue\n                                } else {\n                                    value = hourValue % 24\n                                }\n                            }\n                            fullValues[token] = this.formatValue(token, value)\n                            break\n                        case 'h':\n                        case 'hh':\n                            // h <-> hh\n                            if (this.baseOn12Hours) {\n                                value = hourValue\n                                apm = apmValue || ''\n                                // Read from other hour formats\n                            } else {\n                                if (hourValue > 11 && hourValue < 24) {\n                                    apm = 'pm'\n                                    value = hourValue === 12 ? 12 : hourValue % 12\n                                } else {\n                                    apm = 'am'\n                                    value = hourValue % 12 === 0 ? 12 : hourValue\n                                }\n                            }\n                            fullValues[token] = this.formatValue(token, value)\n                            fullValues.a = apm\n                            fullValues.A = apm.toUpperCase()\n                            break\n                    }\n                })\n            }\n\n            fullValues.m = this.formatValue('m', this.minute)\n            fullValues.mm = this.formatValue('mm', this.minute)\n            fullValues.s = this.formatValue('s', this.second)\n            fullValues.ss = this.formatValue('ss', this.second)\n\n            this.fullValues = fullValues\n\n            // On lazy mode, emit `input` and `change` events only when:\n            // - The user pick a new value and then close the dropdown\n            // - The user click the (\"x\") clear button\n            if (!this.lazy || forceEmit) {\n                this.emitTimeValue()\n            }\n\n            if (this.closeOnComplete && this.allValueSelected && this.showDropdown) {\n                this.toggleActive()\n            }\n        },\n\n        getFullData() {\n            if (!this.fullValues) {\n                this.fillValues()\n            }\n            return {\n                data: JSON.parse(JSON.stringify(this.fullValues)),\n                displayTime: this.inputIsEmpty ? '' : String(this.displayTime)\n            }\n        },\n\n        emitTimeValue() {\n            if (this.lazy && this.bakDisplayTime === this.displayTime) {\n                if (this.debugMode) {\n                    this.debugLog('The value does not change on `lazy` mode. Skip the emitting `input` and `change` event.')\n                }\n                return\n            }\n\n            const fullData = this.getFullData()\n\n            if (this.useStringValue) {\n                this.$emit('input', fullData.displayTime)\n            } else {\n                const fullValues = fullData.data\n                const tokensInUse = this.inUse.tokens || []\n                const timeValue = {}\n                tokensInUse.forEach((token) => {\n                    timeValue[token] = fullValues[token] || ''\n                })\n                this.$emit('input', JSON.parse(JSON.stringify(timeValue)))\n            }\n\n            this.$emit('change', fullData)\n        },\n\n        translate12hRange(value) {\n            const valueT = this.match12hRange(value)\n            if (+valueT[1] === 12) {\n                return +valueT[1] + (valueT[2].toLowerCase() === 'p' ? 0 : 12)\n            }\n            return +valueT[1] + (valueT[2].toLowerCase() === 'p' ? 12 : 0)\n        },\n\n        isDisabled(type, value) {\n            if (!this.isBasicType(type) || !this.inUse[type]) { return true }\n            switch (type) {\n                case 'hour':\n                    return this.isDisabledHour(value)\n                case 'minute':\n                case 'second':\n                    if (!this[`${type}RangeList`]) {\n                        return false\n                    }\n                    return !this[`${type}RangeList`].includes(value)\n                case 'apm':\n                    if (!this.restrictedHourRange) {\n                        return false\n                    }\n                    return !this.has[this.lowerCasedApm(value)]\n                default:\n                    return true\n            }\n        },\n\n        isDisabledHour(value) {\n            if (!this.restrictedHourRange) { return false }\n            if (this.baseOn12Hours) {\n                if (!this.apm || !this.apm.length) {\n                    return false\n                } else {\n                    const token = this.apm.toLowerCase() === 'am' ? 'a' : 'p'\n                    return !this.restrictedHourRange.includes(`${+value}${token}`)\n                }\n            }\n            // Fallback for 'HH' and 'H hour format with a `hour-range` in a 12-hour form\n            if (\n                (this.hourType === 'HH' || this.hourType === 'H') &&\n                +value === 0 && this.restrictedHourRange.includes(24)\n            ) {\n                return false\n            }\n            return !this.restrictedHourRange.includes(+value)\n        },\n\n        notInInterval(section, value) {\n            if (!section || !this.isMinuteOrSecond(section)) { return }\n            if (this.opts[`${section}Interval`] === 1) { return false }\n            return +value % this.opts[`${section}Interval`] !== 0\n        },\n\n        renderRangeList(rawRange, section) {\n            if (!rawRange || !section || !this.isMinuteOrSecond(section)) { return [] }\n            const range = []\n            let formatedValue\n            rawRange.forEach(value => {\n                if (value instanceof Array) {\n                    if (value.length > 2 && this.debugMode) {\n                        this.debugLog(`Nested array within \"${section}-range\" must contain no more than two items. Only the first two items of ${JSON.stringify(value)} will be taken into account.`)\n                    }\n                    const start = value[0]\n                    const end = value[1] || value[0]\n                    for (let i = +start; i <= +end; i++) {\n                        if (i < 0 || i > 59) { continue }\n                        formatedValue = this.formatValue(this.getTokenByType(section), i)\n                        if (!range.includes(formatedValue)) {\n                            range.push(formatedValue)\n                        }\n                    }\n                } else {\n                    if (+value < 0 || +value > 59) { return }\n                    formatedValue = this.formatValue(this.getTokenByType(section), value)\n                    if (!range.includes(formatedValue)) {\n                        range.push(formatedValue)\n                    }\n                }\n            })\n            range.sort((l, r) => { return l - r })\n            // Debug Mode\n            if (this.debugMode) {\n                const fullList = (section === 'minute' ? this.minutes : this.seconds) || []\n                const validItems = fullList.filter(item => range.includes(item))\n                if (!validItems || !validItems.length) {\n                    if (section === 'minute') {\n                        this.debugLog(`The minute list is empty due to the \"minute-range\" config\\nminute-range: ${JSON.stringify(this.minuteRange)}\\nminute-interval: ${this.opts.minuteInterval}`)\n                    } else {\n                        this.debugLog(`The second list is empty due to the \"second-range\" config\\nsecond-range: ${JSON.stringify(this.secondRange)}\\nsecond-interval: ${this.opts.secondInterval}`)\n                    }\n                }\n            }\n            return range\n        },\n\n        forceApmSelection() {\n            if (this.manualInput) {\n                // Skip this to allow users to paste a string value from the clipboard in Manual Input mode\n                return\n            }\n            if (this.apmType && !this.apm) {\n                if (this.has.am || this.has.pm) {\n                    this.doClearApmChecking = true\n                    const apmValue = this.has.am ? 'am' : 'pm'\n                    this.apm = this.apmType === 'A' ? apmValue.toUpperCase() : apmValue\n                }\n            }\n        },\n\n        emptyApmSelection() {\n            if (this.doClearApmChecking && this.hour === '' && this.minute === '' && this.second === '') {\n                this.apm = ''\n            }\n            this.doClearApmChecking = false\n        },\n\n        apmDisplayText(apmValue) {\n            if (this.amText && this.lowerCasedApm(apmValue) === 'am') {\n                return this.amText\n            }\n            if (this.pmText && this.lowerCasedApm(apmValue) === 'pm') {\n                return this.pmText\n            }\n            return apmValue\n        },\n\n        toggleActive() {\n            if (this.disabled) { return }\n            this.isActive = !this.isActive\n\n            if (this.isActive) {\n                this.isFocusing = true\n                if (this.manualInput) {\n                    this.$emit('focus')\n                }\n                if (!this.opts.hideDropdown) {\n                    this.setDropdownState(true)\n                }\n                // Record to check if value did change in the later phase\n                if (this.lazy) {\n                    this.bakDisplayTime = String(this.displayTime || '')\n                }\n                if (this.manualInput && !this.inputIsEmpty) {\n                    this.$nextTick(() => {\n                        if (this.$refs.input && this.$refs.input.selectionStart === 0 && this.$refs.input.selectionEnd === this.displayTime.length) {\n                            // Select the first slot instead of the whole value string when tabbed in\n                            this.selectFirstSlot()\n                        }\n                    })\n                }\n            } else {\n                if (this.showDropdown) {\n                    this.setDropdownState(false)\n                } else if (this.manualInput) {\n                    this.$emit('blur', this.getFullData())\n                }\n                this.isFocusing = false\n                if (this.lazy) {\n                    this.fillValues(true)\n                    this.bakDisplayTime = undefined\n                }\n            }\n\n            if (this.restrictedHourRange && this.baseOn12Hours) {\n                this.showDropdown ? this.forceApmSelection() : this.emptyApmSelection()\n            }\n            if (this.showDropdown) {\n                this.checkForAutoScroll()\n            }\n        },\n\n        setDropdownState(toShow, fromUserClick = false) {\n            if (toShow) {\n                if (this.appendToBody) {\n                    this.appendDropdownToBody()\n                }\n                this.keepFocusing()\n                if (this.autoDirectionEnabled) {\n                    this.checkDropDirection()\n                }\n                this.showDropdown = true\n                this.$emit('open')\n                if (fromUserClick) {\n                    if (this.fixedDropdownButton) {\n                        this.isActive = true\n                    }\n                    this.$emit('blur', this.getFullData())\n                    this.checkForAutoScroll()\n                }\n            } else {\n                this.showDropdown = false\n                this.$emit('close', this.getFullData())\n                if (this.appendToBody) {\n                    this.removeDropdownFromBody()\n                }\n            }\n        },\n\n        appendDropdownToBody() {\n            const dropdown = this.$refs && this.$refs.dropdown\n            const body = document.getElementsByTagName('body')[0]\n            if (body && dropdown) {\n                window.addEventListener('scroll', this.updateDropdownPos)\n                dropdown.classList.add('vue__time-picker-dropdown')\n                this.updateDropdownPos()\n                body.appendChild(dropdown)\n            }\n        },\n\n        updateDropdownPos() {\n            if (!this.appendToBody) { return }\n            const dropdown = this.$refs && this.$refs.dropdown\n            const body = document.getElementsByTagName('body')[0]\n            if (body && dropdown) {\n                const box = this.$el.getBoundingClientRect()\n                if (this.dropdownDirClass === 'drop-up') {\n                    dropdown.style.bottom = `${window.innerHeight - box.y}px`\n                    dropdown.style.top = 'auto'\n                } else {\n                    dropdown.style.top = `${box.y + box.height}px`\n                    dropdown.style.bottom = 'auto'\n                }\n                dropdown.style.left = `${box.x}px`\n            }\n        },\n\n        removeDropdownFromBody() {\n            const dropdown = this.$refs && this.$refs.dropdown\n            const body = document.getElementsByTagName('body')[0]\n            if (body && dropdown && body.contains(dropdown)) {\n                body.removeChild(dropdown)\n            }\n            if (dropdown) {\n                dropdown.classList.remove('vue__time-picker-dropdown')\n                dropdown.style.top = ''\n                dropdown.style.bottom = ''\n                dropdown.style.left = ''\n                this.$el.appendChild(dropdown)\n            }\n            window.removeEventListener('scroll', this.updateDropdownPos)\n        },\n\n        blurEvent() {\n            if (this.manualInput && !this.opts.hideDropdown) {\n                // hideDropdown's `blur` event is handled somewhere else\n                this.$emit('blur', this.getFullData())\n            }\n        },\n\n        select(type, value) {\n            if (this.isBasicType(type) && !this.isDisabled(type, value)) {\n                this[type] = value\n                if (this.doClearApmChecking) {\n                    this.doClearApmChecking = false\n                }\n            }\n        },\n\n        clearTime() {\n            if (this.disabled) { return }\n            this.hour = ''\n            this.minute = ''\n            this.second = ''\n            this.apm = ''\n\n            if (this.manualInput && this.$refs && this.$refs.input && this.$refs.input.value.length) {\n                this.$refs.input.value = ''\n            }\n\n            if (this.lazy) {\n                this.fillValues(true)\n            }\n        },\n\n        //\n        // Auto-Scroll\n        //\n\n        checkForAutoScroll() {\n            if (this.inputIsEmpty) { return }\n            if (this.autoScroll) {\n                this.$nextTick(() => {\n                    this.scrollToSelectedValues()\n                })\n            } else if (this.advancedKeyboard) {\n                // Auto-focus on selected value in the first column for advanced-keyboard\n                this.$nextTick(() => {\n                    const firstColumn = this.inUse.types[0]\n                    this.scrollToSelected(firstColumn, true)\n                })\n            }\n        },\n\n        scrollToSelected(column, allowFallback = false) {\n            if (!this.timeValue || this.inputIsEmpty) { return }\n            let targetList\n            if (this.appendToBody && this.$refs && this.$refs.dropdown) {\n                targetList = this.$refs.dropdown.querySelectorAll(`ul.${column}s`)[0]\n            } else {\n                targetList = this.$el.querySelectorAll(`ul.${column}s`)[0]\n            }\n            let targetValue = this.activeItemInCol(column)[0]\n            if (!targetValue && allowFallback) {\n                // No value selected in the target column, fallback to the first found valid item\n                targetValue = this.validItemsInCol(column)[0]\n            }\n            if (targetList && targetValue) {\n                targetList.scrollTop = targetValue.offsetTop || 0\n                if (this.advancedKeyboard) {\n                    targetValue.focus()\n                }\n            }\n        },\n\n        scrollToSelectedValues() {\n            if (!this.timeValue || this.inputIsEmpty) { return }\n            this.inUse.types.forEach(section => {\n                this.scrollToSelected(section)\n            })\n        },\n\n        //\n        // Additional Keyboard Navigation\n        //\n\n        onFocus() {\n            if (this.disabled) { return }\n            if (!this.isFocusing) {\n                this.isFocusing = true\n            }\n            if (!this.isActive) {\n                this.toggleActive()\n            }\n        },\n\n        escBlur() {\n            if (this.disabled) { return }\n            window.clearTimeout(this.debounceTimer)\n            this.isFocusing = false\n            const inputBox = this.$el.querySelectorAll('input.display-time')[0]\n            if (inputBox) {\n                inputBox.blur()\n            }\n        },\n\n        debounceBlur() {\n            if (this.disabled) { return }\n            this.isFocusing = false\n            window.clearTimeout(this.debounceTimer)\n            this.debounceTimer = window.setTimeout(() => {\n                window.clearTimeout(this.debounceTimer)\n                this.onBlur()\n            }, this.opts.blurDelay)\n        },\n\n        onBlur() {\n            if (!this.disabled && !this.isFocusing && this.isActive) {\n                this.toggleActive()\n            }\n        },\n\n        keepFocusing() {\n            if (this.disabled) { return }\n            window.clearTimeout(this.debounceTimer)\n            if (!this.isFocusing) {\n                this.isFocusing = true\n            }\n        },\n\n        onTab(column, value, evt) {\n            if (this.appendToBody && evt.shiftKey) {\n                const firstColumn = this.inUse.types[0]\n                if (column !== firstColumn) { return }\n                const firstValidValue = this.validItemsInCol(firstColumn)[0]\n                // Is the first valid item in the first column\n                if (firstValidValue && firstValidValue.getAttribute('data-key') === String(value)) {\n                    evt.preventDefault()\n                    // Focus back on <input>\n                    if (this.$refs && this.$refs.input) {\n                        this.$refs.input.focus()\n                    }\n                }\n            }\n        },\n\n        validItemsInCol(column) {\n            const columnClass = `${column}s`\n            if (this.appendToBody && this.$refs && this.$refs.dropdown) {\n                return this.$refs.dropdown.querySelectorAll(`ul.${columnClass} > li:not(.hint):not([disabled])`)\n            }\n            return this.$el.querySelectorAll(`ul.${columnClass} > li:not(.hint):not([disabled])`)\n        },\n\n        activeItemInCol(column) {\n            const columnClass = `${column}s`\n            if (this.appendToBody && this.$refs && this.$refs.dropdown) {\n                return this.$refs.dropdown.querySelectorAll(`ul.${columnClass} > li.active:not(.hint)`)\n            }\n            return this.$el.querySelectorAll(`ul.${columnClass} > li.active:not(.hint)`)\n        },\n\n        getClosestSibling(column, dataKey, getPrevious = false) {\n            const siblingsInCol = this.validItemsInCol(column)\n            const selfIndex = Array.prototype.findIndex.call(siblingsInCol, (sbl) => {\n                return sbl.getAttribute('data-key') === dataKey\n            })\n\n            // Already the first item\n            if (getPrevious && selfIndex === 0) {\n                return siblingsInCol[siblingsInCol.length - 1]\n            }\n            // Already the last item\n            if (!getPrevious && selfIndex === siblingsInCol.length - 1) {\n                return siblingsInCol[0]\n            }\n            // Selected value not in the valid values list\n            if (selfIndex < 0) {\n                return siblingsInCol[0]\n            }\n\n            if (getPrevious) {\n                return siblingsInCol[selfIndex - 1]\n            }\n            return siblingsInCol[selfIndex + 1]\n        },\n\n        prevItem(column, dataKey, isManualInput = false) {\n            const targetItem = this.getClosestSibling(column, dataKey, true)\n            if (targetItem) {\n                return isManualInput ? targetItem : targetItem.focus()\n            }\n        },\n\n        nextItem(column, dataKey, isManualInput = false) {\n            const targetItem = this.getClosestSibling(column, dataKey, false)\n            if (targetItem) {\n                return isManualInput ? targetItem : targetItem.focus()\n            }\n        },\n\n        getSideColumnName(currentColumn, toLeft = false) {\n            const currentColumnIndex = this.inUse.types.indexOf(currentColumn)\n            if (toLeft && currentColumnIndex <= 0) {\n                if (this.debugMode) {\n                    this.debugLog('You\\'re in the leftmost list already')\n                }\n                return\n            } else if (!toLeft && currentColumnIndex === (this.inUse.types.length - 1)) {\n                if (this.debugMode) {\n                    this.debugLog('You\\'re in the rightmost list already')\n                }\n                return\n            }\n            return this.inUse.types[toLeft ? currentColumnIndex - 1 : currentColumnIndex + 1]\n        },\n\n        getFirstItemInSideColumn(currentColumn, toLeft = false) {\n            const targetColumn = this.getSideColumnName(currentColumn, toLeft)\n            if (!targetColumn) { return }\n            const listItems = this.validItemsInCol(targetColumn)\n            if (listItems && listItems[0]) {\n                return listItems[0]\n            }\n        },\n\n        getActiveItemInSideColumn(currentColumn, toLeft = false) {\n            const targetColumn = this.getSideColumnName(currentColumn, toLeft)\n            if (!targetColumn) { return }\n            const activeItems = this.activeItemInCol(targetColumn)\n            if (activeItems && activeItems[0]) {\n                return activeItems[0]\n            }\n        },\n\n        toLeftColumn(currentColumn) {\n            const targetItem = this.getActiveItemInSideColumn(currentColumn, true) || this.getFirstItemInSideColumn(currentColumn, true)\n            if (targetItem) {\n                targetItem.focus()\n            }\n        },\n\n        toRightColumn(currentColumn) {\n            const targetItem = this.getActiveItemInSideColumn(currentColumn, false) || this.getFirstItemInSideColumn(currentColumn, false)\n            if (targetItem) {\n                targetItem.focus()\n            }\n        },\n\n        //\n        // Manual Input\n        //\n\n        onMouseDown() {\n            if (!this.manualInput) { return }\n            window.clearTimeout(this.selectionTimer)\n            this.selectionTimer = window.setTimeout(() => {\n                window.clearTimeout(this.selectionTimer)\n                if (this.$refs && this.$refs.input) {\n                    const nearestSlot = this.getNearestChunkByPos(this.$refs.input.selectionStart || 0)\n                    this.debounceSetInputSelection(nearestSlot)\n                }\n            }, 50)\n        },\n\n        keyDownHandler(evt) {\n            if (evt.isComposing || evt.keyCode === 229) {\n                // Skip IME inputs\n                evt.preventDefault()\n                evt.stopPropagation()\n                return false\n            }\n            // Numbers\n            if ((evt.keyCode >= 48 && evt.keyCode <= 57) || (evt.keyCode >= 96 && evt.keyCode <= 105)) {\n                evt.preventDefault()\n                this.keyboardInput(evt.key)\n                // A|P|M\n            } else if ([65, 80, 77].includes(evt.keyCode)) {\n                evt.preventDefault()\n                this.keyboardInput(evt.key, true)\n                // Arrow keys\n            } else if (evt.keyCode >= 37 && evt.keyCode <= 40) {\n                evt.preventDefault()\n                this.clearKbInputLog()\n                this.arrowHandler(evt)\n                // Delete|Backspace\n            } else if (evt.keyCode === 8 || evt.keyCode === 46) {\n                evt.preventDefault()\n                this.clearKbInputLog()\n                this.clearTime()\n                // Tab\n            } else if (evt.keyCode === 9) {\n                this.clearKbInputLog()\n                this.tabHandler(evt)\n                // Colon|Space\n            } else if (evt.keyCode === 186 || evt.keyCode === 32) {\n                evt.preventDefault()\n                this.clearKbInputLog()\n                this.toNextSlot()\n                // Prevent any Non-ESC and non-pasting inputs\n            } else if (evt.keyCode !== 27 && !(evt.metaKey || evt.ctrlKey)) {\n                evt.preventDefault()\n            }\n        },\n\n        onCompostionStart(evt) {\n            evt.preventDefault()\n            evt.stopPropagation()\n            this.bakCurrentPos = this.getCurrentTokenChunk()\n            return false\n        },\n\n        onCompostionEnd(evt) {\n            evt.preventDefault()\n            evt.stopPropagation()\n\n            const cpsData = evt.data\n            let inputIsCustomApmText = false\n            if (this.has.customApmText) {\n                inputIsCustomApmText = this.isCustomApmText(cpsData)\n            }\n            if (inputIsCustomApmText) {\n                this.setSanitizedValueToSection('apm', inputIsCustomApmText)\n            }\n\n            this.$refs.input.value = this.has.customApmText ? this.customDisplayTime : this.displayTime\n\n            this.$nextTick(() => {\n                if (this.bakCurrentPos) {\n                    const bakPos = JSON.parse(JSON.stringify(this.bakCurrentPos))\n                    if (inputIsCustomApmText) {\n                        bakPos.end = (bakPos.start + cpsData.length)\n                    }\n                    this.debounceSetInputSelection(bakPos)\n                    this.bakCurrentPos = null\n                }\n            })\n            return false\n        },\n\n        pasteHandler(evt) {\n            evt.preventDefault()\n            let pastingText = (evt.clipboardData || window.clipboardData).getData('text')\n            if (this.debugMode) {\n                this.debugLog(`Pasting value \"${pastingText}\" from clipboard`)\n            }\n            if (!pastingText || !pastingText.length) { return }\n\n            // Replace custom AM/PM text (if any)\n            if (this.has.customApmText) {\n                pastingText = this.replaceCustomApmText(pastingText)\n            }\n\n            if (this.inputIsEmpty) {\n                this.readStringValues(pastingText)\n            } else {\n                this.kbInputLog = pastingText.substr(-2, 2)\n                this.setKbInput()\n                this.debounceClearKbLog()\n            }\n        },\n\n        arrowHandler(evt) {\n            const direction = { 37: 'L', 38: 'U', 39: 'R', 40: 'D' }[evt.keyCode]\n            if (direction === 'U' || direction === 'D') {\n                if (this.inputIsEmpty) {\n                    this.selectFirstValidValue()\n                } else {\n                    const currentChunk = this.getCurrentTokenChunk()\n                    if (!currentChunk) {\n                        this.selectFirstValidValue()\n                        return\n                    }\n                    const tokenType = currentChunk.type\n                    this.getClosestValidItemInCol(tokenType, this[tokenType], direction)\n                    const newChunkPos = this.getCurrentTokenChunk()\n                    this.debounceSetInputSelection(newChunkPos)\n                }\n            } else if (direction === 'R') {\n                this.toLateralToken(false)\n            } else if (direction === 'L') {\n                this.toLateralToken(true)\n            }\n        },\n\n        tabHandler(evt) {\n            if (!this.inputIsEmpty && this.tokenChunksPos && this.tokenChunksPos.length) {\n                const currentChunk = this.getCurrentTokenChunk()\n                if (!currentChunk) { return }\n                const firstChunk = this.tokenChunksPos[0]\n                const lastChunk = this.tokenChunksPos[this.tokenChunksPos.length - 1]\n                if ((evt.shiftKey && currentChunk.token !== firstChunk.token) || (!evt.shiftKey && currentChunk.token !== lastChunk.token)) {\n                    evt.preventDefault()\n                    this.toLateralToken(evt.shiftKey)\n                }\n            } else if (this.appendToBody && this.advancedKeyboard) {\n                if (evt.shiftKey) { return }\n                evt.preventDefault()\n                if (this.inputIsEmpty) {\n                    const firstColumn = this.inUse.types[0]\n                    const targetValue = this.validItemsInCol(firstColumn)[0]\n                    if (targetValue) {\n                        targetValue.focus()\n                    }\n                }\n            }\n        },\n\n        keyboardInput(newChar, isApm = false) {\n            const currentChunk = this.getCurrentTokenChunk()\n            if (!currentChunk || (currentChunk.type !== 'apm' && isApm) || (currentChunk.type === 'apm' && !isApm)) { return }\n            this.kbInputLog = `${this.kbInputLog.substr(-1)}${newChar}`\n            this.setKbInput()\n            this.debounceClearKbLog()\n        },\n\n        clearKbInputLog() {\n            window.clearTimeout(this.kbInputTimer)\n            this.kbInputLog = ''\n        },\n\n        debounceClearKbLog() {\n            window.clearTimeout(this.kbInputTimer)\n            this.kbInputTimer = window.setTimeout(() => {\n                this.clearKbInputLog()\n            }, this.opts.manualInputTimeout)\n        },\n\n        setKbInput(value) {\n            value = value || this.kbInputLog\n            const currentChunk = this.getCurrentTokenChunk()\n            if (!currentChunk || !value || !value.length) { return }\n            const chunkType = currentChunk.type\n            const chunkToken = currentChunk.token\n\n            let validValue\n            if (chunkType === 'apm') {\n                if (this.lowerCasedApm(value).includes('a')) {\n                    validValue = 'am'\n                } else if (this.lowerCasedApm(value).includes('p')) {\n                    validValue = 'pm'\n                }\n                if (validValue) {\n                    validValue = chunkToken === 'A' ? validValue.toUpperCase() : validValue\n                }\n            } else {\n                if (this.isValidValue(chunkToken, value)) {\n                    validValue = value\n                } else {\n                    const lastInputValue = this.formatValue(chunkToken, value.substr(-1))\n                    if (this.isValidValue(chunkToken, lastInputValue)) {\n                        validValue = lastInputValue\n                    }\n                }\n            }\n\n            if (validValue) {\n                this.setSanitizedValueToSection(chunkType, validValue)\n                const newChunkPos = this.getCurrentTokenChunk()\n                this.debounceSetInputSelection(newChunkPos)\n            }\n            if (this.debugMode) {\n                if (validValue) {\n                    this.debugLog(`Successfully set value \"${validValue}\" from latest input \"${value}\" for the \"${chunkType}\" slot`)\n                } else {\n                    this.debugLog(`Value \"${value}\" is invalid in the \"${chunkType}\" slot`)\n                }\n            }\n        },\n\n        // Form Autofill\n        onChange() {\n            if (!this.manualInput || !this.$refs || !this.$refs.input) { return }\n            const autoFillValue = this.$refs.input.value || ''\n            if (autoFillValue && autoFillValue.length) {\n                this.readStringValues(autoFillValue)\n            }\n        },\n\n        getNearestChunkByPos(startPos) {\n            if (!this.tokenChunksPos || !this.tokenChunksPos.length) { return }\n            let nearest\n            let nearestDelta = -1\n            for (let i = 0; i < this.tokenChunksPos.length; i++) {\n                const chunk = JSON.parse(JSON.stringify(this.tokenChunksPos[i]))\n                if (chunk.start === startPos) {\n                    return chunk\n                }\n                const delta = Math.abs(chunk.start - startPos)\n                if (nearestDelta < 0) {\n                    nearest = chunk\n                    nearestDelta = delta\n                } else {\n                    if (nearestDelta <= delta) {\n                        return nearest\n                    }\n                    nearestDelta = delta\n                    nearest = chunk\n                }\n            }\n            return nearest\n        },\n\n        selectFirstValidValue() {\n            if (!this.tokenChunksPos || !this.tokenChunksPos.length) { return }\n            const firstSlotType = this.tokenChunksPos[0].type\n            if (firstSlotType === 'hour') {\n                this.getClosestHourItem()\n            } else {\n                this.getClosestValidItemInCol(firstSlotType, this[firstSlotType])\n            }\n            this.selectFirstSlot()\n        },\n\n        getClosestHourItem(currentValue, direction = 'U') {\n            if (!this.validHoursList || !this.validHoursList.length) {\n                if (this.debugMode) {\n                    this.debugLog(`No valid hour values found, please check your \"hour-range\" config\\nhour-range: ${JSON.stringify(this.hourRange)}`)\n                }\n                return\n            }\n            if (!currentValue) {\n                this.setManualHour(this.validHoursList[0])\n                return\n            }\n            const currentIndex = this.validHoursList.findIndex(item => {\n                if (!this.baseOn12Hours) {\n                    return item === currentValue\n                } else {\n                    const valueKey = `${currentValue}${this.lowerCasedApm(this.apm) === 'pm' ? 'p' : 'a'}`\n                    return item === valueKey\n                }\n            })\n            let nextIndex\n            if (currentIndex === -1) {\n                nextIndex = 0\n            } else if (direction === 'D') {\n                nextIndex = currentIndex === 0 ? this.validHoursList.length - 1 : currentIndex - 1\n            } else {\n                nextIndex = (currentIndex + 1) % this.validHoursList.length\n            }\n            const nextItem = this.validHoursList[nextIndex]\n            this.setManualHour(nextItem)\n        },\n\n        getClosestValidItemInCol(column, currentValue, direction = 'U') {\n            if (column === 'hour') {\n                this.getClosestHourItem(currentValue, direction)\n            } else {\n                const nextItem = direction === 'D' ? this.prevItem(column, this[column], true) : this.nextItem(column, this[column], true)\n                if (nextItem) {\n                    this.select(column, nextItem.getAttribute('data-key'))\n                }\n            }\n        },\n\n        setSanitizedValueToSection(section, inputValue) {\n            if (!section || !this.getTokenByType(section)) { return }\n            // NOTE: Disabled values are allowed here, followed by an 'error' event, though\n            const sanitizedValue = this.sanitizedValue(this.getTokenByType(section), inputValue)\n            this[section] = sanitizedValue\n        },\n\n        setManualHour(nextItem) {\n            if (this.is12hRange(nextItem)) {\n                const hourT = this.match12hRange(nextItem)\n                const apmValue = hourT[2] === 'a' ? 'AM' : 'PM'\n                this.setSanitizedValueToSection('apm', this.apmType === 'a' ? apmValue.toLowerCase() : apmValue)\n                this.setSanitizedValueToSection('hour', hourT[1])\n            } else {\n                this.setSanitizedValueToSection('hour', nextItem)\n            }\n        },\n\n        debounceSetInputSelection({ start = 0, end = 0 }) {\n            this.$nextTick(() => {\n                this.setInputSelectionRange(start, end)\n            })\n            window.clearTimeout(this.selectionTimer)\n            this.selectionTimer = window.setTimeout(() => {\n                window.clearTimeout(this.selectionTimer)\n                // Double-check selection for 12hr format\n                if (this.$refs.input && (this.$refs.input.selectionStart !== start || this.$refs.input.selectionEnd !== end)) {\n                    this.setInputSelectionRange(start, end)\n                }\n            }, 30)\n        },\n\n        setInputSelectionRange(start, end) {\n            if (this.$refs && this.$refs.input) {\n                this.$refs.input.setSelectionRange(start, end)\n            }\n        },\n\n        getCurrentTokenChunk() {\n            return this.getNearestChunkByPos((this.$refs.input && this.$refs.input.selectionStart) || 0)\n        },\n\n        selectFirstSlot() {\n            const firstChunkPos = this.getNearestChunkByPos(0)\n            this.debounceSetInputSelection(firstChunkPos)\n        },\n\n        toNextSlot() {\n            if (!this.inputIsEmpty && this.tokenChunksPos && this.tokenChunksPos.length) {\n                const currentChunk = this.getCurrentTokenChunk()\n                if (!currentChunk) { return }\n                const lastChunk = this.tokenChunksPos[this.tokenChunksPos.length - 1]\n                if (currentChunk.token !== lastChunk.token) {\n                    this.toLateralToken(false)\n                }\n            }\n        },\n\n        toLateralToken(toLeft) {\n            const currentChunk = this.getCurrentTokenChunk()\n            if (!currentChunk) {\n                this.selectFirstValidValue()\n                return\n            }\n            const currentChunkIndex = this.tokenChunksPos.findIndex(chk => chk.token === currentChunk.token)\n            if ((!toLeft && currentChunkIndex >= this.tokenChunksPos.length - 1) || (toLeft && currentChunkIndex === 0)) {\n                if (this.debugMode) {\n                    if (toLeft) {\n                        this.debugLog('You\\'re in the leftmost slot already')\n                    } else {\n                        this.debugLog('You\\'re in the rightmost slot already')\n                    }\n                }\n                return\n            }\n            const targetSlotPos = toLeft ? this.tokenChunksPos[currentChunkIndex - 1] : this.tokenChunksPos[currentChunkIndex + 1]\n            this.debounceSetInputSelection(targetSlotPos)\n        },\n\n        isCustomApmText(inputData) {\n            if (!inputData || !inputData.length) { return false }\n            if (this.amText && this.amText === inputData) {\n                return this.apmType === 'A' ? 'AM' : 'am'\n            }\n            if (this.pmText && this.pmText === inputData) {\n                return this.apmType === 'A' ? 'PM' : 'pm'\n            }\n            return false\n        },\n\n        replaceCustomApmText(inputString) {\n            if (this.amText && this.amText.length && inputString.includes(this.amText)) {\n                return inputString.replace(new RegExp(this.amText, 'g'), this.apmType === 'A' ? 'AM' : 'am')\n            } else if (this.pmText && this.pmText.length && inputString.includes(this.pmText)) {\n                return inputString.replace(new RegExp(this.pmText, 'g'), this.apmType === 'A' ? 'PM' : 'pm')\n            }\n            return inputString\n        },\n\n        checkDropDirection() {\n            if (!this.$el) { return }\n            let container\n            if (this.containerId && this.containerId.length) {\n                container = document.getElementById(this.containerId)\n                if (!container && this.debugMode) {\n                    this.debugLog(`Container with id \"${this.containerId}\" not found. Fallback to document body.`)\n                }\n            }\n            const el = this.$el\n            let spaceDown\n            if (container && container.offsetHeight) {\n                // Valid container found\n                spaceDown = (container.offsetTop + container.offsetHeight) - (el.offsetTop + el.offsetHeight)\n            } else {\n                // Fallback to document body\n                const docHeight = Math.max(document.body.scrollHeight, document.documentElement.scrollHeight, document.body.offsetHeight, document.documentElement.offsetHeight, document.body.clientHeight, document.documentElement.clientHeight)\n                spaceDown = docHeight - (el.offsetTop + el.offsetHeight)\n            }\n            this.forceDropOnTop = this.opts.dropOffsetHeight > spaceDown\n        },\n\n        //\n        // Helpers\n        //\n\n        is12hRange(value) {\n            return /^\\d{1,2}(a|p|A|P)$/.test(value)\n        },\n\n        match12hRange(value) {\n            return value.match(/^(\\d{1,2})(a|p|A|P)$/)\n        },\n\n        isNumber(value) {\n            return !isNaN(parseFloat(value)) && isFinite(value)\n        },\n\n        isBasicType(type) {\n            return CONFIG.BASIC_TYPES.includes(type)\n        },\n\n        lowerCasedApm(apmValue) {\n            return (apmValue || '').toLowerCase()\n        },\n\n        getTokenRegex(token) {\n            switch (token) {\n                case 'HH':\n                    return '([01][0-9]|2[0-3]|H{2})'\n                case 'H':\n                    return '([0-9]{1}|1[0-9]|2[0-3]|H{1})'\n                case 'hh':\n                    return '(0[1-9]|1[0-2]|h{2})'\n                case 'h':\n                    return '([1-9]{1}|1[0-2]|h{1})'\n                case 'kk':\n                    return '(0[1-9]|1[0-9]|2[0-4]|k{2})'\n                case 'k':\n                    return '([1-9]{1}|1[0-9]|2[0-4]|k{1})'\n                case 'mm':\n                    return '([0-5][0-9]|m{2})'\n                case 'ss':\n                    return '([0-5][0-9]|s{2})'\n                case 'm':\n                    return '([0-9]{1}|[1-5][0-9]|m{1})'\n                case 's':\n                    return '([0-9]{1}|[1-5][0-9]|s{1})'\n                case 'A':\n                    return '(AM|PM|A{1})'\n                case 'a':\n                    return '(am|pm|a{1})'\n                default:\n                    return ''\n            }\n        },\n\n        isEmptyValue(targetToken, testValue) {\n            return (!testValue || !testValue.length) || (testValue && testValue === targetToken)\n        },\n\n        isValidValue(targetToken, testValue) {\n            if (!targetToken || this.isEmptyValue(targetToken, testValue)) { return false }\n            const tokenRegexStr = this.getTokenRegex(targetToken)\n            if (!tokenRegexStr || !tokenRegexStr.length) { return false }\n            return (new RegExp(`^${tokenRegexStr}$`)).test(testValue)\n        },\n\n        sanitizedValue(targetToken, inputValue) {\n            if (this.isValidValue(targetToken, inputValue)) {\n                return inputValue\n            }\n            return ''\n        },\n\n        getTokenType(token) {\n            return this.inUse.types[this.inUse.tokens.indexOf(token)] || ''\n        },\n\n        getTokenByType(type) {\n            return this[`${type}Type`] || ''\n        },\n\n        isMinuteOrSecond(type) {\n            return ['minute', 'second'].includes(type)\n        },\n\n        debugLog(logText) {\n            if (!logText || !logText.length) { return }\n            let identifier = ''\n            if (this.id) {\n                identifier += `#${this.id}`\n            }\n            if (this.name) {\n                identifier += `[name=${this.name}]`\n            }\n            if (this.inputClass) {\n                let inputClasses = []\n                if (typeof this.inputClass === 'string') {\n                    inputClasses = this.inputClass.split(/\\s/g)\n                } else if (Array.isArray(this.inputClass)) {\n                    inputClasses = [].concat([], this.inputClass)\n                } else if (typeof this.inputClass === 'object') {\n                    Object.keys(this.inputClass).forEach(clsName => {\n                        if (this.inputClass[clsName]) {\n                            inputClasses.push(clsName)\n                        }\n                    })\n                }\n                for (let inputClass of inputClasses) {\n                    if (inputClass && inputClass.trim().length) {\n                        identifier += `.${inputClass.trim()}`\n                    }\n                }\n            }\n            const finalLogText = `DEBUG: ${logText}${identifier ? `\\n\\t(${identifier})` : ''}`\n            if (window.console.debug && typeof window.console.debug === 'function') {\n                window.console.debug(finalLogText)\n            } else {\n                window.console.log(finalLogText)\n            }\n        }\n    },\n\n    mounted() {\n        window.clearTimeout(this.debounceTimer)\n        window.clearTimeout(this.selectionTimer)\n        window.clearTimeout(this.kbInputTimer)\n        this.renderFormat()\n    },\n\n    beforeDestroy() {\n        window.clearTimeout(this.debounceTimer)\n        window.clearTimeout(this.selectionTimer)\n        window.clearTimeout(this.kbInputTimer)\n    }\n}\n</script>\n\n<template>\n    <span class=\"vue__time-picker time-picker\" :style=\"inputWidthStyle\">\n        <input type=\"text\" class=\"display-time\" ref=\"input\"\n            :class=\"[inputClass, { 'is-empty': inputIsEmpty, 'invalid': hasInvalidInput, 'all-selected': allValueSelected, 'disabled': disabled, 'has-custom-icon': $slots && $slots.icon }]\"\n            :style=\"inputWidthStyle\" :id=\"id\" :name=\"name\" :value=\"inputIsEmpty ? null : customDisplayTime\"\n            :placeholder=\"placeholder ? placeholder : formatString\" :tabindex=\"disabled ? -1 : tabindex\"\n            :disabled=\"disabled\" :readonly=\"!manualInput\" :autocomplete=\"autocomplete\" @focus=\"onFocus\" @change=\"onChange\"\n            @blur=\"debounceBlur(); blurEvent()\" @mousedown=\"onMouseDown\" @keydown=\"keyDownHandler\"\n            @compositionstart=\"onCompostionStart\" @compositionend=\"onCompostionEnd\" @paste=\"pasteHandler\"\n            @keydown.esc.exact=\"escBlur\" />\n        <div class=\"controls\" v-if=\"showClearBtn || showDropdownBtn\" tabindex=\"-1\">\n            <span v-if=\"!isActive && showClearBtn\" class=\"clear-btn\" tabindex=\"-1\"\n                :class=\"{ 'has-custom-btn': $slots && $slots.clearButton }\" @click=\"clearTime\">\n                <slot name=\"clearButton\"><span class=\"char\">&times;</span></slot>\n            </span>\n            <span v-if=\"showDropdownBtn\" class=\"dropdown-btn\" tabindex=\"-1\"\n                :class=\"{ 'has-custom-btn': $slots && $slots.dropdownButton }\"\n                @click=\"setDropdownState(fixedDropdownButton ? !showDropdown : true, true)\" @mousedown=\"keepFocusing\">\n                <slot name=\"dropdownButton\"><span class=\"char\">&dtrif;</span></slot>\n            </span>\n        </div>\n        <div class=\"custom-icon\" v-if=\"$slots && $slots.icon\">\n            <slot name=\"icon\"></slot>\n        </div>\n        <div class=\"time-picker-overlay\" v-if=\"showDropdown\" @click=\"toggleActive\" tabindex=\"-1\"></div>\n        <div class=\"dropdown\" ref=\"dropdown\" v-show=\"showDropdown\" tabindex=\"-1\" :class=\"[dropdownDirClass]\"\n            :style=\"inputWidthStyle\" @mouseup=\"keepFocusing\" @click.stop=\"\">\n            <div class=\"select-list\" :style=\"inputWidthStyle\" tabindex=\"-1\">\n                <!-- Common Keyboard Support: less event listeners -->\n                <template v-if=\"!advancedKeyboard\">\n                    <template v-for=\"column in columnsSequence\">\n                        <header class=\"hint\" v-text=\"hourLabelText\" v-if=\"column === 'hour'\" :key=\"column\">\n                        </header>\n                        <ul v-if=\"column === 'hour'\" :key=\"column\" class=\"hours\" @scroll=\"keepFocusing\">\n                            <template v-for=\"(hr, hIndex) in hours\">\n                                <li v-if=\"!opts.hideDisabledHours || (opts.hideDisabledHours && !isDisabled('hour', hr))\"\n                                    :key=\"hIndex\" :class=\"{ active: hour === hr }\" :disabled=\"isDisabled('hour', hr)\"\n                                    :data-key=\"hr\" v-text=\"hr\" @click=\"select('hour', hr)\"></li>\n                            </template>\n                        </ul>\n                        <header class=\"hint\" v-text=\"minuteLabelText\" v-if=\"column === 'minute'\" :key=\"column\">\n                        </header>\n                        <ul v-if=\"column === 'minute'\" :key=\"column\" class=\"minutes\" @scroll=\"keepFocusing\">\n                            <template v-for=\"(m, mIndex) in minutes\">\n                                <li v-if=\"!opts.hideDisabledMinutes || (opts.hideDisabledMinutes && !isDisabled('minute', m))\"\n                                    :key=\"mIndex\" :class=\"{ active: minute === m }\" :disabled=\"isDisabled('minute', m)\"\n                                    :data-key=\"m\" v-text=\"m\" @click=\"select('minute', m)\"></li>\n                            </template>\n                        </ul>\n                        <header class=\"hint\" v-text=\"secondLabelText\" v-if=\"column === 'second'\" :key=\"column\"></header>\n                        <ul v-if=\"column === 'second'\" :key=\"column\" class=\"seconds\" @scroll=\"keepFocusing\">\n                            <template v-for=\"(s, sIndex) in seconds\">\n                                <li v-if=\"!opts.hideDisabledSeconds || (opts.hideDisabledSeconds && !isDisabled('second', s))\"\n                                    :key=\"sIndex\" :class=\"{ active: second === s }\" :disabled=\"isDisabled('second', s)\"\n                                    :data-key=\"s\" v-text=\"s\" @click=\"select('second', s)\"></li>\n                            </template>\n                        </ul>\n                        <header class=\"hint\" v-text=\"apmLabelText\" v-if=\"column === 'apm'\" :key=\"column\"></header>\n                        <ul v-if=\"column === 'apm'\" :key=\"column\" class=\"apms\" @scroll=\"keepFocusing\">\n                            <template v-for=\"(a, aIndex) in apms\">\n                                <li v-if=\"!opts.hideDisabledHours || (opts.hideDisabledHours && !isDisabled('apm', a))\"\n                                    :key=\"aIndex\" :class=\"{ active: apm === a }\" :disabled=\"isDisabled('apm', a)\"\n                                    :data-key=\"a\" v-text=\"apmDisplayText(a)\" @click=\"select('apm', a)\"></li>\n                            </template>\n                        </ul>\n                    </template>\n                </template><!-- / Common Keyboard Support -->\n\n                <!--\n                                                                                                Advanced Keyboard Support\n                                                                                                Addeds hundreds of additional event lisenters\n                                                                                              -->\n                <template v-if=\"advancedKeyboard\">\n                    <template v-for=\"column in columnsSequence\">\n                        <header class=\"hint\" v-text=\"hourLabelText\" tabindex=\"-1\" v-if=\"column === 'hour'\" :key=\"column\">\n                        </header>\n                        <ul v-if=\"column === 'hour'\" :key=\"column\" class=\"hours\" tabindex=\"-1\" @scroll=\"keepFocusing\">\n                            <template v-for=\"(hr, hIndex) in hours\">\n                                <li v-if=\"!opts.hideDisabledHours || (opts.hideDisabledHours && !isDisabled('hour', hr))\"\n                                    :key=\"hIndex\" :class=\"{ active: hour === hr }\"\n                                    :tabindex=\"isDisabled('hour', hr) ? -1 : tabindex\" :data-key=\"hr\"\n                                    :disabled=\"isDisabled('hour', hr)\" v-text=\"hr\" @click=\"select('hour', hr)\"\n                                    @keydown.tab=\"onTab('hour', hr, $event)\" @keydown.space.prevent=\"select('hour', hr)\"\n                                    @keydown.enter.prevent=\"select('hour', hr)\" @keydown.up.prevent=\"prevItem('hour', hr)\"\n                                    @keydown.down.prevent=\"nextItem('hour', hr)\"\n                                    @keydown.left.prevent=\"toLeftColumn('hour')\"\n                                    @keydown.right.prevent=\"toRightColumn('hour')\" @keydown.esc.exact=\"debounceBlur\"\n                                    @blur=\"debounceBlur\" @focus=\"keepFocusing\"></li>\n                            </template>\n                        </ul>\n                        <header class=\"hint\" v-text=\"minuteLabelText\" tabindex=\"-1\" v-if=\"column === 'minute'\"\n                            :key=\"column\">\n                        </header>\n                        <ul v-if=\"column === 'minute'\" :key=\"column\" class=\"minutes\" tabindex=\"-1\" @scroll=\"keepFocusing\">\n                            <template v-for=\"(m, mIndex) in minutes\">\n                                <li v-if=\"!opts.hideDisabledMinutes || (opts.hideDisabledMinutes && !isDisabled('minute', m))\"\n                                    :key=\"mIndex\" :class=\"{ active: minute === m }\"\n                                    :tabindex=\"isDisabled('minute', m) ? -1 : tabindex\" :data-key=\"m\"\n                                    :disabled=\"isDisabled('minute', m)\" v-text=\"m\" @click=\"select('minute', m)\"\n                                    @keydown.tab=\"onTab('minute', m, $event)\" @keydown.space.prevent=\"select('minute', m)\"\n                                    @keydown.enter.prevent=\"select('minute', m)\" @keydown.up.prevent=\"prevItem('minute', m)\"\n                                    @keydown.down.prevent=\"nextItem('minute', m)\"\n                                    @keydown.left.prevent=\"toLeftColumn('minute')\"\n                                    @keydown.right.prevent=\"toRightColumn('minute')\" @keydown.esc.exact=\"debounceBlur\"\n                                    @blur=\"debounceBlur\" @focus=\"keepFocusing\"></li>\n                            </template>\n                        </ul>\n                        <header class=\"hint\" v-text=\"secondLabelText\" tabindex=\"-1\" v-if=\"column === 'second'\"\n                            :key=\"column\"></header>\n\n                        <ul v-if=\"column === 'second'\" :key=\"column\" class=\"seconds\" tabindex=\"-1\" @scroll=\"keepFocusing\">\n                            <template v-for=\"(s, sIndex) in seconds\">\n                                <li v-if=\"!opts.hideDisabledSeconds || (opts.hideDisabledSeconds && !isDisabled('second', s))\"\n                                    :key=\"sIndex\" :class=\"{ active: second === s }\"\n                                    :tabindex=\"isDisabled('second', s) ? -1 : tabindex\" :data-key=\"s\"\n                                    :disabled=\"isDisabled('second', s)\" v-text=\"s\" @click=\"select('second', s)\"\n                                    @keydown.tab=\"onTab('second', s, $event)\" @keydown.space.prevent=\"select('second', s)\"\n                                    @keydown.enter.prevent=\"select('second', s)\" @keydown.up.prevent=\"prevItem('second', s)\"\n                                    @keydown.down.prevent=\"nextItem('second', s)\"\n                                    @keydown.left.prevent=\"toLeftColumn('second')\"\n                                    @keydown.right.prevent=\"toRightColumn('second')\" @keydown.esc.exact=\"debounceBlur\"\n                                    @blur=\"debounceBlur\" @focus=\"keepFocusing\"></li>\n                            </template>\n                        </ul>\n                        <header class=\"hint\" v-text=\"apmLabelText\" tabindex=\"-1\" v-if=\"column === 'apm'\" :key=\"column\">\n                        </header>\n                        <ul v-if=\"column === 'apm'\" :key=\"column\" class=\"apms\" tabindex=\"-1\" @scroll=\"keepFocusing\">\n                            <template v-for=\"(a, aIndex) in apms\">\n                                <li v-if=\"!opts.hideDisabledHours || (opts.hideDisabledHours && !isDisabled('apm', a))\"\n                                    :key=\"aIndex\" :class=\"{ active: apm === a }\"\n                                    :tabindex=\"isDisabled('apm', a) ? -1 : tabindex\" :data-key=\"a\"\n                                    :disabled=\"isDisabled('apm', a)\" v-text=\"apmDisplayText(a)\" @click=\"select('apm', a)\"\n                                    @keydown.tab=\"onTab('apm', a, $event)\" @keydown.space.prevent=\"select('apm', a)\"\n                                    @keydown.enter.prevent=\"select('apm', a)\" @keydown.up.prevent=\"prevItem('apm', a)\"\n                                    @keydown.down.prevent=\"nextItem('apm', a)\" @keydown.left.prevent=\"toLeftColumn('apm')\"\n                                    @keydown.right.prevent=\"toRightColumn('apm')\" @keydown.esc.exact=\"debounceBlur\"\n                                    @blur=\"debounceBlur\" @focus=\"keepFocusing\"></li>\n                            </template>\n                        </ul>\n                    </template>\n                </template><!-- / Advanced Keyboard Support -->\n            </div>\n        </div>\n    </span>\n</template>\n\n<style>\n.vue__time-picker {\n    display: inline-block;\n    position: relative;\n    font-size: 1em;\n    width: 10em;\n    font-family: sans-serif;\n    vertical-align: middle;\n}\n\n.vue__time-picker * {\n    box-sizing: border-box;\n}\n\n.vue__time-picker input.display-time {\n    border: 1px solid #d2d2d2;\n    width: 10em;\n    height: 2.2em;\n    padding: 0.3em 0.5em;\n    font-size: 1em;\n}\n\n.vue__time-picker input.has-custom-icon {\n    padding-left: 1.8em;\n}\n\n.vue__time-picker input.display-time.invalid:not(.skip-error-style) {\n    border-color: #cc0033;\n    outline-color: #cc0033;\n}\n\n.vue__time-picker input.display-time:disabled,\n.vue__time-picker input.display-time.disabled {\n    color: #d2d2d2;\n}\n\n.vue__time-picker .controls {\n    position: absolute;\n    top: 0;\n    bottom: 0;\n    right: 0;\n    z-index: 3;\n\n    display: flex;\n    flex-flow: row nowrap;\n    justify-content: flex-end;\n    align-items: stretch;\n\n    /* Prevent browser focusing on the controls layer */\n    pointer-events: none;\n}\n\n.vue__time-picker .controls>* {\n    cursor: pointer;\n\n    width: auto;\n    display: flex;\n    flex-flow: column nowrap;\n    justify-content: center;\n    align-items: center;\n\n    padding: 0 0.35em;\n\n    color: #d2d2d2;\n    line-height: 100%;\n    font-style: normal;\n\n    /* Resume pointer-events on children components */\n    pointer-events: initial;\n\n    transition: color .2s, opacity .2s;\n}\n\n.vue__time-picker .controls>*:hover {\n    color: #797979;\n}\n\n.vue__time-picker .controls>*:focus,\n.vue__time-picker .controls>*:active {\n    outline: 0;\n}\n\n.vue__time-picker .controls .char {\n    font-size: 1.1em;\n    line-height: 100%;\n\n    /* Vertical align fixes for webkit browsers only */\n    -webkit-margin-before: -0.15em;\n}\n\n.vue__time-picker .custom-icon {\n    z-index: 2;\n    position: absolute;\n    left: 0;\n    top: 0;\n    bottom: 0;\n    width: 1.8em;\n\n    display: flex;\n    flex-flow: column nowrap;\n    justify-content: center;\n    align-items: center;\n\n    /* pass down mouse events to the <input> underneath */\n    pointer-events: none;\n}\n\n.vue__time-picker .custom-icon img,\n.vue__time-picker .custom-icon svg,\n.vue__time-picker .controls img,\n.vue__time-picker .controls svg {\n    display: inline-block;\n    vertical-align: middle;\n    margin: 0;\n    border: 0;\n    outline: 0;\n    max-width: 1em;\n    height: auto;\n}\n\n.vue__time-picker .time-picker-overlay {\n    z-index: 4;\n    position: fixed;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n}\n\n.vue__time-picker .dropdown,\n.vue__time-picker-dropdown {\n    position: absolute;\n    z-index: 5;\n    top: calc(2.2em + 2px);\n    left: 0;\n    background: #fff;\n    box-shadow: 0 1px 6px rgba(0, 0, 0, 0.15);\n    width: 10em;\n    height: 10em;\n    font-weight: normal;\n}\n\n/* Dropdown class when \"append-to-body\" is on */\n.vue__time-picker-dropdown {\n    position: fixed;\n    z-index: 100;\n}\n\n.vue__time-picker .dropdown.drop-up,\n.vue__time-picker-dropdown.drop-up {\n    top: auto;\n    bottom: calc(2.2em + 1px);\n}\n\n.vue__time-picker .dropdown .select-list,\n.vue__time-picker-dropdown .select-list {\n    width: 10em;\n    height: 10em;\n    overflow: hidden;\n    display: flex;\n    flex-flow: row nowrap;\n    align-items: stretch;\n    justify-content: space-between;\n}\n\n.vue__time-picker .dropdown .select-list:focus,\n.vue__time-picker .dropdown .select-list:active,\n.vue__time-picker-dropdown .select-list:focus,\n.vue__time-picker-dropdown .select-list:active {\n    outline: 0;\n}\n\n.vue__time-picker .dropdown ul,\n.vue__time-picker-dropdown ul {\n    padding: 0;\n    margin: 0;\n    list-style: none;\n    outline: 0;\n\n    flex: 1 1 0.00001px;\n    overflow-x: hidden;\n    overflow-y: auto;\n}\n\n.vue__time-picker .dropdown ul.minutes,\n.vue__time-picker .dropdown ul.seconds,\n.vue__time-picker .dropdown ul.apms,\n.vue__time-picker-dropdown ul.minutes,\n.vue__time-picker-dropdown ul.seconds,\n.vue__time-picker-dropdown ul.apms {\n    border-left: 1px solid #fff;\n}\n\n.vue__time-picker .dropdown ul li,\n.vue__time-picker-dropdown ul li {\n    list-style: none;\n    text-align: center;\n    padding: 0.3em 0;\n    color: #161616;\n}\n\n.vue__time-picker .dropdown ul li:not(.hint):not([disabled]):hover,\n.vue__time-picker .dropdown ul li:not(.hint):not([disabled]):focus,\n.vue__time-picker-dropdown ul li:not(.hint):not([disabled]):hover,\n.vue__time-picker-dropdown ul li:not(.hint):not([disabled]):focus {\n    background: rgba(0, 0, 0, .08);\n    color: #161616;\n    cursor: pointer;\n}\n\n.vue__time-picker .dropdown ul li:not([disabled]).active,\n.vue__time-picker .dropdown ul li:not([disabled]).active:hover,\n.vue__time-picker .dropdown ul li:not([disabled]).active:focus,\n.vue__time-picker-dropdown ul li:not([disabled]).active,\n.vue__time-picker-dropdown ul li:not([disabled]).active:hover,\n.vue__time-picker-dropdown ul li:not([disabled]).active:focus {\n    background: #41B883;\n    color: #fff;\n}\n\n.vue__time-picker .dropdown ul li[disabled],\n.vue__time-picker .dropdown ul li[disabled]:hover,\n.vue__time-picker-dropdown ul li[disabled],\n.vue__time-picker-dropdown ul li[disabled]:hover {\n    background: transparent;\n    opacity: 0.3;\n    cursor: not-allowed;\n}\n\n.vue__time-picker .dropdown .hint,\n.vue__time-picker-dropdown .hint {\n    color: #a5a5a5;\n    cursor: default;\n    font-size: 0.8em;\n}</style>\n"]}]}