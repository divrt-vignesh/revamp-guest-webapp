{"remainingRequest":"/home/vignesh/DIVRT/guest-webapp/node_modules/vue-loader/lib/index.js??vue-loader-options!/home/vignesh/DIVRT/guest-webapp/src/uiComponents/SpherePhoneNumberInput/assets/RecycleScroller.vue?vue&type=script&lang=js&","dependencies":[{"path":"/home/vignesh/DIVRT/guest-webapp/src/uiComponents/SpherePhoneNumberInput/assets/RecycleScroller.vue","mtime":1686725510912},{"path":"/home/vignesh/DIVRT/guest-webapp/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/vignesh/DIVRT/guest-webapp/node_modules/babel-loader/lib/index.js","mtime":315532800000},{"path":"/home/vignesh/DIVRT/guest-webapp/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/vignesh/DIVRT/guest-webapp/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:Ly8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KCmltcG9ydCB7IHNoYWxsb3dSZWFjdGl2ZSwgbWFya1JhdyB9IGZyb20gJ3Z1ZScKaW1wb3J0IHsgUmVzaXplT2JzZXJ2ZXIgfSBmcm9tICd2dWUtcmVzaXplJwppbXBvcnQgeyBPYnNlcnZlVmlzaWJpbGl0eSB9IGZyb20gJ3Z1ZS1vYnNlcnZlLXZpc2liaWxpdHknCmltcG9ydCB7IGdldFNjcm9sbFBhcmVudCB9IGZyb20gJy4uL2Fzc2V0cy9TY3JvbGxQYXJlbnQnCmltcG9ydCBjb25maWcgZnJvbSAnLi4vY29uZmlnJwppbXBvcnQgeyBwcm9wcywgc2ltcGxlQXJyYXkgfSBmcm9tICcuL2NvbW1vbicKaW1wb3J0IHsgc3VwcG9ydHNQYXNzaXZlIH0gZnJvbSAnLi4vYXNzZXRzL3V0aWwnCgpsZXQgdWlkID0gMAoKZXhwb3J0IGRlZmF1bHQgewogIG5hbWU6ICdSZWN5Y2xlU2Nyb2xsZXInLAoKICBjb21wb25lbnRzOiB7CiAgICBSZXNpemVPYnNlcnZlciwKICB9LAoKICBkaXJlY3RpdmVzOiB7CiAgICBPYnNlcnZlVmlzaWJpbGl0eSwKICB9LAoKICBwcm9wczogewogICAgLi4ucHJvcHMsCgogICAgaXRlbVNpemU6IHsKICAgICAgdHlwZTogTnVtYmVyLAogICAgICBkZWZhdWx0OiBudWxsLAogICAgfSwKCiAgICBncmlkSXRlbXM6IHsKICAgICAgdHlwZTogTnVtYmVyLAogICAgICBkZWZhdWx0OiB1bmRlZmluZWQsCiAgICB9LAoKICAgIGl0ZW1TZWNvbmRhcnlTaXplOiB7CiAgICAgIHR5cGU6IE51bWJlciwKICAgICAgZGVmYXVsdDogdW5kZWZpbmVkLAogICAgfSwKCiAgICBtaW5JdGVtU2l6ZTogewogICAgICB0eXBlOiBbTnVtYmVyLCBTdHJpbmddLAogICAgICBkZWZhdWx0OiBudWxsLAogICAgfSwKCiAgICBzaXplRmllbGQ6IHsKICAgICAgdHlwZTogU3RyaW5nLAogICAgICBkZWZhdWx0OiAnc2l6ZScsCiAgICB9LAoKICAgIHR5cGVGaWVsZDogewogICAgICB0eXBlOiBTdHJpbmcsCiAgICAgIGRlZmF1bHQ6ICd0eXBlJywKICAgIH0sCgogICAgYnVmZmVyOiB7CiAgICAgIHR5cGU6IE51bWJlciwKICAgICAgZGVmYXVsdDogMjAwLAogICAgfSwKCiAgICBwYWdlTW9kZTogewogICAgICB0eXBlOiBCb29sZWFuLAogICAgICBkZWZhdWx0OiBmYWxzZSwKICAgIH0sCgogICAgcHJlcmVuZGVyOiB7CiAgICAgIHR5cGU6IE51bWJlciwKICAgICAgZGVmYXVsdDogMCwKICAgIH0sCgogICAgZW1pdFVwZGF0ZTogewogICAgICB0eXBlOiBCb29sZWFuLAogICAgICBkZWZhdWx0OiBmYWxzZSwKICAgIH0sCgogICAgdXBkYXRlSW50ZXJ2YWw6IHsKICAgICAgdHlwZTogTnVtYmVyLAogICAgICBkZWZhdWx0OiAwLAogICAgfSwKCiAgICBza2lwSG92ZXI6IHsKICAgICAgdHlwZTogQm9vbGVhbiwKICAgICAgZGVmYXVsdDogZmFsc2UsCiAgICB9LAoKICAgIGxpc3RUYWc6IHsKICAgICAgdHlwZTogU3RyaW5nLAogICAgICBkZWZhdWx0OiAnZGl2JywKICAgIH0sCgogICAgaXRlbVRhZzogewogICAgICB0eXBlOiBTdHJpbmcsCiAgICAgIGRlZmF1bHQ6ICdkaXYnLAogICAgfSwKCiAgICBsaXN0Q2xhc3M6IHsKICAgICAgdHlwZTogW1N0cmluZywgT2JqZWN0LCBBcnJheV0sCiAgICAgIGRlZmF1bHQ6ICcnLAogICAgfSwKCiAgICBpdGVtQ2xhc3M6IHsKICAgICAgdHlwZTogW1N0cmluZywgT2JqZWN0LCBBcnJheV0sCiAgICAgIGRlZmF1bHQ6ICcnLAogICAgfSwKICB9LAoKICBlbWl0czogWwogICAgJ3Jlc2l6ZScsCiAgICAndmlzaWJsZScsCiAgICAnaGlkZGVuJywKICAgICd1cGRhdGUnLAogICAgJ3Njcm9sbC1zdGFydCcsCiAgICAnc2Nyb2xsLWVuZCcsCiAgXSwKCiAgZGF0YSAoKSB7CiAgICByZXR1cm4gewogICAgICBwb29sOiBbXSwKICAgICAgdG90YWxTaXplOiAwLAogICAgICByZWFkeTogZmFsc2UsCiAgICAgIGhvdmVyS2V5OiBudWxsLAogICAgfQogIH0sCgogIGNvbXB1dGVkOiB7CiAgICBzaXplcyAoKSB7CiAgICAgIGlmICh0aGlzLml0ZW1TaXplID09PSBudWxsKSB7CiAgICAgICAgY29uc3Qgc2l6ZXMgPSB7CiAgICAgICAgICAnLTEnOiB7IGFjY3VtdWxhdG9yOiAwIH0sCiAgICAgICAgfQogICAgICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5pdGVtcwogICAgICAgIGNvbnN0IGZpZWxkID0gdGhpcy5zaXplRmllbGQKICAgICAgICBjb25zdCBtaW5JdGVtU2l6ZSA9IHRoaXMubWluSXRlbVNpemUKICAgICAgICBsZXQgY29tcHV0ZWRNaW5TaXplID0gMTAwMDAKICAgICAgICBsZXQgYWNjdW11bGF0b3IgPSAwCiAgICAgICAgbGV0IGN1cnJlbnQKICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IGl0ZW1zLmxlbmd0aDsgaSA8IGw7IGkrKykgewogICAgICAgICAgY3VycmVudCA9IGl0ZW1zW2ldW2ZpZWxkXSB8fCBtaW5JdGVtU2l6ZQogICAgICAgICAgaWYgKGN1cnJlbnQgPCBjb21wdXRlZE1pblNpemUpIHsKICAgICAgICAgICAgY29tcHV0ZWRNaW5TaXplID0gY3VycmVudAogICAgICAgICAgfQogICAgICAgICAgYWNjdW11bGF0b3IgKz0gY3VycmVudAogICAgICAgICAgc2l6ZXNbaV0gPSB7IGFjY3VtdWxhdG9yLCBzaXplOiBjdXJyZW50IH0KICAgICAgICB9CiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lCiAgICAgICAgdGhpcy4kX2NvbXB1dGVkTWluSXRlbVNpemUgPSBjb21wdXRlZE1pblNpemUKICAgICAgICByZXR1cm4gc2l6ZXMKICAgICAgfQogICAgICByZXR1cm4gW10KICAgIH0sCgogICAgc2ltcGxlQXJyYXksCgogICAgaXRlbUluZGV4QnlLZXkgKCkgewogICAgICBjb25zdCB7IGtleUZpZWxkLCBpdGVtcyB9ID0gdGhpcwogICAgICBjb25zdCByZXN1bHQgPSB7fQogICAgICBmb3IgKGxldCBpID0gMCwgbCA9IGl0ZW1zLmxlbmd0aDsgaSA8IGw7IGkrKykgewogICAgICAgIHJlc3VsdFtpdGVtc1tpXVtrZXlGaWVsZF1dID0gaQogICAgICB9CiAgICAgIHJldHVybiByZXN1bHQKICAgIH0sCiAgfSwKCiAgd2F0Y2g6IHsKICAgIGl0ZW1zICgpIHsKICAgICAgdGhpcy51cGRhdGVWaXNpYmxlSXRlbXModHJ1ZSkKICAgIH0sCgogICAgcGFnZU1vZGUgKCkgewogICAgICB0aGlzLmFwcGx5UGFnZU1vZGUoKQogICAgICB0aGlzLnVwZGF0ZVZpc2libGVJdGVtcyhmYWxzZSkKICAgIH0sCgogICAgc2l6ZXM6IHsKICAgICAgaGFuZGxlciAoKSB7CiAgICAgICAgdGhpcy51cGRhdGVWaXNpYmxlSXRlbXMoZmFsc2UpCiAgICAgIH0sCiAgICAgIGRlZXA6IHRydWUsCiAgICB9LAoKICAgIGdyaWRJdGVtcyAoKSB7CiAgICAgIHRoaXMudXBkYXRlVmlzaWJsZUl0ZW1zKHRydWUpCiAgICB9LAoKICAgIGl0ZW1TZWNvbmRhcnlTaXplICgpIHsKICAgICAgdGhpcy51cGRhdGVWaXNpYmxlSXRlbXModHJ1ZSkKICAgIH0sCiAgfSwKCiAgY3JlYXRlZCAoKSB7CiAgICB0aGlzLiRfc3RhcnRJbmRleCA9IDAKICAgIHRoaXMuJF9lbmRJbmRleCA9IDAKICAgIHRoaXMuJF92aWV3cyA9IG5ldyBNYXAoKQogICAgdGhpcy4kX3VudXNlZFZpZXdzID0gbmV3IE1hcCgpCiAgICB0aGlzLiRfc2Nyb2xsRGlydHkgPSBmYWxzZQogICAgdGhpcy4kX2xhc3RVcGRhdGVTY3JvbGxQb3NpdGlvbiA9IDAKCiAgICAvLyBJbiBTU1IgbW9kZSwgd2UgYWxzbyBwcmVyZW5kZXIgdGhlIHNhbWUgbnVtYmVyIG9mIGl0ZW0gZm9yIHRoZSBmaXJzdCByZW5kZXIKICAgIC8vIHRvIGF2b2lyIG1pc21hdGNoIGJldHdlZW4gc2VydmVyIGFuZCBjbGllbnQgdGVtcGxhdGVzCiAgICBpZiAodGhpcy5wcmVyZW5kZXIpIHsKICAgICAgdGhpcy4kX3ByZXJlbmRlciA9IHRydWUKICAgICAgdGhpcy51cGRhdGVWaXNpYmxlSXRlbXMoZmFsc2UpCiAgICB9CgogICAgaWYgKHRoaXMuZ3JpZEl0ZW1zICYmICF0aGlzLml0ZW1TaXplKSB7CiAgICAgIGNvbnNvbGUuZXJyb3IoJ1t2dWUtcmVjeWNsZS1zY3JvbGxlcl0gWW91IG11c3QgcHJvdmlkZSBhbiBpdGVtU2l6ZSB3aGVuIHVzaW5nIGdyaWRJdGVtcycpCiAgICB9CiAgfSwKCiAgbW91bnRlZCAoKSB7CiAgICB0aGlzLmFwcGx5UGFnZU1vZGUoKQogICAgdGhpcy4kbmV4dFRpY2soKCkgPT4gewogICAgICAvLyBJbiBTU1IgbW9kZSwgcmVuZGVyIHRoZSByZWFsIG51bWJlciBvZiB2aXNpYmxlIGl0ZW1zCiAgICAgIHRoaXMuJF9wcmVyZW5kZXIgPSBmYWxzZQogICAgICB0aGlzLnVwZGF0ZVZpc2libGVJdGVtcyh0cnVlKQogICAgICB0aGlzLnJlYWR5ID0gdHJ1ZQogICAgfSkKICB9LAoKICBhY3RpdmF0ZWQgKCkgewogICAgY29uc3QgbGFzdFBvc2l0aW9uID0gdGhpcy4kX2xhc3RVcGRhdGVTY3JvbGxQb3NpdGlvbgogICAgaWYgKHR5cGVvZiBsYXN0UG9zaXRpb24gPT09ICdudW1iZXInKSB7CiAgICAgIHRoaXMuJG5leHRUaWNrKCgpID0+IHsKICAgICAgICB0aGlzLnNjcm9sbFRvUG9zaXRpb24obGFzdFBvc2l0aW9uKQogICAgICB9KQogICAgfQogIH0sCgogIGJlZm9yZVVubW91bnQgKCkgewogICAgdGhpcy5yZW1vdmVMaXN0ZW5lcnMoKQogIH0sCgogIG1ldGhvZHM6IHsKICAgIGFkZFZpZXcgKHBvb2wsIGluZGV4LCBpdGVtLCBrZXksIHR5cGUpIHsKICAgICAgY29uc3QgbnIgPSBtYXJrUmF3KHsKICAgICAgICBpZDogdWlkKyssCiAgICAgICAgaW5kZXgsCiAgICAgICAgdXNlZDogdHJ1ZSwKICAgICAgICBrZXksCiAgICAgICAgdHlwZSwKICAgICAgfSkKICAgICAgY29uc3QgdmlldyA9IHNoYWxsb3dSZWFjdGl2ZSh7CiAgICAgICAgaXRlbSwKICAgICAgICBwb3NpdGlvbjogMCwKICAgICAgICBuciwKICAgICAgfSkKICAgICAgcG9vbC5wdXNoKHZpZXcpCiAgICAgIHJldHVybiB2aWV3CiAgICB9LAoKICAgIHVudXNlVmlldyAodmlldywgZmFrZSA9IGZhbHNlKSB7CiAgICAgIGNvbnN0IHVudXNlZFZpZXdzID0gdGhpcy4kX3VudXNlZFZpZXdzCiAgICAgIGNvbnN0IHR5cGUgPSB2aWV3Lm5yLnR5cGUKICAgICAgbGV0IHVudXNlZFBvb2wgPSB1bnVzZWRWaWV3cy5nZXQodHlwZSkKICAgICAgaWYgKCF1bnVzZWRQb29sKSB7CiAgICAgICAgdW51c2VkUG9vbCA9IFtdCiAgICAgICAgdW51c2VkVmlld3Muc2V0KHR5cGUsIHVudXNlZFBvb2wpCiAgICAgIH0KICAgICAgdW51c2VkUG9vbC5wdXNoKHZpZXcpCiAgICAgIGlmICghZmFrZSkgewogICAgICAgIHZpZXcubnIudXNlZCA9IGZhbHNlCiAgICAgICAgdmlldy5wb3NpdGlvbiA9IC05OTk5CiAgICAgIH0KICAgIH0sCgogICAgaGFuZGxlUmVzaXplICgpIHsKICAgICAgdGhpcy4kZW1pdCgncmVzaXplJykKICAgICAgaWYgKHRoaXMucmVhZHkpIHRoaXMudXBkYXRlVmlzaWJsZUl0ZW1zKGZhbHNlKQogICAgfSwKCiAgICBoYW5kbGVTY3JvbGwgKGV2ZW50KSB7CiAgICAgIGlmICghdGhpcy4kX3Njcm9sbERpcnR5KSB7CiAgICAgICAgdGhpcy4kX3Njcm9sbERpcnR5ID0gdHJ1ZQogICAgICAgIGlmICh0aGlzLiRfdXBkYXRlVGltZW91dCkgcmV0dXJuCgogICAgICAgIGNvbnN0IHJlcXVlc3RVcGRhdGUgPSAoKSA9PiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gewogICAgICAgICAgdGhpcy4kX3Njcm9sbERpcnR5ID0gZmFsc2UKICAgICAgICAgIGNvbnN0IHsgY29udGludW91cyB9ID0gdGhpcy51cGRhdGVWaXNpYmxlSXRlbXMoZmFsc2UsIHRydWUpCgogICAgICAgICAgLy8gSXQgc2VlbXMgc29tZXRpbWVzIGNocm9tZSBkb2Vzbid0IGZpcmUgc2Nyb2xsIGV2ZW50IDovCiAgICAgICAgICAvLyBXaGVuIG5vbiBjb250aW5vdXMgc2Nyb2xsaW5nIGlzIGVuZGluZywgd2UgZm9yY2UgYSByZWZyZXNoCiAgICAgICAgICBpZiAoIWNvbnRpbnVvdXMpIHsKICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuJF9yZWZyZXNoVGltb3V0KQogICAgICAgICAgICB0aGlzLiRfcmVmcmVzaFRpbW91dCA9IHNldFRpbWVvdXQodGhpcy5oYW5kbGVTY3JvbGwsIHRoaXMudXBkYXRlSW50ZXJ2YWwgKyAxMDApCiAgICAgICAgICB9CiAgICAgICAgfSkKCiAgICAgICAgcmVxdWVzdFVwZGF0ZSgpCgogICAgICAgIC8vIFNjaGVkdWxlIHRoZSBuZXh0IHVwZGF0ZSB3aXRoIHRocm90dGxpbmcKICAgICAgICBpZiAodGhpcy51cGRhdGVJbnRlcnZhbCkgewogICAgICAgICAgdGhpcy4kX3VwZGF0ZVRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHsKICAgICAgICAgICAgdGhpcy4kX3VwZGF0ZVRpbWVvdXQgPSAwCiAgICAgICAgICAgIGlmICh0aGlzLiRfc2Nyb2xsRGlydHkpIHJlcXVlc3RVcGRhdGUoKQogICAgICAgICAgfSwgdGhpcy51cGRhdGVJbnRlcnZhbCkKICAgICAgICB9CiAgICAgIH0KICAgIH0sCgogICAgaGFuZGxlVmlzaWJpbGl0eUNoYW5nZSAoaXNWaXNpYmxlLCBlbnRyeSkgewogICAgICBpZiAodGhpcy5yZWFkeSkgewogICAgICAgIGlmIChpc1Zpc2libGUgfHwgZW50cnkuYm91bmRpbmdDbGllbnRSZWN0LndpZHRoICE9PSAwIHx8IGVudHJ5LmJvdW5kaW5nQ2xpZW50UmVjdC5oZWlnaHQgIT09IDApIHsKICAgICAgICAgIHRoaXMuJGVtaXQoJ3Zpc2libGUnKQogICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHsKICAgICAgICAgICAgdGhpcy51cGRhdGVWaXNpYmxlSXRlbXMoZmFsc2UpCiAgICAgICAgICB9KQogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICB0aGlzLiRlbWl0KCdoaWRkZW4nKQogICAgICAgIH0KICAgICAgfQogICAgfSwKCiAgICB1cGRhdGVWaXNpYmxlSXRlbXMgKGNoZWNrSXRlbSwgY2hlY2tQb3NpdGlvbkRpZmYgPSBmYWxzZSkgewogICAgICBjb25zdCBpdGVtU2l6ZSA9IHRoaXMuaXRlbVNpemUKICAgICAgY29uc3QgZ3JpZEl0ZW1zID0gdGhpcy5ncmlkSXRlbXMgfHwgMQogICAgICBjb25zdCBpdGVtU2Vjb25kYXJ5U2l6ZSA9IHRoaXMuaXRlbVNlY29uZGFyeVNpemUgfHwgaXRlbVNpemUKICAgICAgY29uc3QgbWluSXRlbVNpemUgPSB0aGlzLiRfY29tcHV0ZWRNaW5JdGVtU2l6ZQogICAgICBjb25zdCB0eXBlRmllbGQgPSB0aGlzLnR5cGVGaWVsZAogICAgICBjb25zdCBrZXlGaWVsZCA9IHRoaXMuc2ltcGxlQXJyYXkgPyBudWxsIDogdGhpcy5rZXlGaWVsZAogICAgICBjb25zdCBpdGVtcyA9IHRoaXMuaXRlbXMKICAgICAgY29uc3QgY291bnQgPSBpdGVtcy5sZW5ndGgKICAgICAgY29uc3Qgc2l6ZXMgPSB0aGlzLnNpemVzCiAgICAgIGNvbnN0IHZpZXdzID0gdGhpcy4kX3ZpZXdzCiAgICAgIGNvbnN0IHVudXNlZFZpZXdzID0gdGhpcy4kX3VudXNlZFZpZXdzCiAgICAgIGNvbnN0IHBvb2wgPSB0aGlzLnBvb2wKICAgICAgY29uc3QgaXRlbUluZGV4QnlLZXkgPSB0aGlzLml0ZW1JbmRleEJ5S2V5CiAgICAgIGxldCBzdGFydEluZGV4LCBlbmRJbmRleAogICAgICBsZXQgdG90YWxTaXplCiAgICAgIGxldCB2aXNpYmxlU3RhcnRJbmRleCwgdmlzaWJsZUVuZEluZGV4CgogICAgICBpZiAoIWNvdW50KSB7CiAgICAgICAgc3RhcnRJbmRleCA9IGVuZEluZGV4ID0gdmlzaWJsZVN0YXJ0SW5kZXggPSB2aXNpYmxlRW5kSW5kZXggPSB0b3RhbFNpemUgPSAwCiAgICAgIH0gZWxzZSBpZiAodGhpcy4kX3ByZXJlbmRlcikgewogICAgICAgIHN0YXJ0SW5kZXggPSB2aXNpYmxlU3RhcnRJbmRleCA9IDAKICAgICAgICBlbmRJbmRleCA9IHZpc2libGVFbmRJbmRleCA9IE1hdGgubWluKHRoaXMucHJlcmVuZGVyLCBpdGVtcy5sZW5ndGgpCiAgICAgICAgdG90YWxTaXplID0gbnVsbAogICAgICB9IGVsc2UgewogICAgICAgIGNvbnN0IHNjcm9sbCA9IHRoaXMuZ2V0U2Nyb2xsKCkKCiAgICAgICAgLy8gU2tpcCB1cGRhdGUgaWYgdXNlIGhhc24ndCBzY3JvbGxlZCBlbm91Z2gKICAgICAgICBpZiAoY2hlY2tQb3NpdGlvbkRpZmYpIHsKICAgICAgICAgIGxldCBwb3NpdGlvbkRpZmYgPSBzY3JvbGwuc3RhcnQgLSB0aGlzLiRfbGFzdFVwZGF0ZVNjcm9sbFBvc2l0aW9uCiAgICAgICAgICBpZiAocG9zaXRpb25EaWZmIDwgMCkgcG9zaXRpb25EaWZmID0gLXBvc2l0aW9uRGlmZgogICAgICAgICAgaWYgKChpdGVtU2l6ZSA9PT0gbnVsbCAmJiBwb3NpdGlvbkRpZmYgPCBtaW5JdGVtU2l6ZSkgfHwgcG9zaXRpb25EaWZmIDwgaXRlbVNpemUpIHsKICAgICAgICAgICAgcmV0dXJuIHsKICAgICAgICAgICAgICBjb250aW51b3VzOiB0cnVlLAogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHRoaXMuJF9sYXN0VXBkYXRlU2Nyb2xsUG9zaXRpb24gPSBzY3JvbGwuc3RhcnQKCiAgICAgICAgY29uc3QgYnVmZmVyID0gdGhpcy5idWZmZXIKICAgICAgICBzY3JvbGwuc3RhcnQgLT0gYnVmZmVyCiAgICAgICAgc2Nyb2xsLmVuZCArPSBidWZmZXIKCiAgICAgICAgLy8gYWNjb3VudCBmb3IgbGVhZGluZyBzbG90CiAgICAgICAgbGV0IGJlZm9yZVNpemUgPSAwCiAgICAgICAgaWYgKHRoaXMuJHJlZnMuYmVmb3JlKSB7CiAgICAgICAgICBiZWZvcmVTaXplID0gdGhpcy4kcmVmcy5iZWZvcmUuc2Nyb2xsSGVpZ2h0CiAgICAgICAgICBzY3JvbGwuc3RhcnQgLT0gYmVmb3JlU2l6ZQogICAgICAgIH0KCiAgICAgICAgLy8gYWNjb3VudCBmb3IgdHJhaWxpbmcgc2xvdAogICAgICAgIGlmICh0aGlzLiRyZWZzLmFmdGVyKSB7CiAgICAgICAgICBjb25zdCBhZnRlclNpemUgPSB0aGlzLiRyZWZzLmFmdGVyLnNjcm9sbEhlaWdodAogICAgICAgICAgc2Nyb2xsLmVuZCArPSBhZnRlclNpemUKICAgICAgICB9CgogICAgICAgIC8vIFZhcmlhYmxlIHNpemUgbW9kZQogICAgICAgIGlmIChpdGVtU2l6ZSA9PT0gbnVsbCkgewogICAgICAgICAgbGV0IGgKICAgICAgICAgIGxldCBhID0gMAogICAgICAgICAgbGV0IGIgPSBjb3VudCAtIDEKICAgICAgICAgIGxldCBpID0gfn4oY291bnQgLyAyKQogICAgICAgICAgbGV0IG9sZEkKCiAgICAgICAgICAvLyBTZWFyY2hpbmcgZm9yIHN0YXJ0SW5kZXgKICAgICAgICAgIGRvIHsKICAgICAgICAgICAgb2xkSSA9IGkKICAgICAgICAgICAgaCA9IHNpemVzW2ldLmFjY3VtdWxhdG9yCiAgICAgICAgICAgIGlmIChoIDwgc2Nyb2xsLnN0YXJ0KSB7CiAgICAgICAgICAgICAgYSA9IGkKICAgICAgICAgICAgfSBlbHNlIGlmIChpIDwgY291bnQgLSAxICYmIHNpemVzW2kgKyAxXS5hY2N1bXVsYXRvciA+IHNjcm9sbC5zdGFydCkgewogICAgICAgICAgICAgIGIgPSBpCiAgICAgICAgICAgIH0KICAgICAgICAgICAgaSA9IH5+KChhICsgYikgLyAyKQogICAgICAgICAgfSB3aGlsZSAoaSAhPT0gb2xkSSkKICAgICAgICAgIGkgPCAwICYmIChpID0gMCkKICAgICAgICAgIHN0YXJ0SW5kZXggPSBpCgogICAgICAgICAgLy8gRm9yIGNvbnRhaW5lciBzdHlsZQogICAgICAgICAgdG90YWxTaXplID0gc2l6ZXNbY291bnQgLSAxXS5hY2N1bXVsYXRvcgoKICAgICAgICAgIC8vIFNlYXJjaGluZyBmb3IgZW5kSW5kZXgKICAgICAgICAgIGZvciAoZW5kSW5kZXggPSBpOyBlbmRJbmRleCA8IGNvdW50ICYmIHNpemVzW2VuZEluZGV4XS5hY2N1bXVsYXRvciA8IHNjcm9sbC5lbmQ7IGVuZEluZGV4KyspOwogICAgICAgICAgaWYgKGVuZEluZGV4ID09PSAtMSkgewogICAgICAgICAgICBlbmRJbmRleCA9IGl0ZW1zLmxlbmd0aCAtIDEKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIGVuZEluZGV4KysKICAgICAgICAgICAgLy8gQm91bmRzCiAgICAgICAgICAgIGVuZEluZGV4ID4gY291bnQgJiYgKGVuZEluZGV4ID0gY291bnQpCiAgICAgICAgICB9CgogICAgICAgICAgLy8gc2VhcmNoIHZpc2libGUgc3RhcnRJbmRleAogICAgICAgICAgZm9yICh2aXNpYmxlU3RhcnRJbmRleCA9IHN0YXJ0SW5kZXg7IHZpc2libGVTdGFydEluZGV4IDwgY291bnQgJiYgKGJlZm9yZVNpemUgKyBzaXplc1t2aXNpYmxlU3RhcnRJbmRleF0uYWNjdW11bGF0b3IpIDwgc2Nyb2xsLnN0YXJ0OyB2aXNpYmxlU3RhcnRJbmRleCsrKTsKCiAgICAgICAgICAvLyBzZWFyY2ggdmlzaWJsZSBlbmRJbmRleAogICAgICAgICAgZm9yICh2aXNpYmxlRW5kSW5kZXggPSB2aXNpYmxlU3RhcnRJbmRleDsgdmlzaWJsZUVuZEluZGV4IDwgY291bnQgJiYgKGJlZm9yZVNpemUgKyBzaXplc1t2aXNpYmxlRW5kSW5kZXhdLmFjY3VtdWxhdG9yKSA8IHNjcm9sbC5lbmQ7IHZpc2libGVFbmRJbmRleCsrKTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgLy8gRml4ZWQgc2l6ZSBtb2RlCiAgICAgICAgICBzdGFydEluZGV4ID0gfn4oc2Nyb2xsLnN0YXJ0IC8gaXRlbVNpemUgKiBncmlkSXRlbXMpCiAgICAgICAgICBjb25zdCByZW1haW5lciA9IHN0YXJ0SW5kZXggJSBncmlkSXRlbXMKICAgICAgICAgIHN0YXJ0SW5kZXggLT0gcmVtYWluZXIKICAgICAgICAgIGVuZEluZGV4ID0gTWF0aC5jZWlsKHNjcm9sbC5lbmQgLyBpdGVtU2l6ZSAqIGdyaWRJdGVtcykKICAgICAgICAgIHZpc2libGVTdGFydEluZGV4ID0gTWF0aC5tYXgoMCwgTWF0aC5mbG9vcigoc2Nyb2xsLnN0YXJ0IC0gYmVmb3JlU2l6ZSkgLyBpdGVtU2l6ZSAqIGdyaWRJdGVtcykpCiAgICAgICAgICB2aXNpYmxlRW5kSW5kZXggPSBNYXRoLmZsb29yKChzY3JvbGwuZW5kIC0gYmVmb3JlU2l6ZSkgLyBpdGVtU2l6ZSAqIGdyaWRJdGVtcykKCiAgICAgICAgICAvLyBCb3VuZHMKICAgICAgICAgIHN0YXJ0SW5kZXggPCAwICYmIChzdGFydEluZGV4ID0gMCkKICAgICAgICAgIGVuZEluZGV4ID4gY291bnQgJiYgKGVuZEluZGV4ID0gY291bnQpCiAgICAgICAgICB2aXNpYmxlU3RhcnRJbmRleCA8IDAgJiYgKHZpc2libGVTdGFydEluZGV4ID0gMCkKICAgICAgICAgIHZpc2libGVFbmRJbmRleCA+IGNvdW50ICYmICh2aXNpYmxlRW5kSW5kZXggPSBjb3VudCkKCiAgICAgICAgICB0b3RhbFNpemUgPSBNYXRoLmNlaWwoY291bnQgLyBncmlkSXRlbXMpICogaXRlbVNpemUKICAgICAgICB9CiAgICAgIH0KCiAgICAgIGlmIChlbmRJbmRleCAtIHN0YXJ0SW5kZXggPiBjb25maWcuaXRlbXNMaW1pdCkgewogICAgICAgIHRoaXMuaXRlbXNMaW1pdEVycm9yKCkKICAgICAgfQoKICAgICAgdGhpcy50b3RhbFNpemUgPSB0b3RhbFNpemUKCiAgICAgIGxldCB2aWV3CgogICAgICBjb25zdCBjb250aW51b3VzID0gc3RhcnRJbmRleCA8PSB0aGlzLiRfZW5kSW5kZXggJiYgZW5kSW5kZXggPj0gdGhpcy4kX3N0YXJ0SW5kZXgKCiAgICAgIC8vIFVudXNlIHZpZXdzIHRoYXQgYXJlIG5vIGxvbmdlciB2aXNpYmxlCiAgICAgIGlmIChjb250aW51b3VzKSB7CiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBwb29sLmxlbmd0aDsgaSA8IGw7IGkrKykgewogICAgICAgICAgdmlldyA9IHBvb2xbaV0KICAgICAgICAgIGlmICh2aWV3Lm5yLnVzZWQpIHsKICAgICAgICAgICAgLy8gVXBkYXRlIHZpZXcgaXRlbSBpbmRleAogICAgICAgICAgICBpZiAoY2hlY2tJdGVtKSB7CiAgICAgICAgICAgICAgdmlldy5uci5pbmRleCA9IGl0ZW1JbmRleEJ5S2V5W3ZpZXcuaXRlbVtrZXlGaWVsZF1dCiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIC8vIENoZWNrIGlmIGluZGV4IGlzIHN0aWxsIGluIHZpc2libGUgcmFuZ2UKICAgICAgICAgICAgaWYgKAogICAgICAgICAgICAgIHZpZXcubnIuaW5kZXggPT0gbnVsbCB8fAogICAgICAgICAgICAgIHZpZXcubnIuaW5kZXggPCBzdGFydEluZGV4IHx8CiAgICAgICAgICAgICAgdmlldy5uci5pbmRleCA+PSBlbmRJbmRleAogICAgICAgICAgICApIHsKICAgICAgICAgICAgICB0aGlzLnVudXNlVmlldyh2aWV3KQogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CgogICAgICBjb25zdCB1bnVzZWRJbmRleCA9IGNvbnRpbnVvdXMgPyBudWxsIDogbmV3IE1hcCgpCgogICAgICBsZXQgaXRlbSwgdHlwZQogICAgICBsZXQgdgogICAgICBmb3IgKGxldCBpID0gc3RhcnRJbmRleDsgaSA8IGVuZEluZGV4OyBpKyspIHsKICAgICAgICBpdGVtID0gaXRlbXNbaV0KICAgICAgICBjb25zdCBrZXkgPSBrZXlGaWVsZCA/IGl0ZW1ba2V5RmllbGRdIDogaXRlbQogICAgICAgIGlmIChrZXkgPT0gbnVsbCkgewogICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBLZXkgaXMgJHtrZXl9IG9uIGl0ZW0gKGtleUZpZWxkIGlzICcke2tleUZpZWxkfScpYCkKICAgICAgICB9CiAgICAgICAgdmlldyA9IHZpZXdzLmdldChrZXkpCgogICAgICAgIGlmICghaXRlbVNpemUgJiYgIXNpemVzW2ldLnNpemUpIHsKICAgICAgICAgIGlmICh2aWV3KSB0aGlzLnVudXNlVmlldyh2aWV3KQogICAgICAgICAgY29udGludWUKICAgICAgICB9CgogICAgICAgIHR5cGUgPSBpdGVtW3R5cGVGaWVsZF0KCiAgICAgICAgbGV0IHVudXNlZFBvb2wgPSB1bnVzZWRWaWV3cy5nZXQodHlwZSkKICAgICAgICBsZXQgbmV3bHlVc2VkVmlldyA9IGZhbHNlCgogICAgICAgIC8vIE5vIHZpZXcgYXNzaWduZWQgdG8gaXRlbQogICAgICAgIGlmICghdmlldykgewogICAgICAgICAgaWYgKGNvbnRpbnVvdXMpIHsKICAgICAgICAgICAgLy8gUmV1c2UgZXhpc3RpbmcgdmlldwogICAgICAgICAgICBpZiAodW51c2VkUG9vbCAmJiB1bnVzZWRQb29sLmxlbmd0aCkgewogICAgICAgICAgICAgIHZpZXcgPSB1bnVzZWRQb29sLnBvcCgpCiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgdmlldyA9IHRoaXMuYWRkVmlldyhwb29sLCBpLCBpdGVtLCBrZXksIHR5cGUpCiAgICAgICAgICAgIH0KICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIC8vIFVzZSBleGlzdGluZyB2aWV3CiAgICAgICAgICAgIC8vIFdlIGRvbid0IGNhcmUgaWYgdGhleSBhcmUgYWxyZWFkeSB1c2VkCiAgICAgICAgICAgIC8vIGJlY2F1c2Ugd2UgYXJlIG5vdCBpbiBjb250aW5vdXMgc2Nyb2xsaW5nCiAgICAgICAgICAgIHYgPSB1bnVzZWRJbmRleC5nZXQodHlwZSkgfHwgMAoKICAgICAgICAgICAgaWYgKCF1bnVzZWRQb29sIHx8IHYgPj0gdW51c2VkUG9vbC5sZW5ndGgpIHsKICAgICAgICAgICAgICB2aWV3ID0gdGhpcy5hZGRWaWV3KHBvb2wsIGksIGl0ZW0sIGtleSwgdHlwZSkKICAgICAgICAgICAgICB0aGlzLnVudXNlVmlldyh2aWV3LCB0cnVlKQogICAgICAgICAgICAgIHVudXNlZFBvb2wgPSB1bnVzZWRWaWV3cy5nZXQodHlwZSkKICAgICAgICAgICAgfQoKICAgICAgICAgICAgdmlldyA9IHVudXNlZFBvb2xbdl0KICAgICAgICAgICAgdW51c2VkSW5kZXguc2V0KHR5cGUsIHYgKyAxKQogICAgICAgICAgfQoKICAgICAgICAgIC8vIEFzc2lnbiB2aWV3IHRvIGl0ZW0KICAgICAgICAgIHZpZXdzLmRlbGV0ZSh2aWV3Lm5yLmtleSkKICAgICAgICAgIHZpZXcubnIudXNlZCA9IHRydWUKICAgICAgICAgIHZpZXcubnIuaW5kZXggPSBpCiAgICAgICAgICB2aWV3Lm5yLmtleSA9IGtleQogICAgICAgICAgdmlldy5uci50eXBlID0gdHlwZQogICAgICAgICAgdmlld3Muc2V0KGtleSwgdmlldykKCiAgICAgICAgICBuZXdseVVzZWRWaWV3ID0gdHJ1ZQogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAvLyBWaWV3IGFscmVhZHkgYXNzaWduZWQgdG8gaXRlbQogICAgICAgICAgaWYgKCF2aWV3Lm5yLnVzZWQpIHsKICAgICAgICAgICAgdmlldy5uci51c2VkID0gdHJ1ZQogICAgICAgICAgICBuZXdseVVzZWRWaWV3ID0gdHJ1ZQogICAgICAgICAgICBpZiAodW51c2VkUG9vbCkgewogICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gdW51c2VkUG9vbC5pbmRleE9mKHZpZXcpCiAgICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkgdW51c2VkUG9vbC5zcGxpY2UoaW5kZXgsIDEpCiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9CgogICAgICAgIC8vIEFsd2F5cyBzZXQgaXRlbSBpbiBjYXNlIGl0J3MgYSBuZXcgb2JqZWN0IHdpdGggdGhlIHNhbWUga2V5CiAgICAgICAgdmlldy5pdGVtID0gaXRlbQoKICAgICAgICBpZiAobmV3bHlVc2VkVmlldykgewogICAgICAgICAgaWYgKGkgPT09IGl0ZW1zLmxlbmd0aCAtIDEpIHRoaXMuJGVtaXQoJ3Njcm9sbC1lbmQnKQogICAgICAgICAgaWYgKGkgPT09IDApIHRoaXMuJGVtaXQoJ3Njcm9sbC1zdGFydCcpCiAgICAgICAgfQoKICAgICAgICAvLyBVcGRhdGUgcG9zaXRpb24KICAgICAgICBpZiAoaXRlbVNpemUgPT09IG51bGwpIHsKICAgICAgICAgIHZpZXcucG9zaXRpb24gPSBzaXplc1tpIC0gMV0uYWNjdW11bGF0b3IKICAgICAgICAgIHZpZXcub2Zmc2V0ID0gMAogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICB2aWV3LnBvc2l0aW9uID0gTWF0aC5mbG9vcihpIC8gZ3JpZEl0ZW1zKSAqIGl0ZW1TaXplCiAgICAgICAgICB2aWV3Lm9mZnNldCA9IChpICUgZ3JpZEl0ZW1zKSAqIGl0ZW1TZWNvbmRhcnlTaXplCiAgICAgICAgfQogICAgICB9CgogICAgICB0aGlzLiRfc3RhcnRJbmRleCA9IHN0YXJ0SW5kZXgKICAgICAgdGhpcy4kX2VuZEluZGV4ID0gZW5kSW5kZXgKCiAgICAgIGlmICh0aGlzLmVtaXRVcGRhdGUpIHRoaXMuJGVtaXQoJ3VwZGF0ZScsIHN0YXJ0SW5kZXgsIGVuZEluZGV4LCB2aXNpYmxlU3RhcnRJbmRleCwgdmlzaWJsZUVuZEluZGV4KQoKICAgICAgLy8gQWZ0ZXIgdGhlIHVzZXIgaGFzIGZpbmlzaGVkIHNjcm9sbGluZwogICAgICAvLyBTb3J0IHZpZXdzIHNvIHRleHQgc2VsZWN0aW9uIGlzIGNvcnJlY3QKICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuJF9zb3J0VGltZXIpCiAgICAgIHRoaXMuJF9zb3J0VGltZXIgPSBzZXRUaW1lb3V0KHRoaXMuc29ydFZpZXdzLCB0aGlzLnVwZGF0ZUludGVydmFsICsgMzAwKQoKICAgICAgcmV0dXJuIHsKICAgICAgICBjb250aW51b3VzLAogICAgICB9CiAgICB9LAoKICAgIGdldExpc3RlbmVyVGFyZ2V0ICgpIHsKICAgICAgbGV0IHRhcmdldCA9IGdldFNjcm9sbFBhcmVudCh0aGlzLiRlbCkKICAgICAgLy8gRml4IGdsb2JhbCBzY3JvbGwgdGFyZ2V0IGZvciBDaHJvbWUgYW5kIFNhZmFyaQogICAgICBpZiAod2luZG93LmRvY3VtZW50ICYmICh0YXJnZXQgPT09IHdpbmRvdy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgfHwgdGFyZ2V0ID09PSB3aW5kb3cuZG9jdW1lbnQuYm9keSkpIHsKICAgICAgICB0YXJnZXQgPSB3aW5kb3cKICAgICAgfQogICAgICByZXR1cm4gdGFyZ2V0CiAgICB9LAoKICAgIGdldFNjcm9sbCAoKSB7CiAgICAgIGNvbnN0IHsgJGVsOiBlbCwgZGlyZWN0aW9uIH0gPSB0aGlzCiAgICAgIGNvbnN0IGlzVmVydGljYWwgPSBkaXJlY3Rpb24gPT09ICd2ZXJ0aWNhbCcKICAgICAgbGV0IHNjcm9sbFN0YXRlCgogICAgICBpZiAodGhpcy5wYWdlTW9kZSkgewogICAgICAgIGNvbnN0IGJvdW5kcyA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpCiAgICAgICAgY29uc3QgYm91bmRzU2l6ZSA9IGlzVmVydGljYWwgPyBib3VuZHMuaGVpZ2h0IDogYm91bmRzLndpZHRoCiAgICAgICAgbGV0IHN0YXJ0ID0gLShpc1ZlcnRpY2FsID8gYm91bmRzLnRvcCA6IGJvdW5kcy5sZWZ0KQogICAgICAgIGxldCBzaXplID0gaXNWZXJ0aWNhbCA/IHdpbmRvdy5pbm5lckhlaWdodCA6IHdpbmRvdy5pbm5lcldpZHRoCiAgICAgICAgaWYgKHN0YXJ0IDwgMCkgewogICAgICAgICAgc2l6ZSArPSBzdGFydAogICAgICAgICAgc3RhcnQgPSAwCiAgICAgICAgfQogICAgICAgIGlmIChzdGFydCArIHNpemUgPiBib3VuZHNTaXplKSB7CiAgICAgICAgICBzaXplID0gYm91bmRzU2l6ZSAtIHN0YXJ0CiAgICAgICAgfQogICAgICAgIHNjcm9sbFN0YXRlID0gewogICAgICAgICAgc3RhcnQsCiAgICAgICAgICBlbmQ6IHN0YXJ0ICsgc2l6ZSwKICAgICAgICB9CiAgICAgIH0gZWxzZSBpZiAoaXNWZXJ0aWNhbCkgewogICAgICAgIHNjcm9sbFN0YXRlID0gewogICAgICAgICAgc3RhcnQ6IGVsLnNjcm9sbFRvcCwKICAgICAgICAgIGVuZDogZWwuc2Nyb2xsVG9wICsgZWwuY2xpZW50SGVpZ2h0LAogICAgICAgIH0KICAgICAgfSBlbHNlIHsKICAgICAgICBzY3JvbGxTdGF0ZSA9IHsKICAgICAgICAgIHN0YXJ0OiBlbC5zY3JvbGxMZWZ0LAogICAgICAgICAgZW5kOiBlbC5zY3JvbGxMZWZ0ICsgZWwuY2xpZW50V2lkdGgsCiAgICAgICAgfQogICAgICB9CgogICAgICByZXR1cm4gc2Nyb2xsU3RhdGUKICAgIH0sCgogICAgYXBwbHlQYWdlTW9kZSAoKSB7CiAgICAgIGlmICh0aGlzLnBhZ2VNb2RlKSB7CiAgICAgICAgdGhpcy5hZGRMaXN0ZW5lcnMoKQogICAgICB9IGVsc2UgewogICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXJzKCkKICAgICAgfQogICAgfSwKCiAgICBhZGRMaXN0ZW5lcnMgKCkgewogICAgICB0aGlzLmxpc3RlbmVyVGFyZ2V0ID0gdGhpcy5nZXRMaXN0ZW5lclRhcmdldCgpCiAgICAgIHRoaXMubGlzdGVuZXJUYXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5oYW5kbGVTY3JvbGwsIHN1cHBvcnRzUGFzc2l2ZQogICAgICAgID8gewogICAgICAgICAgICBwYXNzaXZlOiB0cnVlLAogICAgICAgICAgfQogICAgICAgIDogZmFsc2UpCiAgICAgIHRoaXMubGlzdGVuZXJUYXJnZXQuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5oYW5kbGVSZXNpemUpCiAgICB9LAoKICAgIHJlbW92ZUxpc3RlbmVycyAoKSB7CiAgICAgIGlmICghdGhpcy5saXN0ZW5lclRhcmdldCkgewogICAgICAgIHJldHVybgogICAgICB9CgogICAgICB0aGlzLmxpc3RlbmVyVGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuaGFuZGxlU2Nyb2xsKQogICAgICB0aGlzLmxpc3RlbmVyVGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuaGFuZGxlUmVzaXplKQoKICAgICAgdGhpcy5saXN0ZW5lclRhcmdldCA9IG51bGwKICAgIH0sCgogICAgc2Nyb2xsVG9JdGVtIChpbmRleCkgewogICAgICBsZXQgc2Nyb2xsCiAgICAgIGNvbnN0IGdyaWRJdGVtcyA9IHRoaXMuZ3JpZEl0ZW1zIHx8IDEKICAgICAgaWYgKHRoaXMuaXRlbVNpemUgPT09IG51bGwpIHsKICAgICAgICBzY3JvbGwgPSBpbmRleCA+IDAgPyB0aGlzLnNpemVzW2luZGV4IC0gMV0uYWNjdW11bGF0b3IgOiAwCiAgICAgIH0gZWxzZSB7CiAgICAgICAgc2Nyb2xsID0gTWF0aC5mbG9vcihpbmRleCAvIGdyaWRJdGVtcykgKiB0aGlzLml0ZW1TaXplCiAgICAgIH0KICAgICAgdGhpcy5zY3JvbGxUb1Bvc2l0aW9uKHNjcm9sbCkKICAgIH0sCgogICAgc2Nyb2xsVG9Qb3NpdGlvbiAocG9zaXRpb24pIHsKICAgICAgY29uc3QgZGlyZWN0aW9uID0gdGhpcy5kaXJlY3Rpb24gPT09ICd2ZXJ0aWNhbCcKICAgICAgICA/IHsgc2Nyb2xsOiAnc2Nyb2xsVG9wJywgc3RhcnQ6ICd0b3AnIH0KICAgICAgICA6IHsgc2Nyb2xsOiAnc2Nyb2xsTGVmdCcsIHN0YXJ0OiAnbGVmdCcgfQoKICAgICAgbGV0IHZpZXdwb3J0CiAgICAgIGxldCBzY3JvbGxEaXJlY3Rpb24KICAgICAgbGV0IHNjcm9sbERpc3RhbmNlCgogICAgICBpZiAodGhpcy5wYWdlTW9kZSkgewogICAgICAgIGNvbnN0IHZpZXdwb3J0RWwgPSBnZXRTY3JvbGxQYXJlbnQodGhpcy4kZWwpCiAgICAgICAgLy8gSFRNTCBkb2Vzbid0IG92ZXJmbG93IGxpa2Ugb3RoZXIgZWxlbWVudHMKICAgICAgICBjb25zdCBzY3JvbGxUb3AgPSB2aWV3cG9ydEVsLnRhZ05hbWUgPT09ICdIVE1MJyA/IDAgOiB2aWV3cG9ydEVsW2RpcmVjdGlvbi5zY3JvbGxdCiAgICAgICAgY29uc3QgYm91bmRzID0gdmlld3BvcnRFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKQoKICAgICAgICBjb25zdCBzY3JvbGxlciA9IHRoaXMuJGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpCiAgICAgICAgY29uc3Qgc2Nyb2xsZXJQb3NpdGlvbiA9IHNjcm9sbGVyW2RpcmVjdGlvbi5zdGFydF0gLSBib3VuZHNbZGlyZWN0aW9uLnN0YXJ0XQoKICAgICAgICB2aWV3cG9ydCA9IHZpZXdwb3J0RWwKICAgICAgICBzY3JvbGxEaXJlY3Rpb24gPSBkaXJlY3Rpb24uc2Nyb2xsCiAgICAgICAgc2Nyb2xsRGlzdGFuY2UgPSBwb3NpdGlvbiArIHNjcm9sbFRvcCArIHNjcm9sbGVyUG9zaXRpb24KICAgICAgfSBlbHNlIHsKICAgICAgICB2aWV3cG9ydCA9IHRoaXMuJGVsCiAgICAgICAgc2Nyb2xsRGlyZWN0aW9uID0gZGlyZWN0aW9uLnNjcm9sbAogICAgICAgIHNjcm9sbERpc3RhbmNlID0gcG9zaXRpb24KICAgICAgfQoKICAgICAgdmlld3BvcnRbc2Nyb2xsRGlyZWN0aW9uXSA9IHNjcm9sbERpc3RhbmNlCiAgICB9LAoKICAgIGl0ZW1zTGltaXRFcnJvciAoKSB7CiAgICAgIHNldFRpbWVvdXQoKCkgPT4gewogICAgICAgIGNvbnNvbGUubG9nKCdJdCBzZWVtcyB0aGUgc2Nyb2xsZXIgZWxlbWVudCBpc25cJ3Qgc2Nyb2xsaW5nLCBzbyBpdCB0cmllcyB0byByZW5kZXIgYWxsIHRoZSBpdGVtcyBhdCBvbmNlLicsICdTY3JvbGxlcjonLCB0aGlzLiRlbCkKICAgICAgICBjb25zb2xlLmxvZygnTWFrZSBzdXJlIHRoZSBzY3JvbGxlciBoYXMgYSBmaXhlZCBoZWlnaHQgKG9yIHdpZHRoKSBhbmQgXCdvdmVyZmxvdy15XCcgKG9yIFwnb3ZlcmZsb3cteFwnKSBzZXQgdG8gXCdhdXRvXCcgc28gaXQgY2FuIHNjcm9sbCBjb3JyZWN0bHkgYW5kIG9ubHkgcmVuZGVyIHRoZSBpdGVtcyB2aXNpYmxlIGluIHRoZSBzY3JvbGwgdmlld3BvcnQuJykKICAgICAgfSkKICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZW5kZXJlZCBpdGVtcyBsaW1pdCByZWFjaGVkJykKICAgIH0sCgogICAgc29ydFZpZXdzICgpIHsKICAgICAgdGhpcy5wb29sLnNvcnQoKHZpZXdBLCB2aWV3QikgPT4gdmlld0EubnIuaW5kZXggLSB2aWV3Qi5uci5pbmRleCkKICAgIH0sCiAgfSwKfQo="},{"version":3,"sources":["RecycleScroller.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4EA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA","file":"RecycleScroller.vue","sourceRoot":"src/uiComponents/SpherePhoneNumberInput/assets","sourcesContent":["<template>\n    <div\n      v-observe-visibility=\"handleVisibilityChange\"\n      class=\"vue-recycle-scroller\"\n      :class=\"{\n        ready,\n        'page-mode': pageMode,\n        [`direction-${direction}`]: true,\n      }\"\n      @scroll.passive=\"handleScroll\"\n    >\n      <div\n        v-if=\"$slots.before\"\n        ref=\"before\"\n        class=\"vue-recycle-scroller__slot\"\n      >\n        <slot\n          name=\"before\"\n        />\n      </div>\n  \n      <component\n        :is=\"listTag\"\n        ref=\"wrapper\"\n        :style=\"{ [direction === 'vertical' ? 'minHeight' : 'minWidth']: totalSize + 'px' }\"\n        class=\"vue-recycle-scroller__item-wrapper\"\n        :class=\"listClass\"\n      >\n        <component\n          :is=\"itemTag\"\n          v-for=\"view of pool\"\n          :key=\"view.nr.id\"\n          :style=\"ready ? {\n            transform: `translate${direction === 'vertical' ? 'Y' : 'X'}(${view.position}px) translate${direction === 'vertical' ? 'X' : 'Y'}(${view.offset}px)`,\n            width: gridItems ? `${direction === 'vertical' ? itemSecondarySize || itemSize : itemSize}px` : undefined,\n            height: gridItems ? `${direction === 'horizontal' ? itemSecondarySize || itemSize : itemSize}px` : undefined,\n          } : null\"\n          class=\"vue-recycle-scroller__item-view\"\n          :class=\"[\n            itemClass,\n            {\n              hover: !skipHover && hoverKey === view.nr.key\n            },\n          ]\"\n          v-on=\"skipHover ? {} : {\n            mouseenter: () => { hoverKey = view.nr.key },\n            mouseleave: () => { hoverKey = null },\n          }\"\n        >\n          <slot\n            :item=\"view.item\"\n            :index=\"view.nr.index\"\n            :active=\"view.nr.used\"\n          />\n        </component>\n  \n        <slot\n          name=\"empty\"\n        />\n      </component>\n  \n      <div\n        v-if=\"$slots.after\"\n        ref=\"after\"\n        class=\"vue-recycle-scroller__slot\"\n      >\n        <slot\n          name=\"after\"\n        />\n      </div>\n  \n      <ResizeObserver @notify=\"handleResize\" />\n    </div>\n  </template>\n  \n  <script>\n  import { shallowReactive, markRaw } from 'vue'\n  import { ResizeObserver } from 'vue-resize'\n  import { ObserveVisibility } from 'vue-observe-visibility'\n  import { getScrollParent } from '../assets/ScrollParent'\n  import config from '../config'\n  import { props, simpleArray } from './common'\n  import { supportsPassive } from '../assets/util'\n  \n  let uid = 0\n  \n  export default {\n    name: 'RecycleScroller',\n  \n    components: {\n      ResizeObserver,\n    },\n  \n    directives: {\n      ObserveVisibility,\n    },\n  \n    props: {\n      ...props,\n  \n      itemSize: {\n        type: Number,\n        default: null,\n      },\n  \n      gridItems: {\n        type: Number,\n        default: undefined,\n      },\n  \n      itemSecondarySize: {\n        type: Number,\n        default: undefined,\n      },\n  \n      minItemSize: {\n        type: [Number, String],\n        default: null,\n      },\n  \n      sizeField: {\n        type: String,\n        default: 'size',\n      },\n  \n      typeField: {\n        type: String,\n        default: 'type',\n      },\n  \n      buffer: {\n        type: Number,\n        default: 200,\n      },\n  \n      pageMode: {\n        type: Boolean,\n        default: false,\n      },\n  \n      prerender: {\n        type: Number,\n        default: 0,\n      },\n  \n      emitUpdate: {\n        type: Boolean,\n        default: false,\n      },\n  \n      updateInterval: {\n        type: Number,\n        default: 0,\n      },\n  \n      skipHover: {\n        type: Boolean,\n        default: false,\n      },\n  \n      listTag: {\n        type: String,\n        default: 'div',\n      },\n  \n      itemTag: {\n        type: String,\n        default: 'div',\n      },\n  \n      listClass: {\n        type: [String, Object, Array],\n        default: '',\n      },\n  \n      itemClass: {\n        type: [String, Object, Array],\n        default: '',\n      },\n    },\n  \n    emits: [\n      'resize',\n      'visible',\n      'hidden',\n      'update',\n      'scroll-start',\n      'scroll-end',\n    ],\n  \n    data () {\n      return {\n        pool: [],\n        totalSize: 0,\n        ready: false,\n        hoverKey: null,\n      }\n    },\n  \n    computed: {\n      sizes () {\n        if (this.itemSize === null) {\n          const sizes = {\n            '-1': { accumulator: 0 },\n          }\n          const items = this.items\n          const field = this.sizeField\n          const minItemSize = this.minItemSize\n          let computedMinSize = 10000\n          let accumulator = 0\n          let current\n          for (let i = 0, l = items.length; i < l; i++) {\n            current = items[i][field] || minItemSize\n            if (current < computedMinSize) {\n              computedMinSize = current\n            }\n            accumulator += current\n            sizes[i] = { accumulator, size: current }\n          }\n          // eslint-disable-next-line\n          this.$_computedMinItemSize = computedMinSize\n          return sizes\n        }\n        return []\n      },\n  \n      simpleArray,\n  \n      itemIndexByKey () {\n        const { keyField, items } = this\n        const result = {}\n        for (let i = 0, l = items.length; i < l; i++) {\n          result[items[i][keyField]] = i\n        }\n        return result\n      },\n    },\n  \n    watch: {\n      items () {\n        this.updateVisibleItems(true)\n      },\n  \n      pageMode () {\n        this.applyPageMode()\n        this.updateVisibleItems(false)\n      },\n  \n      sizes: {\n        handler () {\n          this.updateVisibleItems(false)\n        },\n        deep: true,\n      },\n  \n      gridItems () {\n        this.updateVisibleItems(true)\n      },\n  \n      itemSecondarySize () {\n        this.updateVisibleItems(true)\n      },\n    },\n  \n    created () {\n      this.$_startIndex = 0\n      this.$_endIndex = 0\n      this.$_views = new Map()\n      this.$_unusedViews = new Map()\n      this.$_scrollDirty = false\n      this.$_lastUpdateScrollPosition = 0\n  \n      // In SSR mode, we also prerender the same number of item for the first render\n      // to avoir mismatch between server and client templates\n      if (this.prerender) {\n        this.$_prerender = true\n        this.updateVisibleItems(false)\n      }\n  \n      if (this.gridItems && !this.itemSize) {\n        console.error('[vue-recycle-scroller] You must provide an itemSize when using gridItems')\n      }\n    },\n  \n    mounted () {\n      this.applyPageMode()\n      this.$nextTick(() => {\n        // In SSR mode, render the real number of visible items\n        this.$_prerender = false\n        this.updateVisibleItems(true)\n        this.ready = true\n      })\n    },\n  \n    activated () {\n      const lastPosition = this.$_lastUpdateScrollPosition\n      if (typeof lastPosition === 'number') {\n        this.$nextTick(() => {\n          this.scrollToPosition(lastPosition)\n        })\n      }\n    },\n  \n    beforeUnmount () {\n      this.removeListeners()\n    },\n  \n    methods: {\n      addView (pool, index, item, key, type) {\n        const nr = markRaw({\n          id: uid++,\n          index,\n          used: true,\n          key,\n          type,\n        })\n        const view = shallowReactive({\n          item,\n          position: 0,\n          nr,\n        })\n        pool.push(view)\n        return view\n      },\n  \n      unuseView (view, fake = false) {\n        const unusedViews = this.$_unusedViews\n        const type = view.nr.type\n        let unusedPool = unusedViews.get(type)\n        if (!unusedPool) {\n          unusedPool = []\n          unusedViews.set(type, unusedPool)\n        }\n        unusedPool.push(view)\n        if (!fake) {\n          view.nr.used = false\n          view.position = -9999\n        }\n      },\n  \n      handleResize () {\n        this.$emit('resize')\n        if (this.ready) this.updateVisibleItems(false)\n      },\n  \n      handleScroll (event) {\n        if (!this.$_scrollDirty) {\n          this.$_scrollDirty = true\n          if (this.$_updateTimeout) return\n  \n          const requestUpdate = () => requestAnimationFrame(() => {\n            this.$_scrollDirty = false\n            const { continuous } = this.updateVisibleItems(false, true)\n  \n            // It seems sometimes chrome doesn't fire scroll event :/\n            // When non continous scrolling is ending, we force a refresh\n            if (!continuous) {\n              clearTimeout(this.$_refreshTimout)\n              this.$_refreshTimout = setTimeout(this.handleScroll, this.updateInterval + 100)\n            }\n          })\n  \n          requestUpdate()\n  \n          // Schedule the next update with throttling\n          if (this.updateInterval) {\n            this.$_updateTimeout = setTimeout(() => {\n              this.$_updateTimeout = 0\n              if (this.$_scrollDirty) requestUpdate()\n            }, this.updateInterval)\n          }\n        }\n      },\n  \n      handleVisibilityChange (isVisible, entry) {\n        if (this.ready) {\n          if (isVisible || entry.boundingClientRect.width !== 0 || entry.boundingClientRect.height !== 0) {\n            this.$emit('visible')\n            requestAnimationFrame(() => {\n              this.updateVisibleItems(false)\n            })\n          } else {\n            this.$emit('hidden')\n          }\n        }\n      },\n  \n      updateVisibleItems (checkItem, checkPositionDiff = false) {\n        const itemSize = this.itemSize\n        const gridItems = this.gridItems || 1\n        const itemSecondarySize = this.itemSecondarySize || itemSize\n        const minItemSize = this.$_computedMinItemSize\n        const typeField = this.typeField\n        const keyField = this.simpleArray ? null : this.keyField\n        const items = this.items\n        const count = items.length\n        const sizes = this.sizes\n        const views = this.$_views\n        const unusedViews = this.$_unusedViews\n        const pool = this.pool\n        const itemIndexByKey = this.itemIndexByKey\n        let startIndex, endIndex\n        let totalSize\n        let visibleStartIndex, visibleEndIndex\n  \n        if (!count) {\n          startIndex = endIndex = visibleStartIndex = visibleEndIndex = totalSize = 0\n        } else if (this.$_prerender) {\n          startIndex = visibleStartIndex = 0\n          endIndex = visibleEndIndex = Math.min(this.prerender, items.length)\n          totalSize = null\n        } else {\n          const scroll = this.getScroll()\n  \n          // Skip update if use hasn't scrolled enough\n          if (checkPositionDiff) {\n            let positionDiff = scroll.start - this.$_lastUpdateScrollPosition\n            if (positionDiff < 0) positionDiff = -positionDiff\n            if ((itemSize === null && positionDiff < minItemSize) || positionDiff < itemSize) {\n              return {\n                continuous: true,\n              }\n            }\n          }\n          this.$_lastUpdateScrollPosition = scroll.start\n  \n          const buffer = this.buffer\n          scroll.start -= buffer\n          scroll.end += buffer\n  \n          // account for leading slot\n          let beforeSize = 0\n          if (this.$refs.before) {\n            beforeSize = this.$refs.before.scrollHeight\n            scroll.start -= beforeSize\n          }\n  \n          // account for trailing slot\n          if (this.$refs.after) {\n            const afterSize = this.$refs.after.scrollHeight\n            scroll.end += afterSize\n          }\n  \n          // Variable size mode\n          if (itemSize === null) {\n            let h\n            let a = 0\n            let b = count - 1\n            let i = ~~(count / 2)\n            let oldI\n  \n            // Searching for startIndex\n            do {\n              oldI = i\n              h = sizes[i].accumulator\n              if (h < scroll.start) {\n                a = i\n              } else if (i < count - 1 && sizes[i + 1].accumulator > scroll.start) {\n                b = i\n              }\n              i = ~~((a + b) / 2)\n            } while (i !== oldI)\n            i < 0 && (i = 0)\n            startIndex = i\n  \n            // For container style\n            totalSize = sizes[count - 1].accumulator\n  \n            // Searching for endIndex\n            for (endIndex = i; endIndex < count && sizes[endIndex].accumulator < scroll.end; endIndex++);\n            if (endIndex === -1) {\n              endIndex = items.length - 1\n            } else {\n              endIndex++\n              // Bounds\n              endIndex > count && (endIndex = count)\n            }\n  \n            // search visible startIndex\n            for (visibleStartIndex = startIndex; visibleStartIndex < count && (beforeSize + sizes[visibleStartIndex].accumulator) < scroll.start; visibleStartIndex++);\n  \n            // search visible endIndex\n            for (visibleEndIndex = visibleStartIndex; visibleEndIndex < count && (beforeSize + sizes[visibleEndIndex].accumulator) < scroll.end; visibleEndIndex++);\n          } else {\n            // Fixed size mode\n            startIndex = ~~(scroll.start / itemSize * gridItems)\n            const remainer = startIndex % gridItems\n            startIndex -= remainer\n            endIndex = Math.ceil(scroll.end / itemSize * gridItems)\n            visibleStartIndex = Math.max(0, Math.floor((scroll.start - beforeSize) / itemSize * gridItems))\n            visibleEndIndex = Math.floor((scroll.end - beforeSize) / itemSize * gridItems)\n  \n            // Bounds\n            startIndex < 0 && (startIndex = 0)\n            endIndex > count && (endIndex = count)\n            visibleStartIndex < 0 && (visibleStartIndex = 0)\n            visibleEndIndex > count && (visibleEndIndex = count)\n  \n            totalSize = Math.ceil(count / gridItems) * itemSize\n          }\n        }\n  \n        if (endIndex - startIndex > config.itemsLimit) {\n          this.itemsLimitError()\n        }\n  \n        this.totalSize = totalSize\n  \n        let view\n  \n        const continuous = startIndex <= this.$_endIndex && endIndex >= this.$_startIndex\n  \n        // Unuse views that are no longer visible\n        if (continuous) {\n          for (let i = 0, l = pool.length; i < l; i++) {\n            view = pool[i]\n            if (view.nr.used) {\n              // Update view item index\n              if (checkItem) {\n                view.nr.index = itemIndexByKey[view.item[keyField]]\n              }\n  \n              // Check if index is still in visible range\n              if (\n                view.nr.index == null ||\n                view.nr.index < startIndex ||\n                view.nr.index >= endIndex\n              ) {\n                this.unuseView(view)\n              }\n            }\n          }\n        }\n  \n        const unusedIndex = continuous ? null : new Map()\n  \n        let item, type\n        let v\n        for (let i = startIndex; i < endIndex; i++) {\n          item = items[i]\n          const key = keyField ? item[keyField] : item\n          if (key == null) {\n            throw new Error(`Key is ${key} on item (keyField is '${keyField}')`)\n          }\n          view = views.get(key)\n  \n          if (!itemSize && !sizes[i].size) {\n            if (view) this.unuseView(view)\n            continue\n          }\n  \n          type = item[typeField]\n  \n          let unusedPool = unusedViews.get(type)\n          let newlyUsedView = false\n  \n          // No view assigned to item\n          if (!view) {\n            if (continuous) {\n              // Reuse existing view\n              if (unusedPool && unusedPool.length) {\n                view = unusedPool.pop()\n              } else {\n                view = this.addView(pool, i, item, key, type)\n              }\n            } else {\n              // Use existing view\n              // We don't care if they are already used\n              // because we are not in continous scrolling\n              v = unusedIndex.get(type) || 0\n  \n              if (!unusedPool || v >= unusedPool.length) {\n                view = this.addView(pool, i, item, key, type)\n                this.unuseView(view, true)\n                unusedPool = unusedViews.get(type)\n              }\n  \n              view = unusedPool[v]\n              unusedIndex.set(type, v + 1)\n            }\n  \n            // Assign view to item\n            views.delete(view.nr.key)\n            view.nr.used = true\n            view.nr.index = i\n            view.nr.key = key\n            view.nr.type = type\n            views.set(key, view)\n  \n            newlyUsedView = true\n          } else {\n            // View already assigned to item\n            if (!view.nr.used) {\n              view.nr.used = true\n              newlyUsedView = true\n              if (unusedPool) {\n                const index = unusedPool.indexOf(view)\n                if (index !== -1) unusedPool.splice(index, 1)\n              }\n            }\n          }\n  \n          // Always set item in case it's a new object with the same key\n          view.item = item\n  \n          if (newlyUsedView) {\n            if (i === items.length - 1) this.$emit('scroll-end')\n            if (i === 0) this.$emit('scroll-start')\n          }\n  \n          // Update position\n          if (itemSize === null) {\n            view.position = sizes[i - 1].accumulator\n            view.offset = 0\n          } else {\n            view.position = Math.floor(i / gridItems) * itemSize\n            view.offset = (i % gridItems) * itemSecondarySize\n          }\n        }\n  \n        this.$_startIndex = startIndex\n        this.$_endIndex = endIndex\n  \n        if (this.emitUpdate) this.$emit('update', startIndex, endIndex, visibleStartIndex, visibleEndIndex)\n  \n        // After the user has finished scrolling\n        // Sort views so text selection is correct\n        clearTimeout(this.$_sortTimer)\n        this.$_sortTimer = setTimeout(this.sortViews, this.updateInterval + 300)\n  \n        return {\n          continuous,\n        }\n      },\n  \n      getListenerTarget () {\n        let target = getScrollParent(this.$el)\n        // Fix global scroll target for Chrome and Safari\n        if (window.document && (target === window.document.documentElement || target === window.document.body)) {\n          target = window\n        }\n        return target\n      },\n  \n      getScroll () {\n        const { $el: el, direction } = this\n        const isVertical = direction === 'vertical'\n        let scrollState\n  \n        if (this.pageMode) {\n          const bounds = el.getBoundingClientRect()\n          const boundsSize = isVertical ? bounds.height : bounds.width\n          let start = -(isVertical ? bounds.top : bounds.left)\n          let size = isVertical ? window.innerHeight : window.innerWidth\n          if (start < 0) {\n            size += start\n            start = 0\n          }\n          if (start + size > boundsSize) {\n            size = boundsSize - start\n          }\n          scrollState = {\n            start,\n            end: start + size,\n          }\n        } else if (isVertical) {\n          scrollState = {\n            start: el.scrollTop,\n            end: el.scrollTop + el.clientHeight,\n          }\n        } else {\n          scrollState = {\n            start: el.scrollLeft,\n            end: el.scrollLeft + el.clientWidth,\n          }\n        }\n  \n        return scrollState\n      },\n  \n      applyPageMode () {\n        if (this.pageMode) {\n          this.addListeners()\n        } else {\n          this.removeListeners()\n        }\n      },\n  \n      addListeners () {\n        this.listenerTarget = this.getListenerTarget()\n        this.listenerTarget.addEventListener('scroll', this.handleScroll, supportsPassive\n          ? {\n              passive: true,\n            }\n          : false)\n        this.listenerTarget.addEventListener('resize', this.handleResize)\n      },\n  \n      removeListeners () {\n        if (!this.listenerTarget) {\n          return\n        }\n  \n        this.listenerTarget.removeEventListener('scroll', this.handleScroll)\n        this.listenerTarget.removeEventListener('resize', this.handleResize)\n  \n        this.listenerTarget = null\n      },\n  \n      scrollToItem (index) {\n        let scroll\n        const gridItems = this.gridItems || 1\n        if (this.itemSize === null) {\n          scroll = index > 0 ? this.sizes[index - 1].accumulator : 0\n        } else {\n          scroll = Math.floor(index / gridItems) * this.itemSize\n        }\n        this.scrollToPosition(scroll)\n      },\n  \n      scrollToPosition (position) {\n        const direction = this.direction === 'vertical'\n          ? { scroll: 'scrollTop', start: 'top' }\n          : { scroll: 'scrollLeft', start: 'left' }\n  \n        let viewport\n        let scrollDirection\n        let scrollDistance\n  \n        if (this.pageMode) {\n          const viewportEl = getScrollParent(this.$el)\n          // HTML doesn't overflow like other elements\n          const scrollTop = viewportEl.tagName === 'HTML' ? 0 : viewportEl[direction.scroll]\n          const bounds = viewportEl.getBoundingClientRect()\n  \n          const scroller = this.$el.getBoundingClientRect()\n          const scrollerPosition = scroller[direction.start] - bounds[direction.start]\n  \n          viewport = viewportEl\n          scrollDirection = direction.scroll\n          scrollDistance = position + scrollTop + scrollerPosition\n        } else {\n          viewport = this.$el\n          scrollDirection = direction.scroll\n          scrollDistance = position\n        }\n  \n        viewport[scrollDirection] = scrollDistance\n      },\n  \n      itemsLimitError () {\n        setTimeout(() => {\n          console.log('It seems the scroller element isn\\'t scrolling, so it tries to render all the items at once.', 'Scroller:', this.$el)\n          console.log('Make sure the scroller has a fixed height (or width) and \\'overflow-y\\' (or \\'overflow-x\\') set to \\'auto\\' so it can scroll correctly and only render the items visible in the scroll viewport.')\n        })\n        throw new Error('Rendered items limit reached')\n      },\n  \n      sortViews () {\n        this.pool.sort((viewA, viewB) => viewA.nr.index - viewB.nr.index)\n      },\n    },\n  }\n  </script>\n  \n  <style>\n  .vue-recycle-scroller {\n    position: relative;\n  }\n  \n  .vue-recycle-scroller.direction-vertical:not(.page-mode) {\n    overflow-y: auto;\n  }\n  \n  .vue-recycle-scroller.direction-horizontal:not(.page-mode) {\n    overflow-x: auto;\n  }\n  \n  .vue-recycle-scroller.direction-horizontal {\n    display: flex;\n  }\n  \n  .vue-recycle-scroller__slot {\n    flex: auto 0 0;\n  }\n  \n  .vue-recycle-scroller__item-wrapper {\n    flex: 1;\n    box-sizing: border-box;\n    overflow: hidden;\n    position: relative;\n  }\n  \n  .vue-recycle-scroller.ready .vue-recycle-scroller__item-view {\n    position: absolute;\n    top: 0;\n    left: 0;\n    will-change: transform;\n  }\n  \n  .vue-recycle-scroller.direction-vertical .vue-recycle-scroller__item-wrapper {\n    width: 100%;\n  }\n  \n  .vue-recycle-scroller.direction-horizontal .vue-recycle-scroller__item-wrapper {\n    height: 100%;\n  }\n  \n  .vue-recycle-scroller.ready.direction-vertical .vue-recycle-scroller__item-view {\n    width: 100%;\n  }\n  \n  .vue-recycle-scroller.ready.direction-horizontal .vue-recycle-scroller__item-view {\n    height: 100%;\n  }\n  </style>"]}]}